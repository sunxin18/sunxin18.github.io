<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[实现regression]]></title>
    <url>%2F2020%2F02%2F01%2Fregression%2F</url>
    <content type="text"><![CDATA[两个error：bias,varianceWhat to do with large bias?1.Add more features as input2.模型更复杂What to do with large variance?1.更多数据2.增加正则化 python1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253from statistics import meanimport numpy as npimport randomimport matplotlib.pyplot as pltfrom matplotlib import stylestyle.use('ggplot')def create_dataset(hm,variance,step=2,correlation=False): val = 1 ys = [] for i in range(hm): y = val + random.randrange(-variance,variance) ys.append(y) if correlation and correlation == 'pos': val+=step elif correlation and correlation == 'neg': val-=step xs = [i for i in range(len(ys))] return np.array(xs, dtype=np.float64),np.array(ys,dtype=np.float64)def best_fit_slope_and_intercept(xs,ys): m = (mean(xs)*mean(ys)-mean(xs*ys)) / (mean(xs)*mean(xs)-mean(xs*xs)) b= mean(ys)-m*mean(xs) return m,bdef squared_error(ys_orig,ys_line): return sum((ys_line - ys_orig) * (ys_line - ys_orig))def coefficient_of_determination(ys_orig,ys_line): y_mean_line = [mean(ys_orig) for y in ys_orig] squared_error_regr = sum((ys_line - ys_orig) * (ys_line - ys_orig)) squared_error_y_mean = sum((y_mean_line - ys_orig) * (y_mean_line - ys_orig)) print(squared_error_regr) print(squared_error_y_mean) r_squared = 1 - (squared_error_regr/squared_error_y_mean) return r_squaredxs, ys = create_dataset(40,40,2,correlation='pos')m, b = best_fit_slope_and_intercept(xs,ys)regression_line = [(m*x)+b for x in xs]r_squared = coefficient_of_determination(ys,regression_line)print(r_squared)plt.scatter(xs,ys,color='#003F72', label = 'data')plt.plot(xs, regression_line, label = 'regression line')plt.legend(loc=4)plt.show() R-square：分子是预测数据与原始数据均值之差的平方和，分母是原始数据和均值之差的平方和R-square=0.5288792849075254]]></content>
      <categories>
        <category>machine learning</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[github解决端口22不能连接错误 error]]></title>
    <url>%2F2020%2F01%2F21%2Ferror%2F</url>
    <content type="text"><![CDATA[报错内容：ssh: connect to host github.com port 22: Connection timed out 解决方法：打开这个文件C:\Program Files\Git\etc\ssh\ssh_config 添加以下内容：Host github.comUser xxxxx@email.comHostname ssh.github.comPreferredAuthentications publickeyIdentityFile ~/.ssh/id_rsaPort 443]]></content>
  </entry>
  <entry>
    <title><![CDATA[gragh]]></title>
    <url>%2F2020%2F01%2F21%2Fgragh%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[linear regression实战（股票预测）]]></title>
    <url>%2F2020%2F01%2F14%2Fmachine-learning%2F</url>
    <content type="text"><![CDATA[从quandl获取股票数据(Open：开盘价Close：收盘价High：最高价Low：最低价Volume：成交量),留下有用的featurepython12345678import pandas as pdimport quandldf =quandl.get("WIKI/GOOGL")df =df[['Adj. Open', 'Adj. High', 'Adj. Low', 'Adj. Close', 'Adj. Volume']]df['HL_PCT'] = (df['Adj. High'] - df['Adj. Low']) / df['Adj. Close'] * 100.0df['PCT_change']=(df['Adj. Close'] - df['Adj. Open']) / df['Adj. Open'] * 100.0df = df[['Adj. Close', 'HL_PCT', 'PCT_change', 'Adj. Volume']]print(df.head()) Adj. Close HL_PCT PCT_change Adj. Volume Date2004-08-19 50.322842 8.072956 0.324968 44659000.02004-08-20 54.322689 7.921706 7.227007 22834300.02004-08-23 54.869377 4.049360 -1.227880 18256100.02004-08-24 52.597363 7.657099 -5.726357 15247300.0 fillna() 函数：有一个inplace参数，默认为false，不会对原来dataframe中进行替换，为True时候会修改原来的 python1234567forecast_col='Adj.Close'df.fillna(value=-9999,inplace=true)forecast_out = int(math.ceil(0.01 * len(df)))#比如现在有100天的数据，去预测未来一天的x=np.array(df.drop(['lable',1]) #当你要删除某一行或者某一列时，用drop函数，它不改变原有的df中的数据，而是返回另一个dataframe来存放删除后的数据y=np..array(df['labble'])X=preprocessing.scale(X) #特征在[-1,1] Fit(): Method calculates the parameters μ and σ and saves them as internal objects.解释：简单来说，就是求得训练集X的均值啊，方差啊，最大值啊，最小值啊这些训练集X固有的属性。可以理解为一个训练过程 Transform(): Method using these calculated parameters apply the transformation to a particular dataset.解释：在Fit的基础上，进行标准化，降维，归一化等操作（看具体用的是哪个工具，如PCA，StandardScaler等）。 Fit_transform(): joins the fit() and transform() method for transformation of dataset.解释：fit_transform是fit和transform的组合，既包括了训练又包含了转换。 python12345678910111213141516171819202122232425262728X_lately = X[-forecast_out:]X_lately=X[-forecast_out:]y = np.array(df['label'])print(len(X), len(y))X_train, X_test, y_train, y_test = model_selection.train_test_split(X, y, test_size=0.2)clf = svm.SVR()#kernel='poly'clf.fit(X_train, y_train)confidence = clf.score(X_test, y_test)forecast_set = clf.predict(X_lately)print(confidence,forecast_set)df['Forecast'] = np.nanlast_date = df.iloc[-1].name #iloc,loc:https://www.jianshu.com/p/f430d4f1b33flast_unix = last_date.timestamp() #转化为时间戳one_day = 86400next_unix = last_unix + one_dayfor i in forecast_set: next_date = datetime.datetime.fromtimestamp(next_unix) next_unix += 86400 df.loc[next_date]= [np.nan for _ in range(len(df.columns)-1)]+[i]df['Adj. Close'].plot()df['Forecast'].plot()plt.legend(loc=4)plt.xlabel('Date')plt.ylabel('Price')plt.show()]]></content>
      <categories>
        <category>machine learning</category>
      </categories>
      <tags>
        <tag>machine learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[dp]]></title>
    <url>%2F2019%2F12%2F06%2Fdp%2F</url>
    <content type="text"><![CDATA[1.最大子序和给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 示例:输入: [-2,1,-3,4,-1,2,1,-5,4],输出: 6解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。c++123456789101112131415class Solution &#123;public: int maxSubArray(vector&lt;int&gt;&amp; nums) &#123; int dp=0,result=nums[0]; for(int i=0;i&lt;nums.size();i++)&#123; if(dp&gt;0) dp=dp+nums[i]; else dp=nums[i]; result=max(result,dp); &#125; return result; &#125;&#125;; 2.最小路径和给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。 说明：每次只能向下或者向右移动一步。 示例: 输入:[ [1,3,1], [1,5,1], [4,2,1]]输出: 7解释: 因为路径 1→3→1→1→1 的总和最小。c++1234567891011121314151617181920class Solution &#123;public: int minPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; if(grid.empty())return 0; int dp[grid.size()][grid[0].size()]; for(int i=0;i&lt;grid.size();i++)&#123; for(int j=0;j&lt;grid[0].size();j++) &#123; if(i==0&amp;&amp;j==0) dp[0][0]=grid[0][0]; else if(i==0) dp[i][j]= dp[i][j-1]+grid[i][j]; else if(j==0) dp[i][j]= dp[i-1][j]+grid[i][j]; else dp[i][j]=min(dp[i-1][j],dp[i][j-1])+grid[i][j]; &#125; &#125; return dp[grid.size()-1][grid[0].size()-1]; &#125;&#125;;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode1]]></title>
    <url>%2F2019%2F07%2F31%2Fleetcode1%2F</url>
    <content type="text"><![CDATA[2.两数相加给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。您可以假设除了数字 0 之外，这两个数都不会以 0 开头。示例：输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807c++12345678910111213141516171819202122232425class Solution &#123;public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123; ListNode *answer = new ListNode(0); ListNode *curr= answer; int sum=0; int carry=0; while(l1!=NULL||l2!=NULL) &#123; int x=(l1!=NULL)?l1-&gt;val:0; int y=(l2!=NULL)?l2-&gt;val:0; sum=x+y+carry; curr-&gt;next= new ListNode(sum%10); curr=curr-&gt;next; carry=sum/10; if(l1!=NULL) l1=l1-&gt;next; if(l2!=NULL) l2=l2-&gt;next; &#125; if (carry &gt; 0) curr-&gt;next = new ListNode(carry); return answer-&gt;next; &#125;&#125;; 9.回文数c++1234567class Solution(object): def isPalindrome(self, x): """ :type x: int :rtype: bool """ return str(x)==str(x)[::-1] 11盛水最多的容器c++12345678910111213141516class Solution &#123;public: int maxArea(vector&lt;int&gt;&amp; height) &#123; int i=0,j=height.size()-1; int result=0; while(i&lt;j) &#123; result=max(result,(j-i)*min(height[i],height[j])); if(height[i]&gt;=height[j]) j--; else i++; &#125; return result; &#125;&#125;; 14.最长公共前缀方法一：c++12345678910111213141516171819class Solution &#123;public: string longestCommonPrefix(vector&lt;string&gt;&amp; strs) &#123; if (strs.size()==0) return ""; string str; for (int i=0;i&lt;strs[0].size();i++)&#123; for(int k=0;k&lt;strs.size()-1;k++) &#123; if (strs[k][i]!=strs[k+1][i]) &#123; return str; &#125; &#125; str=str+strs[0][i]; &#125; return str; &#125;&#125;; 方法二：c++123class Solution: def longestCommonPrefix(self, strs: List[str]) -&gt; str: return os.path.commonprefix(strs) 方法三：c++123456789class Solution: def longestCommonPrefix(self, strs): if not strs: return "" s1 = min(strs) s2 = max(strs) for i,x in enumerate(s1): if x != s2[i]: return s2[:i] return s1 14.三数之和c++123456789101112131415161718192021222324class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123; int target; vector&lt;vector&lt;int&gt;&gt; ans; sort(nums.begin(), nums.end()); for (int i = 0; i &lt; nums.size(); i++) &#123; if ((target = nums[i]) &gt; 0) break; if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) continue; int l = i + 1, r = nums.size() - 1; while (l &lt; r) &#123; if (nums[l] + nums[r] + target &lt; 0) ++l; else if (nums[l] + nums[r] + target &gt; 0) --r; else &#123; ans.push_back(&#123;target, nums[l], nums[r]&#125;); ++l, --r; while (l &lt; r &amp;&amp; nums[l] == nums[l - 1]) ++l; while (l &lt; r &amp;&amp; nums[r] == nums[r + 1]) --r; &#125; &#125; &#125; return ans; &#125;&#125;; 16最近接的三数值和c++123456789101112131415161718192021222324252627class Solution &#123; public: int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) &#123; sort(nums.begin(),nums.end()); int a=nums[0]+nums[1]+nums[2]; for(int i=0;i&lt;nums.size()-2;i++) &#123; if(i&gt;0&amp;&amp;nums[i]==nums[i-1])continue; int l=i+1; int r=nums.size()-1; while(l&lt;r) &#123; int sum=nums[i]+nums[l]+nums[r]; if(abs(sum-target)&lt;abs(a-target)) a=sum; if(sum&gt;target) r--; else if(sum&lt;target) l++; else if(sum==target) return sum; &#125; &#125; return a; &#125;&#125;; 19删除链表倒数第N个节点快慢指针，相差nc++123456789101112131415161718192021class Solution &#123;public: ListNode* removeNthFromEnd(ListNode* head, int n) &#123; ListNode*p1=head; ListNode*p2=head; while(n!=0) &#123; p1=p1-&gt;next; n--; &#125; if(p1==NULL)return head-&gt;next; while((p1-&gt;next)!=NULL) &#123; p1=p1-&gt;next; p2=p2-&gt;next; &#125; p2-&gt;next=p2-&gt;next-&gt;next; return head; &#125;&#125;; 20.有效括号c++1234567891011121314151617181920212223242526class Solution &#123;public: bool isValid(string s) &#123; stack&lt;char&gt;a; if(s.size()%2!=0)return 0; else&#123; for(auto i:s) &#123; if(i=='['||i=='&#123;'||i=='(') a.push(i); else if(a.size()==0&amp;&amp;(i==']'||i=='&#125;'||i==')')) return 0; else if((i==']'&amp;&amp;a.top()!='[')||(i=='&#125;'&amp;&amp;a.top()!='&#123;')||(i==')'&amp;&amp;a.top()!='(')) return 0; else a.pop(); &#125; &#125; if(a.size()!=0) return 0; else return 1; &#125;&#125;; 26删除排序数组中的重复项双指针c++1234567891011121314class Solution &#123;public: int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123; if(nums.size()==0) return 0; int i=0; for(int j=0;j&lt;nums.size();j++) if(nums[i]!=nums[j]) &#123; nums[i+1]=nums[j]; i++; &#125; return i+1; &#125;&#125;; 28实现strSTR()c++1234567891011121314class Solution &#123;public: int strStr(string haystack, string needle) &#123; if (needle.size() == 0) return 0; if (needle.size() &gt; haystack.size()) return -1; if (needle==haystack)return 0; int len=needle.size(); for(int i=0;i&lt;haystack.size()-len+1;i++) &#123; if(needle==haystack.substr(i,len))return i; &#125; return -1; &#125;&#125;; 88.合并两个有序数组从后向前插入数。c++1234567891011121314151617class Solution &#123;public: void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) &#123; int i=m-1; int j=n-1; int len=m+n-1; while(i&gt;=0&amp;&amp;j&gt;=0) &#123; if(nums1[i]&gt;nums2[j]) nums1[len--]=nums1[i--]; else nums1[len--]=nums2[j--]; &#125; while(j&gt;=0) nums1[len--]=nums2[j--]; &#125;&#125;; 颜色分类方法一：c++12345678910111213141516171819202122class Solution &#123;public: void sortColors(vector&lt;int&gt;&amp; nums) &#123; int a=0,b=0,c=0; for(int i=0;i&lt;nums.size();i++) &#123; if(nums[i]==0) a++; if(nums[i]==1) b++; if(nums[i]==2) c++; &#125; int j=0; for(;j&lt;a;j++) nums[j]=0; for(;j&lt;b+a;j++) nums[j]=1; for(;j&lt;a+b+c;j++) nums[j]=2; &#125;&#125;; 方法二：荷兰国旗问题：https://en.wikipedia.org/wiki/Dutch_national_flag_problemc++1234567891011121314151617181920212223class Solution &#123;public: void sortColors(vector&lt;int&gt;&amp; nums) &#123; int p0=0,p2=nums.size()-1; int cur=0; while(cur&lt;=p2) &#123; if(nums[cur]==2) &#123; swap(nums[p2],nums[cur]); p2--; &#125; else if(nums[cur]==1) cur++; else if(nums[cur]==0) &#123; swap(nums[p0],nums[cur]); p0++,cur++; &#125; &#125; &#125;&#125;; 17.电话号码的字母组合c++12345678910111213141516171819202122232425262728class Solution &#123;public: map&lt;char,string&gt; mp=&#123;&#123;'2',"abc"&#125;,&#123;'3',"def"&#125;,&#123;'4',"ghi"&#125;,&#123;'5',"jkl"&#125;,&#123;'6',"mno"&#125;,&#123;'7',"pqrs"&#125;,&#123;'8',"tuv"&#125;,&#123;'9',"wxyz"&#125;&#125;; vector&lt;string&gt;res; void DFS(string cur,string next_word) &#123; if(next_word.size()==0) res.push_back(cur); else &#123; char digit=next_word[0]; string letters=mp[digit]; for(int i=0;i&lt;letters.size();i++) &#123; cur=cur+letters.substr(i,1); next_word=next_word.substr(1); DFS(cur,next_word); &#125; &#125; &#125; vector&lt;string&gt; letterCombinations(string digits)&#123; if(digits.size()==0) return &#123;&#125;; else DFS("",digits); return res; &#125;&#125;;]]></content>
  </entry>
  <entry>
    <title><![CDATA[python数据可视化]]></title>
    <url>%2F2019%2F07%2F22%2Fpython-1%2F</url>
    <content type="text"><![CDATA[数据可视化是指通过可视化表示来搜索数据，与数据挖掘仅仅相关一、安装matplotlib进入命令行，输入pip install matplotlib便会自动安装。二、绘制简单曲线`python #coding=gbkimport matplotlib.pyplot as pltimport numpy as npsquares=[1,4,9,16,25]plt.plot(squares,linewidth=5) #设置标题以及坐标标签plt.title(“Square Numbers”,fontsize=24)plt.xlabel(“Value”,fontsize=14)plt.ylabel(“Square of Value”,fontsize=14) #设置刻度标记的大小plt.tick_params(axis=’both’,labelsize=14)plt.show()]]></content>
  </entry>
  <entry>
    <title><![CDATA[heart]]></title>
    <url>%2F2019%2F05%2F03%2Fheart%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>心里话</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[记录一下]]></title>
    <url>%2F2019%2F04%2F28%2Fwanqing%2F</url>
    <content type="text"><![CDATA[哎]]></content>
      <categories>
        <category>生活</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2013年浙江大学复试机试模拟题]]></title>
    <url>%2F2019%2F03%2F15%2Foj%2F</url>
    <content type="text"><![CDATA[题目描述 Xiao Ming’s parents visit ZJU and Xiao Ming want to take them to look around the campus.They will start from the stone with two famous question raised by President Zhu Kezhen and end at largest dining room in Asia.They want to visit every place exactly once in ZJU’s campus,including the stone and dining room. 输入The input consists of multiple test cases.The first line contains an integer n(n&lt;=20),which means the number of place in ZJU’s campus.We give numbers(from 1 to n ) to the places,especailly,1 means the stone with two famous question and n means the largest dining room.The second line contains an integer m,which means the number of roads between two place.Then follows m lines,each line contain two integer,which means there is a road between these two place.The road will not repeat more than one time. 输出For each test case, you should output one line.If the path exists,you should output 1.Otherwise,you should output 0. 样例输入5 4 1 2 1 3 1 4 2 5 6 6 1 3 3 2 1 2 3 4 4 5 5 6 样例输出0 1 来源2013年浙江大学复试机试模拟题 #include&lt;stdio.h&gt; #include&lt;string.h&gt;int n,m,ok;int vis[22],Map[22][22]; //搜索，已经访问count个地方现在处于location点void DFS(int location,int count){ int i; //已经全部访问完 if(count == n){ //到达目的地n if(location == n){ ok = 1; } return; } //没有访问完，访问下一处 for(i = 1;i &lt;= n;i++){ //i点没访问过且能访问则去i点 if(Map[location][i] == 1&amp;&amp; vis[i] == 0){ //标记i已经访问过 vis[i]=1; //递归下一处 DFS(i,count+1); if(ok == 1){ return; } //取消标记 vis[i] = 0; } }}//初始化void Init(){ int i,j,start,end; //初始化地图 for(i = 1;i &lt;= n;i++){ for(j = 1;j &lt;= n;j++){ Map[i][j]=0; } } //添加路况 for(i = 0;i &lt; m;i++){ scanf(“%d %d”,&amp;start,&amp;end); //end和start之间联通 Map[start][end]=1; Map[end][start]=1; } memset(vis,0,sizeof(vis)); ok = 0; //1为出发点 vis[1]=1;}int main(){ while(scanf(“%d %d”,&amp;n,&amp;m)!=EOF){ Init(); DFS(1,1); printf(“%d\n”,ok); } return 0;}]]></content>
      <categories>
        <category>算法编程</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[准备复试]]></title>
    <url>%2F2019%2F02%2F22%2Fhello-world%2F</url>
    <content type="text"><![CDATA[复试加油，相信自己！]]></content>
      <categories>
        <category>life</category>
      </categories>
  </entry>
</search>

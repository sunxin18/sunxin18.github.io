<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>lalala</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://sunxin18.github.io/"/>
  <updated>2020-03-08T03:20:55.468Z</updated>
  <id>https://sunxin18.github.io/</id>
  
  <author>
    <name>Sunxin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>gragh_convolution</title>
    <link href="https://sunxin18.github.io/2020/03/08/gragh-convolution/"/>
    <id>https://sunxin18.github.io/2020/03/08/gragh-convolution/</id>
    <published>2020-03-08T01:57:31.000Z</published>
    <updated>2020-03-08T03:20:55.468Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="graghsage"><a href="#graghsage" class="headerlink" title="graghsage"></a>graghsage</h1><p>论文链接：<a href="https://arxiv.org/abs/1706.02216" target="_blank" rel="noopener">https://arxiv.org/abs/1706.02216</a></p><p>github链接：<a href="https://github.com/williamleif/GraphSAGE" target="_blank" rel="noopener">https://github.com/williamleif/GraphSAGE</a></p><p>官方介绍链接：<a href="http://snap.stanford.edu/graphsage/" target="_blank" rel="noopener">http://snap.stanford.edu/graphsage/</a></p><p>优秀介绍： <a href="https://blog.csdn.net/yyl424525/article/details/100532849?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">https://blog.csdn.net/yyl424525/article/details/100532849?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task</a></p><h2 id="gcn"><a href="#gcn" class="headerlink" title="gcn"></a>gcn</h2><p>现存的方法需要图中所有的顶点在训练embedding的时候都出现；这些前人的方法本质上是transductive，不能自然地泛化到未见过的顶点。<br><strong>GraphSAGE是为了学习一种节点表示方法，即如何通过从一个顶点的局部邻居采样并聚合顶点特征，而不是为每个顶点训练单独的embedding。</strong><br>GCN虽然能提取图中顶点的embedding，但是存在一些问题：</p><ol><li>GCN的基本思想： 把一个节点在图中的高纬度邻接信息降维到一个低维的向量表示。</li><li>GCN的优点： 可以捕捉graph的全局信息，从而很好地表示node的特征。</li><li>GCN的缺点： Transductive learning的方式，需要把所有节点都参与训练才能得到node embedding，无法快速得到新node的embedding。<br><strong>GCN等transductive的方法，学到的是每个节点的一个唯一确定的embedding； 而GraphSAGE方法学到的node embedding，是根据node的邻居关系的变化而变化的，也就是说，即使是旧的node，如果建立了一些新的link，那么其对应的embedding也会变化，而且也很方便地学到。</strong></li></ol><h1 id="算法概述"><a href="#算法概述" class="headerlink" title="算法概述"></a>算法概述</h1><p><a href="/2020/03/08/gragh-convolution/1.png" data-fancybox="group" data-caption class="fancybox"><img src="/2020/03/08/gragh-convolution/1.png" alt title></a><br>$$K$$:K是网络的层数，也代表着每个顶点能够聚合的邻接点的跳数，如K=2的时候每个顶点可以最多根据其2跳邻接点的信息学习其自身的embedding表示。每增加一层可以聚合更远节点的信息<br>$$N_{(v)}$$:GraphSAGE中每一层的节点邻居都是是从上一层网络采样的，并不是所有邻居参与，并且采样的后的邻居的size是固定的<br><a href="/2020/03/08/gragh-convolution/2.png" data-fancybox="group" data-caption class="fancybox"><img src="/2020/03/08/gragh-convolution/2.png" alt title></a><br>其运行流程如上图所示，可以分为三个步骤：</p><p>对图中每个顶点邻居顶点进行采样，因为每个节点的度是不一致的，为了计算高效， 为每个节点采样固定数量的邻居<br>根据聚合函数聚合邻居顶点蕴含的信息<br>得到图中各顶点的向量表示供下游任务使用</p><h2 id="Neighborhood-definition-采样邻居顶点"><a href="#Neighborhood-definition-采样邻居顶点" class="headerlink" title="Neighborhood definition - 采样邻居顶点"></a>Neighborhood definition - 采样邻居顶点</h2><p>出于对计算效率的考虑，对每个顶点采样一定数量的邻居顶点作为待聚合信息的顶点。设需要的邻居数量，即采样数量为SSS，若顶点邻居数少于SSS,则采用有放回的抽样方法，直到采样出SSS个顶点。若顶点邻居数大于SSS，则采用无放回的抽样。(<strong>即采用有放回的重采样/负采样方法达到SSS</strong>)</p><p>当然，若不考虑计算效率，完全可以对每个顶点利用其所有的邻居顶点进行信息聚合，这样是信息无损的。<br>文中在较大的数据集上实验。因此，统一采样一个固定大小的邻域集，以保持每个batch的计算占用空间是固定的（即 graphSAGE并不是使用全部的相邻节点，而是做了固定size的采样）。</p><p>这样固定size的采样，每个节点和采样后的邻居的个数都相同，可以把每个节点和它们的邻居拼成一个batch送到GPU中进行批训练。<br>论文里说<strong>固定长度的随机游走其实就是随机选择了固定数量的邻居</strong></p><h2 id="聚合函数的选取"><a href="#聚合函数的选取" class="headerlink" title="聚合函数的选取"></a>聚合函数的选取</h2><p>在图中顶点的邻居是无序的，所以希望构造出的聚合函数是对称的（即也就是对它输入的各种排列，函数的输出结果不变），同时具有较高的表达能力。 聚合函数的对称性（symmetry property）确保了神经网络模型可以被训练且可以应用于任意顺序的顶点邻居特征集合上。<br>主要有mean embedding，LSTM,pooling</p><h1 id="代码理解"><a href="#代码理解" class="headerlink" title="代码理解"></a>代码理解</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>word2vec</title>
    <link href="https://sunxin18.github.io/2020/03/06/skipgram/"/>
    <id>https://sunxin18.github.io/2020/03/06/skipgram/</id>
    <published>2020-03-06T02:08:52.000Z</published>
    <updated>2020-03-08T03:21:15.843Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="自然语言模型的发展与引出"><a href="#自然语言模型的发展与引出" class="headerlink" title="自然语言模型的发展与引出"></a>自然语言模型的发展与引出</h1><p><a href="https://www.cnblogs.com/guoyaohua/p/9240336.html" target="_blank" rel="noopener">https://www.cnblogs.com/guoyaohua/p/9240336.html</a><br>基于频率或者预测模型：<a href="https://www.analyticsvidhya.com/blog/2017/06/word-embeddings-count-word2veec/" target="_blank" rel="noopener">https://www.analyticsvidhya.com/blog/2017/06/word-embeddings-count-word2veec/</a><br>语言模型会给一个正常的语句很高的概率<br>unigram:$$P(w_{1},w_{2}…w_{n})=\prod_{i=1}^{n}P(w_{i})$$<br>然而下一个词很大程度会取决于前面序列的词，这样独立概率会让一些愚蠢的语句也可以得到很大的值，所以引出了<br>Bigram model:$$P(w_{1},w_{2}…w_{n})=\prod_{i=2}^{n}P(w_{i}|w_{i-1})$$</p><h1 id="模型解析"><a href="#模型解析" class="headerlink" title="模型解析"></a>模型解析</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>语料(corpus)是指文本所有内容，包括重复的词，词典$$D$$是从语料中抽取出来的不包括重复词语<br>one-hot这种表示方式使得每一个词映射到高维空间中都是互相正交的，也就是说one-hot向量空间中词与词之间没有任何关联关系，这显然与实际情况不符合，因为实际中词与词之间有近义、反义等多种关系。Word2vec虽然学习不到反义这种高层次语义信息，但它巧妙的运用了一种思想：“具有相同上下文的词语包含相似的语义”，使得语义相近的词在映射到欧式空间后中具有较高的余弦相似度</p><h2 id="权重矩阵"><a href="#权重矩阵" class="headerlink" title="权重矩阵"></a>权重矩阵</h2><p> <a href="https://blog.csdn.net/itplus/article/details/37969979" target="_blank" rel="noopener">https://blog.csdn.net/itplus/article/details/37969979</a><br>以skipgram为例主要有两个权重矩阵,第一个是中心词的向量表达矩阵$$V$$,第二个是上下文单词的向量表达矩阵$$U$$,他们都是$$D\times V$$维的<br>下面总结一下计算过程:<br>1.首先输入中心词$$\omega_{t}$$的one-hot编码($$V\times 1$$)<br>2.接着与矩阵$$V$$运算得到中心词的representation $$v_{c}=\omega_{t}\cdot V$$ ($$D\times1)<br>3.下一步就是中心词向量$$v_{c}$$与矩阵$$U$$相乘（$$u_{0}^{T}v_{c}$$,$$u_{0}$$就是矩阵$$U$$的某一行，其实这个就是即某个上下文词的one-hot的表达乘以$$U$$得到representation,$$u_{0}^{T}v_{c}$$这最后得到的就是$$V\times 1$$向量的一维)<br>可以听cs24n的视频讲解</p><ol start="4"><li>下面用softmax把相似性大小转变为概率<br><a href="/2020/03/06/skipgram/1.png" data-fancybox="group" data-caption class="fancybox"><img src="/2020/03/06/skipgram/1.png" alt title></a><br>详细的一个例子：<a href="https://cloud.tencent.com/developer/article/1591734" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1591734</a></li></ol><h2 id="输出层"><a href="#输出层" class="headerlink" title="输出层"></a>输出层</h2><p>对应一颗二叉树，词典中的词作为叶子节点，根据单词出现次数作为权值，构造huffman树，叶子节点一共$$|D|$$个,每一次分支都是二分类，分到左面是负类，右面是正类，<a href="https://blog.csdn.net/itplus/article/details/37969979" target="_blank" rel="noopener">详细过程</a>,<a href="https://www.cnblogs.com/neopenx/p/4571996.html" target="_blank" rel="noopener">https://www.cnblogs.com/neopenx/p/4571996.html</a></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><a href="https://github.com/chrisjmccormick/word2vec_commented" target="_blank" rel="noopener">源代码</a></p><p>#构造一个神经网络，输入词语，输出词向量<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn, optim</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment">#训练数据</span></span><br><span class="line"><span class="comment">#text = "I like dog i like cat i like animal dog cat animal apple cat dog like dog fish milk like dog \</span></span><br><span class="line"><span class="comment">#cat eyes like i like apple apple i hate apple i movie book music like cat dog hate cat dog like"</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'/content/text8'</span>) <span class="keyword">as</span> f: <span class="comment">#colab上的路径</span></span><br><span class="line">    text = f.read()</span><br><span class="line"></span><br><span class="line"><span class="comment">#参数设置</span></span><br><span class="line">EMBEDDING_DIM = <span class="number">2</span> <span class="comment">#词向量维度</span></span><br><span class="line">PRINT_EVERY = <span class="number">1000</span> <span class="comment">#可视化频率</span></span><br><span class="line">EPOCHS = <span class="number">3</span> <span class="comment">#训练的轮数</span></span><br><span class="line">BATCH_SIZE = <span class="number">5</span> <span class="comment">#每一批训练数据大小</span></span><br><span class="line">N_SAMPLES = <span class="number">3</span> <span class="comment">#负样本大小</span></span><br><span class="line">WINDOW_SIZE = <span class="number">5</span> <span class="comment">#周边词窗口大小</span></span><br><span class="line">FREQ = <span class="number">0</span> <span class="comment">#词汇出现频率</span></span><br><span class="line">DELETE_WORDS = <span class="keyword">False</span> <span class="comment">#是否删除部分高频词</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#文本预处理</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">preprocess</span><span class="params">(text, FREQ)</span>:</span></span><br><span class="line">    text = text.lower()</span><br><span class="line">    words = text.split()</span><br><span class="line">    <span class="comment">#去除低频词</span></span><br><span class="line">    word_counts = Counter(words)</span><br><span class="line">    trimmed_words = [word <span class="keyword">for</span> word <span class="keyword">in</span> words <span class="keyword">if</span> word_counts[word] &gt; FREQ]</span><br><span class="line">    <span class="keyword">return</span> trimmed_words</span><br><span class="line">words = preprocess(text, FREQ)</span><br><span class="line"></span><br><span class="line"><span class="comment">#构建词典</span></span><br><span class="line">vocab = set(words)</span><br><span class="line">vocab2int = &#123;w: c <span class="keyword">for</span> c, w <span class="keyword">in</span> enumerate(vocab)&#125;</span><br><span class="line">int2vocab = &#123;c: w <span class="keyword">for</span> c, w <span class="keyword">in</span> enumerate(vocab)&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#将文本转化为数值</span></span><br><span class="line">int_words = [vocab2int[w] <span class="keyword">for</span> w <span class="keyword">in</span> words]</span><br><span class="line"></span><br><span class="line"><span class="comment">#计算单词频次</span></span><br><span class="line">int_word_counts = Counter(int_words)</span><br><span class="line">total_count = len(int_words)</span><br><span class="line">word_freqs = &#123;w: c/total_count <span class="keyword">for</span> w, c <span class="keyword">in</span> int_word_counts.items()&#125;<span class="comment">#items()方法把字典中每对key和value组成一个元组，并把这些元组放在列表中返回。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#去除出现频次高的词汇</span></span><br><span class="line"><span class="keyword">if</span> DELETE_WORDS:</span><br><span class="line">    t = <span class="number">1e-5</span></span><br><span class="line">    prob_drop = &#123;w: <span class="number">1</span>-np.sqrt(t/word_freqs[w]) <span class="keyword">for</span> w <span class="keyword">in</span> int_word_counts&#125;</span><br><span class="line">    train_words = [w <span class="keyword">for</span> w <span class="keyword">in</span> int_words <span class="keyword">if</span> random.random()&lt;(<span class="number">1</span>-prob_drop[w])]</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    train_words = int_words</span><br><span class="line"></span><br><span class="line"><span class="comment">#单词分布</span></span><br><span class="line">word_freqs = np.array(list(word_freqs.values()))</span><br><span class="line">unigram_dist = word_freqs / word_freqs.sum()</span><br><span class="line">noise_dist = torch.from_numpy(unigram_dist ** (<span class="number">0.75</span>) / np.sum(unigram_dist ** (<span class="number">0.75</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment">#获取目标词汇</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_target</span><span class="params">(words, idx, WINDOW_SIZE)</span>:</span></span><br><span class="line">  target_window = np.random.randint(<span class="number">1</span>, WINDOW_SIZE+<span class="number">1</span>)</span><br><span class="line">  start_point = idx-target_window <span class="keyword">if</span> (idx-target_window)&gt;<span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">  end_point = idx+target_window</span><br><span class="line">  targets = set(words[start_point:idx]+words[idx+<span class="number">1</span>:end_point+<span class="number">1</span>])</span><br><span class="line">  <span class="keyword">return</span> list(targets)</span><br><span class="line"></span><br><span class="line"><span class="comment">#批次化数据</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_batch</span><span class="params">(words, BATCH_SIZE, WINDOW_SIZE)</span>:</span></span><br><span class="line">  n_batches = len(words)//BATCH_SIZE</span><br><span class="line">  words = words[:n_batches*BATCH_SIZE]</span><br><span class="line">  <span class="keyword">for</span> idx <span class="keyword">in</span> range(<span class="number">0</span>, len(words), BATCH_SIZE):</span><br><span class="line">    batch_x, batch_y = [],[]</span><br><span class="line">    batch = words[idx:idx+BATCH_SIZE]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(batch)):</span><br><span class="line">      x = batch[i]</span><br><span class="line">      y = get_target(batch, i, WINDOW_SIZE)</span><br><span class="line">      batch_x.extend([x]*len(y))</span><br><span class="line">      batch_y.extend(y)</span><br><span class="line">    <span class="keyword">yield</span> batch_x, batch_y</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义模型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SkipGramNeg</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, n_vocab, n_embed, noise_dist)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self.n_vocab = n_vocab</span><br><span class="line">        self.n_embed = n_embed</span><br><span class="line">        self.noise_dist = noise_dist</span><br><span class="line">        <span class="comment">#定义词向量层</span></span><br><span class="line">        self.in_embed = nn.Embedding(n_vocab, n_embed)</span><br><span class="line">        self.out_embed = nn.Embedding(n_vocab, n_embed)</span><br><span class="line">        <span class="comment">#词向量层参数初始化</span></span><br><span class="line">        self.in_embed.weight.data.uniform_(<span class="number">-1</span>, <span class="number">1</span>)</span><br><span class="line">        self.out_embed.weight.data.uniform_(<span class="number">-1</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="comment">#输入词的前向过程</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward_input</span><span class="params">(self, input_words)</span>:</span></span><br><span class="line">        input_vectors = self.in_embed(input_words)</span><br><span class="line">        <span class="keyword">return</span> input_vectors</span><br><span class="line">    <span class="comment">#目标词的前向过程</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward_output</span><span class="params">(self, output_words)</span>:</span></span><br><span class="line">        output_vectors = self.out_embed(output_words)</span><br><span class="line">        <span class="keyword">return</span> output_vectors</span><br><span class="line">    <span class="comment">#负样本词的前向过程</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward_noise</span><span class="params">(self, size, N_SAMPLES)</span>:</span></span><br><span class="line">        noise_dist = self.noise_dist</span><br><span class="line">        <span class="comment">#从词汇分布中采样负样本</span></span><br><span class="line">        noise_words = torch.multinomial(noise_dist,</span><br><span class="line">                                        size * N_SAMPLES,</span><br><span class="line">                                        replacement=<span class="keyword">True</span>)</span><br><span class="line">        noise_vectors = self.out_embed(noise_words).view(size, N_SAMPLES, self.n_embed)</span><br><span class="line">        <span class="keyword">return</span> noise_vectors</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义损失函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NegativeSamplingLoss</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, input_vectors, output_vectors, noise_vectors)</span>:</span></span><br><span class="line">        BATCH_SIZE, embed_size = input_vectors.shape</span><br><span class="line">        <span class="comment">#将输入词向量与目标词向量作维度转化处理</span></span><br><span class="line">        input_vectors = input_vectors.view(BATCH_SIZE, embed_size, <span class="number">1</span>)</span><br><span class="line">        output_vectors = output_vectors.view(BATCH_SIZE, <span class="number">1</span>, embed_size)</span><br><span class="line">        <span class="comment">#目标词损失</span></span><br><span class="line">        test = torch.bmm(output_vectors, input_vectors)</span><br><span class="line">        out_loss = torch.bmm(output_vectors, input_vectors).sigmoid().log()</span><br><span class="line">        out_loss = out_loss.squeeze()</span><br><span class="line">        <span class="comment">#负样本损失</span></span><br><span class="line">        noise_loss = torch.bmm(noise_vectors.neg(), input_vectors).sigmoid().log()</span><br><span class="line">        noise_loss = noise_loss.squeeze().sum(<span class="number">1</span>)</span><br><span class="line">        <span class="comment">#综合计算两类损失</span></span><br><span class="line">        <span class="keyword">return</span> -(out_loss + noise_loss).mean()</span><br><span class="line"></span><br><span class="line"><span class="comment">#模型、损失函数及优化器初始化</span></span><br><span class="line">model = SkipGramNeg(len(vocab2int), EMBEDDING_DIM, noise_dist=noise_dist)</span><br><span class="line">criterion = NegativeSamplingLoss()</span><br><span class="line">optimizer = optim.Adam(model.parameters(), lr=<span class="number">0.003</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#训练</span></span><br><span class="line">steps = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> e <span class="keyword">in</span> range(EPOCHS):</span><br><span class="line">    <span class="comment">#获取输入词以及目标词</span></span><br><span class="line">    <span class="keyword">for</span> input_words, target_words <span class="keyword">in</span> get_batch(train_words, BATCH_SIZE, WINDOW_SIZE):</span><br><span class="line">        steps += <span class="number">1</span></span><br><span class="line">        inputs, targets = torch.LongTensor(input_words), torch.LongTensor(target_words)</span><br><span class="line">        <span class="comment">#输入、输出以及负样本向量</span></span><br><span class="line">        input_vectors = model.forward_input(inputs)</span><br><span class="line">        output_vectors = model.forward_output(targets)</span><br><span class="line">        size, _ = input_vectors.shape</span><br><span class="line">        noise_vectors = model.forward_noise(size, N_SAMPLES)</span><br><span class="line">        <span class="comment">#计算损失</span></span><br><span class="line">        loss = criterion(input_vectors, output_vectors, noise_vectors)</span><br><span class="line">        <span class="comment">#打印损失</span></span><br><span class="line">        <span class="keyword">if</span> steps%PRINT_EVERY == <span class="number">0</span>:</span><br><span class="line">            print(<span class="string">"loss："</span>,loss)</span><br><span class="line">        <span class="comment">#梯度回传</span></span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line"></span><br><span class="line"><span class="comment">#可视化词向量</span></span><br><span class="line"><span class="keyword">for</span> i, w <span class="keyword">in</span> int2vocab.items() :</span><br><span class="line">    vectors = model.state_dict()[<span class="string">"in_embed.weight"</span>]</span><br><span class="line">    x,y = float(vectors[i][<span class="number">0</span>]),float(vectors[i][<span class="number">1</span>])</span><br><span class="line">    plt.scatter(x,y)</span><br><span class="line">    plt.annotate(w, xy=(x, y), xytext=(<span class="number">5</span>, <span class="number">2</span>), textcoords=<span class="string">'offset points'</span>, ha=<span class="string">'right'</span>, va=<span class="string">'bottom'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></div></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="NLP" scheme="https://sunxin18.github.io/categories/NLP/"/>
    
    
  </entry>
  
  <entry>
    <title>leetcode_day</title>
    <link href="https://sunxin18.github.io/2020/03/02/leetcode-day/"/>
    <id>https://sunxin18.github.io/2020/03/02/leetcode-day/</id>
    <published>2020-03-02T08:39:36.000Z</published>
    <updated>2020-03-03T11:39:35.586Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="3-1"><a href="#3-1" class="headerlink" title="3.1"></a>3.1</h2><h2 id="3-2-链表，迭代，递归"><a href="#3-2-链表，迭代，递归" class="headerlink" title="3.2(链表，迭代，递归)"></a>3.2(链表，迭代，递归)</h2><p>类似于头插法<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(head==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        ListNode* pre=<span class="literal">NULL</span>;</span><br><span class="line">        ListNode* cur=head;</span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">             ListNode* p=cur-&gt;next;</span><br><span class="line">            cur-&gt;next= pre;</span><br><span class="line">            pre=cur;</span><br><span class="line">            cur=p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></p><p>递归：关键就是理解p是反转后链表的表头<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>) <span class="keyword">return</span> head;</span><br><span class="line">        <span class="comment">// 如果当前要反转的节点为 null 或者反转链表为 null</span></span><br><span class="line">    <span class="comment">// head.next 为 null，即反转链表的尾结点不存在，即反转链表不存在</span></span><br><span class="line">        ListNode *p = reverseList(head-&gt;next);<span class="comment">// 节点 p 其实就是反转链表的头节点 </span></span><br><span class="line">        head-&gt;next-&gt;next = head;</span><br><span class="line">        head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></p><h2 id="3-3-数组，双指针"><a href="#3-3-数组，双指针" class="headerlink" title="3.3(数组，双指针)"></a>3.3(数组，双指针)</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; B, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=m<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> j=n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> index=m+n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&gt;=<span class="number">0</span>&amp;&amp;j&gt;=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(B[j]&gt;=A[i])</span><br><span class="line">                A[index--]=B[j--];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                A[index--]=A[i--];</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="keyword">while</span>(j &gt;= <span class="number">0</span>) A[index--] = B[j--];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>nlp</title>
    <link href="https://sunxin18.github.io/2020/02/28/nlp/"/>
    <id>https://sunxin18.github.io/2020/02/28/nlp/</id>
    <published>2020-02-28T12:58:44.000Z</published>
    <updated>2020-02-28T13:31:56.840Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="RNN"><a href="#RNN" class="headerlink" title="RNN"></a>RNN</h1><p>如果用标准神经网络来处理序列的话，因为词向量用one hot表示会有很大的维数，这是很庞大的输入层，第一层权重矩阵就会有很多参数<br>RNN公式：<br><a href="/2020/02/28/nlp/1.png" data-fancybox="group" data-caption class="fancybox"><img src="/2020/02/28/nlp/1.png" alt title></a><br><a href="/2020/02/28/nlp/2.png" data-fancybox="group" data-caption class="fancybox"><img src="/2020/02/28/nlp/2.png" alt title></a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="深度学习" scheme="https://sunxin18.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>论文整理</title>
    <link href="https://sunxin18.github.io/2020/02/25/paper1/"/>
    <id>https://sunxin18.github.io/2020/02/25/paper1/</id>
    <published>2020-02-25T11:06:26.000Z</published>
    <updated>2020-02-28T10:31:20.288Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>论文整理：</p><h1 id="truss："><a href="#truss：" class="headerlink" title="truss："></a>truss：</h1><h2 id="Efficient-Truss-Maintenance-in-Evolving-Networks-2014"><a href="#Efficient-Truss-Maintenance-in-Evolving-Networks-2014" class="headerlink" title="Efficient Truss Maintenance in Evolving Networks(2014)"></a>Efficient Truss Maintenance in Evolving Networks(2014)</h2><p>1证明了每次插入边后，truss最多加1<br>2.插入边后，受影响truss的范围</p><h2 id="Streaming-and-Batch-Algorithms-for-Truss-2019"><a href="#Streaming-and-Batch-Algorithms-for-Truss-2019" class="headerlink" title="Streaming and Batch Algorithms for Truss(2019)"></a>Streaming and Batch Algorithms for Truss(2019)</h2><ol><li>插入一条边后对不同k值边的更新不会互相影响。<br>Decomposition</li></ol><h1 id="core"><a href="#core" class="headerlink" title="core"></a>core</h1><h2 id="K-core-Minimization-An-Edge-Manipulation-Approach-2018"><a href="#K-core-Minimization-An-Edge-Manipulation-Approach-2018" class="headerlink" title="K-core Minimization: An Edge Manipulation Approach(2018)"></a>K-core Minimization: An Edge Manipulation Approach(2018)</h2><p>因为m条里选出b个组合复杂度过高，提出了两个greedy算法，第一个就是对k-core里的每条边删除计算followers，选出b个最优解。第二个算法是对候选集和的优化，只选择k-core图中两个顶点分别为k和大于k的边。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="truss" scheme="https://sunxin18.github.io/tags/truss/"/>
    
      <category term="core" scheme="https://sunxin18.github.io/tags/core/"/>
    
  </entry>
  
  <entry>
    <title>新冠状病毒预测</title>
    <link href="https://sunxin18.github.io/2020/02/25/virus/"/>
    <id>https://sunxin18.github.io/2020/02/25/virus/</id>
    <published>2020-02-25T07:07:31.000Z</published>
    <updated>2020-02-26T02:42:41.932Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>闲来无事，做一个确诊人数的预测吧，希望拐点早日降临。<br>首先数据就是日期和总确诊人数，走势是平缓到爆发到平缓，所以用logistics函数。总治愈目前处于上升趋势，多项式拟合吧。大体思路就是自变量特征从1到总的天数，然后把数字映射到日期，制图。<br>附上代码</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> scipy.optimize <span class="keyword">import</span> curve_fit</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">date_encode</span><span class="params">(date)</span>:</span></span><br><span class="line">    <span class="comment"># '01.24' -&gt; 1 * 100 + 24 = 124</span></span><br><span class="line">    d = date.split(<span class="string">'/'</span>)</span><br><span class="line">    <span class="keyword">return</span> int(d[<span class="number">1</span>]),int(d[<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">date_decode</span><span class="params">(date)</span>:</span></span><br><span class="line">    <span class="comment"># 124 -&gt; '01.24'</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'&#123;&#125;.&#123;&#125;'</span>.format(str(date // <span class="number">100</span>), str(date % <span class="number">100</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">df = pd.read_csv(<span class="string">'data.csv'</span>)<span class="comment">#encoding='utf-8',header=None,sep = '\t'</span></span><br><span class="line">df.drop([<span class="number">33</span>],inplace=<span class="keyword">True</span>)</span><br><span class="line">X = np.array(df.iloc[:,<span class="number">0</span>])    <span class="comment">#日期太多显示会重叠，前十天数据很平缓故先忽略掉</span></span><br><span class="line">cur_month,cur_day=date_encode(X[<span class="number">0</span>])</span><br><span class="line">y = np.array(df[<span class="string">'total_confirmed'</span>])</span><br><span class="line">z= np.array(df[<span class="string">'new_recoveries'</span>])</span><br><span class="line">x = np.arange(len(y))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_date_list</span><span class="params">(cur_month,cur_day,days,prediction=<span class="number">7</span>)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    得到原始数据和预测的日期</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    month_day = [<span class="number">0</span>, <span class="number">31</span>, <span class="number">29</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>]</span><br><span class="line">    ans = []</span><br><span class="line">    n=days+prediction</span><br><span class="line">    <span class="keyword">while</span> n:</span><br><span class="line">        <span class="keyword">if</span> cur_day &lt;= month_day[cur_month]:</span><br><span class="line">            d = <span class="string">"0"</span> + str(cur_day) <span class="keyword">if</span> cur_day &lt; <span class="number">10</span> <span class="keyword">else</span> str(cur_day)</span><br><span class="line">            ans += [str(cur_month) + <span class="string">"/"</span> + d]</span><br><span class="line">            cur_day += <span class="number">1</span></span><br><span class="line">            n=n<span class="number">-1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cur_day = <span class="number">1</span></span><br><span class="line">            cur_month += <span class="number">1</span></span><br><span class="line">            n=n<span class="number">-1</span></span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ans = get_date_list(cur_month,cur_day,len(y),prediction=<span class="number">7</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">logistic_function</span><span class="params">(t, K, P0, r)</span>:</span></span><br><span class="line">    r=<span class="number">0.27</span></span><br><span class="line">    t0 = <span class="number">0</span></span><br><span class="line">    exp = np.exp(r * (t - t0))</span><br><span class="line">    <span class="keyword">return</span> (K * exp * P0) / (K + (exp - <span class="number">1</span>) * P0)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f_3</span><span class="params">(x, A, B, C, D)</span>:</span>  </span><br><span class="line">    <span class="keyword">return</span> A*x*x*x + B*x*x + C*x + D</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">popt, pcov = curve_fit(logistic_function, x, y)</span><br><span class="line">popt1, pcov1 = curve_fit(f_3, x, z)</span><br><span class="line">predict_x = list(x)+[x[<span class="number">-1</span>] + i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">8</span>)] <span class="comment">#数组合并不能直接相加</span></span><br><span class="line">predict_x = np.array(predict_x)</span><br><span class="line">predict_y = logistic_function(predict_x, popt[<span class="number">0</span>], popt[<span class="number">1</span>], popt[<span class="number">2</span>])</span><br><span class="line">predict_y = [int(i) <span class="keyword">for</span> i <span class="keyword">in</span> predict_y]</span><br><span class="line">predict_z = f_3(predict_x, popt1[<span class="number">0</span>], popt1[<span class="number">1</span>], popt1[<span class="number">2</span>],popt1[<span class="number">3</span>])</span><br><span class="line">predict_z = [int(i) <span class="keyword">for</span> i <span class="keyword">in</span> predict_z]</span><br><span class="line"><span class="comment">#print(ans[-7:],predict_y[-7:])</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#输出新增确诊</span></span><br><span class="line">new_infected = [predict_y[i]-predict_y[i<span class="number">-1</span>] <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">-7</span>,<span class="number">0</span>)] </span><br><span class="line">print(ans[<span class="number">-7</span>:],new_infected)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#plt.scatter(x,y,color='purple',label='real')</span></span><br><span class="line"><span class="comment">#plt.plot(x,y,color='gray')</span></span><br><span class="line"><span class="comment">#plt.scatter(predict_x,predict_y,marker='x',color='red',label='predicted data')</span></span><br><span class="line"><span class="comment">#plt.xticks(predict_x,ans,rotation=90)</span></span><br><span class="line"><span class="comment">#plt.suptitle("Logistic Fitting Curve for 2019-nCov total infected numbers", fontsize=16, fontweight="bold")</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#输出新增治愈</span></span><br><span class="line">new_cured = [predict_z[i]-predict_z[i<span class="number">-1</span>] <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">-7</span>,<span class="number">0</span>)] </span><br><span class="line">print(ans[<span class="number">-7</span>:],new_cured)</span><br><span class="line"></span><br><span class="line">plt.scatter(x,z,color=<span class="string">'purple'</span>,label=<span class="string">'real'</span>)</span><br><span class="line">plt.plot(x,z,color=<span class="string">'gray'</span>)</span><br><span class="line">plt.scatter(predict_x,predict_z,marker=<span class="string">'x'</span>,color=<span class="string">'red'</span>,label=<span class="string">'predicted data'</span>)</span><br><span class="line">plt.xticks(predict_x,ans,rotation=<span class="number">90</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">plt.suptitle(<span class="string">"polynomial regression Fitting Curve for 2019-nCov total cured numbers"</span>, fontsize=<span class="number">16</span>, fontweight=<span class="string">"bold"</span>)</span><br><span class="line">plt.xlabel(<span class="string">'date'</span>, fontsize=<span class="number">14</span>)</span><br><span class="line">plt.ylabel(<span class="string">'infected number'</span>, fontsize=<span class="number">14</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></div><p>预测走势<br><a href="/2020/02/25/virus/1.png" data-fancybox="group" data-caption class="fancybox"><img src="/2020/02/25/virus/1.png" alt title></a><br>新增确诊人数：<br><a href="/2020/02/25/virus/2.png" data-fancybox="group" data-caption class="fancybox"><img src="/2020/02/25/virus/2.png" alt title></a><br>新增治愈趋势：<br><a href="/2020/02/25/virus/3.png" data-fancybox="group" data-caption class="fancybox"><img src="/2020/02/25/virus/3.png" alt title></a><br>新增治愈人数：<br><a href="/2020/02/25/virus/4.png" data-fancybox="group" data-caption class="fancybox"><img src="/2020/02/25/virus/4.png" alt title></a></p><h1 id="导出csv文件"><a href="#导出csv文件" class="headerlink" title="导出csv文件"></a>导出csv文件</h1><h2 id="导出文件，list作为列的方法："><a href="#导出文件，list作为列的方法：" class="headerlink" title="导出文件，list作为列的方法："></a>导出文件，list作为列的方法：</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="string">'2020/2/24'</span>, <span class="string">'2020/2/25'</span>, <span class="string">'2020/2/26'</span>, <span class="string">'2020/2/27'</span>, <span class="string">'2020/2/28'</span>, <span class="string">'2020/2/29'</span>, <span class="string">'2020/3/01'</span>]</span><br><span class="line">b = [<span class="number">307</span>, <span class="number">236</span>, <span class="number">181</span>, <span class="number">139</span>, <span class="number">106</span>, <span class="number">81</span>, <span class="number">63</span>]</span><br><span class="line">c = [<span class="number">2818</span>, <span class="number">3019</span>, <span class="number">3229</span>, <span class="number">3447</span>, <span class="number">3673</span>, <span class="number">3909</span>, <span class="number">4153</span>]</span><br><span class="line">data = &#123;<span class="string">'date'</span>:a,<span class="string">'new_confirmed'</span>:b,<span class="string">'new_recoveries'</span>:c&#125;</span><br><span class="line">dataframe = pd.DataFrame(data)</span><br><span class="line">dataframe.to_csv(<span class="string">r'D:\python\test.csv'</span>)</span><br></pre></td></tr></table></figure></div><p>结果<br><a href="/2020/02/25/virus/5.png" data-fancybox="group" data-caption class="fancybox"><img src="/2020/02/25/virus/5.png" alt title></a></p><h2 id="用list导入dataframe是list-行-行"><a href="#用list导入dataframe是list-行-行" class="headerlink" title="用list导入dataframe是list[[行],[行]]"></a>用list导入dataframe是list[[行],[行]]</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">list=[new_infected[i] <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">-7</span>,<span class="number">0</span>)]</span><br><span class="line">list1=[predict_z[i] <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">-7</span>,<span class="number">0</span>)]</span><br><span class="line">list.extend(list1)</span><br><span class="line">list=[list]</span><br><span class="line">column=[<span class="string">'confirmed_day1'</span>,<span class="string">'confirmed_day2'</span>,<span class="string">'confirmed_day3'</span>,<span class="string">'confirmed_day4'</span>,<span class="string">'confirmed_day5'</span>,<span class="string">'confirmed_day6'</span>,<span class="string">'confirmed_day7'</span>,<span class="string">'recovery_day1'</span>,<span class="string">'recovery_day2'</span>,<span class="string">'recovery_day3'</span>,<span class="string">'recovery_day4'</span>,<span class="string">'recovery_day5'</span>,<span class="string">'recovery_day6'</span>,<span class="string">'recovery_day7'</span>]  </span><br><span class="line">test=pd.DataFrame(columns=column,data=list,index=[<span class="string">'total'</span>])</span><br><span class="line">test.to_csv(<span class="string">'D:/test1.csv'</span>)</span><br></pre></td></tr></table></figure></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="机器学习" scheme="https://sunxin18.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="多项式回归" scheme="https://sunxin18.github.io/tags/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%9B%9E%E5%BD%92/"/>
    
      <category term="logistics" scheme="https://sunxin18.github.io/tags/logistics/"/>
    
  </entry>
  
  <entry>
    <title>leetcode1326</title>
    <link href="https://sunxin18.github.io/2020/02/21/leetcode1326/"/>
    <id>https://sunxin18.github.io/2020/02/21/leetcode1326/</id>
    <published>2020-02-21T12:26:26.000Z</published>
    <updated>2020-02-25T10:50:31.790Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ol start="91"><li>解码方式<br>首先分析几个特殊的情况，之后开始dp<br>dp[j]对应s[0]到s[i-1]的译码总数<br>如果s[i]=0,前一位只能是1或2，dp[j]=dp[j-2];<br>如果s[i-1]==’1’或者s[i-1]==’2’&amp;&amp;s[i]&lt;=’6’，这两种情况后两位可以合并或者分开译码s[i-1]和s[i]分开译码就是dp[j-1]，合并译码就是dp[j-2]<br>其他情况就是只能分开译码了</li></ol><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(s[<span class="number">0</span>]==<span class="string">'0'</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(s.length()==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> dp[s.size()+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>]=dp[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,j=<span class="number">2</span>;i&lt;s.size();i++,j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">'0'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i<span class="number">-1</span>]==<span class="string">'1'</span>||s[i<span class="number">-1</span>]==<span class="string">'2'</span>) dp[j]=dp[j<span class="number">-2</span>];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i<span class="number">-1</span>]==<span class="string">'1'</span>||s[i<span class="number">-1</span>]==<span class="string">'2'</span>&amp;&amp;s[i]&lt;=<span class="string">'6'</span>)</span><br><span class="line">                dp[j]=dp[j<span class="number">-1</span>]+dp[j<span class="number">-2</span>];</span><br><span class="line">            <span class="keyword">else</span>  </span><br><span class="line">                 dp[j]=dp[j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[s.size()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><ol start="343"><li>整数拆分<br>给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int integerBreak(int n) &#123;</span><br><span class="line">        vector&lt;int&gt;dp(n+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        dp[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(int i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="keyword">for</span>(int j=i<span class="number">-1</span>;j&gt;=<span class="number">1</span>;j--)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i]=max(dp[i],dp[j]*(i-j));</span><br><span class="line">                dp[i]=max(dp[i],j*(i-j));</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></li></ol><p>357.计算各个位数不同的数字个数<br><a href="/2020/02/21/leetcode1326/1.png" data-fancybox="group" data-caption class="fancybox"><img src="/2020/02/21/leetcode1326/1.png" alt title></a><br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int countNumbersWithUniqueDigits(int n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>;   //n=<span class="number">0</span>时，数组长度为<span class="number">1</span>，运行到dp[<span class="number">1</span>]会指向空地址</span><br><span class="line">        vector&lt;int&gt;dp(n+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>]=<span class="number">10</span>;</span><br><span class="line">        <span class="keyword">for</span>(int i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i]=dp[i<span class="number">-1</span>]+(dp[i<span class="number">-1</span>]-dp[i<span class="number">-2</span>])*(<span class="number">10</span>-(i<span class="number">-1</span>));  之前的解加上新增的i位数情况，i位数是由i<span class="number">-1</span>位数加上一位数，再加的一位数只有<span class="number">10</span>-(i<span class="number">-1</span>)种情况。</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></p><p>以n=3为例，n=2已经计算了0-99之间不重复的数字了，我们需要判断的是100-999之间不重复的数字，那也就只能用10-99之间的不重复的数去组成三位数，而不能使用0-9之间的不重复的数，因为他们也组成不了3位数。而10-99之间不重复的数等于dp[2]-dp[1]。<br>当i=2时，说明之前选取的数字只有1位，那么我们只要与这一位不重复即可，所以其实有9(10-1)种情况（比如1，后面可以跟0,2,3,4,5,6,7,8,9）。当i=3时，说明之前选取的数字有2位，那么我们需要与2位不重复，所以剩余的有8（10-2）种（比如12，后面可以跟0,3,4,5,6,7,8,9）</p><p>1326.灌溉花园的最少水龙头数目</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> dp[<span class="number">10001</span>];</span><br><span class="line">    <span class="keyword">int</span> INF= <span class="number">0x3f3f3f3f</span>;    <span class="comment">//定义为无穷大，意味着无法灌溉</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minTaps</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; ranges)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(dp,INF,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ranges.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> L = max(<span class="number">0</span>,i-ranges[i]);</span><br><span class="line">            <span class="keyword">int</span> R = min(n,i+ranges[i]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = L; j &lt;= R; j++)&#123;</span><br><span class="line">                dp[j] = min(dp[j],dp[L]+<span class="number">1</span>); <span class="comment">//</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n] == INF ? <span class="number">-1</span> : dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="算法编程" scheme="https://sunxin18.github.io/categories/%E7%AE%97%E6%B3%95%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="动态规划" scheme="https://sunxin18.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>面部识别</title>
    <link href="https://sunxin18.github.io/2020/02/20/face/"/>
    <id>https://sunxin18.github.io/2020/02/20/face/</id>
    <published>2020-02-20T03:07:34.000Z</published>
    <updated>2020-03-06T02:10:06.917Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="one-shot"><a href="#one-shot" class="headerlink" title="one shot"></a>one shot</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="计算机视觉" scheme="https://sunxin18.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    
  </entry>
  
  <entry>
    <title>leetcode207</title>
    <link href="https://sunxin18.github.io/2020/02/13/BFS/"/>
    <id>https://sunxin18.github.io/2020/02/13/BFS/</id>
    <published>2020-02-13T13:35:58.000Z</published>
    <updated>2020-03-06T02:18:52.692Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="994-腐烂的橘子"><a href="#994-腐烂的橘子" class="headerlink" title="994.腐烂的橘子"></a>994.腐烂的橘子</h1><p>腐烂橘子的影响范围是周围一圈的橘子，这就是典型的BFS,类似于拓扑排序，每一轮bfs都记录一下<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">orangesRotting</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> dx[]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;,dy[]=&#123;<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;<span class="comment">//方向数组</span></span><br><span class="line">        <span class="keyword">int</span> m=grid.size(),n=grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        <span class="comment">//1、初始化队列：添加烂橘子</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;++i)<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;++j)<span class="keyword">if</span>(grid[i][j]==<span class="number">2</span>)q.push(&#123;i,j&#125;);</span><br><span class="line">       <span class="comment">//2、进行bfs：将每层橘子中四个方向的好橘子感染成烂橘子，并添加到队列中</span></span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> span=q.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;span;++i)&#123;</span><br><span class="line">                pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; p=q.front();q.pop();</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">4</span>;++j)&#123;<span class="comment">//将每个烂橘子的4个方向的好橘子感染成烂橘子</span></span><br><span class="line">                    <span class="keyword">int</span> x=p.first+dx[j],y=p.second+dy[j];</span><br><span class="line">                    <span class="keyword">if</span>(x&gt;=<span class="number">0</span>&amp;&amp;x&lt;m&amp;&amp;y&gt;=<span class="number">0</span>&amp;&amp;y&lt;n&amp;&amp;grid[x][y]==<span class="number">1</span>)&#123;</span><br><span class="line">                        grid[x][y]=<span class="number">2</span>;</span><br><span class="line">                        q.push(&#123;x,y&#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!q.empty())res++;<span class="comment">//感染完一圈的橘子，res+1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;++i)<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;++j)<span class="keyword">if</span>(grid[i][j]==<span class="number">1</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></p><h1 id="207-课程表"><a href="#207-课程表" class="headerlink" title="207.课程表"></a>207.课程表</h1><p>这道题等价于判断图里有没有环，两种方法一个是拓扑排序，一个是DFS</p><h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">      <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; degree(numCourses, <span class="number">0</span>);<span class="comment">//   map&lt;int,int&gt;degree;for(int i=0;i&lt;numCourses;i++)degree[i]=0;</span></span><br><span class="line">  <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;cur;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;prerequisites.size();i++)&#123;</span><br><span class="line">            cur[prerequisites[i][<span class="number">1</span>]].push_back(prerequisites[i][<span class="number">0</span>]);</span><br><span class="line">            degree[prerequisites[i][<span class="number">0</span>]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;degree.size();i++) <span class="comment">//不是cur.size()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(degree[i]==<span class="number">0</span>)</span><br><span class="line">                q.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> node=q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            ans++;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;cur[node].size();i++)</span><br><span class="line">            &#123;</span><br><span class="line">                degree[cur[node][i]]--;</span><br><span class="line">                <span class="keyword">if</span>(degree[cur[node][i]]==<span class="number">0</span>)</span><br><span class="line">                    q.push(cur[node][i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ans==numCourses)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><p>在这里我犯了一个错误，找了半天…啊我的时间都去哪了….<br>对于入度容器我开始设计是<code>C++ map&lt;int,vector&lt;int&gt;&gt;cur</code>这样没有考虑度为0的节点，首先默认节点入度都为0，然后根据图来更新入度，这种情况可以就地改进见注释，或者直接用vector初始化</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="算法编程" scheme="https://sunxin18.github.io/categories/%E7%AE%97%E6%B3%95%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="BFS" scheme="https://sunxin18.github.io/tags/BFS/"/>
    
  </entry>
  
  <entry>
    <title>deep_learning</title>
    <link href="https://sunxin18.github.io/2020/02/13/deep-learning/"/>
    <id>https://sunxin18.github.io/2020/02/13/deep-learning/</id>
    <published>2020-02-13T02:09:02.000Z</published>
    <updated>2020-02-22T00:37:53.148Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="激活函数（Activation-functions）"><a href="#激活函数（Activation-functions）" class="headerlink" title="激活函数（Activation functions）"></a>激活函数（Activation functions）</h1><p>如果不使用激活函数，无论神经网络多少层都会是个线性激活函数<br><a href="/2020/02/13/deep-learning/4.png" data-fancybox="group" data-caption class="fancybox"><img src="/2020/02/13/deep-learning/4.png" alt title></a><br>除了二分类问题，不要使用sigmoid，tanh变现总是更好，但这些函数当z很大时，梯度会很小，训练会很慢，所以推荐relu函数。<br>ReLu函数只要$z$是正值的情况下，导数恒等于1，当是$z$负值的时候，导数恒等于0。从实际上来说，当使用的导数时，$z$=0的导数是没有定义的。但是当编程实现的时候，$z$的取值刚好等于0.00000001，这个值相当小，所以，在实践中，不需要担心这个值，$z$是等于0的时候，假设一个导数是1或者0效果都可以。这里也有另一个版本的Relu被称为Leaky Relu,这个函数通常比Relu激活函数效果要好，尽管在实际中Leaky ReLu使用的并不多.<br><a href="/2020/02/13/deep-learning/3.png" data-fancybox="group" data-caption class="fancybox"><img src="/2020/02/13/deep-learning/3.png" alt title></a><br>对于sigmoid函数$g(z)=\frac{1}{1+e^{-x}}$,他的导数等于$g(z)\times (1-g(z))$<br>对于tanh函数$\frac{e^{x}-e^{-x}}{e^{x}+e^{-x}}$,他的导数等于$1-(tanh(z))^{2}$<br>Relu函数$g(z)=max(0,z)$,leaky Relu函数$g(z)=max(0.01z,z)$</p><h1 id="矩阵的维数"><a href="#矩阵的维数" class="headerlink" title="矩阵的维数"></a>矩阵的维数</h1><p>比如图中的神经网络，第一个隐藏层$z^{[1]}=w^{[1]}x+b^{[1]}$,$z^{[1]}$是3×1的矩阵，$x$是2×1的矩阵，所以$w^{[1]}$是3×2的，总结起来就是$w^{[L]}$是$n^{[L]}\times n^{[L-1]}$的，对$dw$也是一样的，$b^{[L]}$就是$n^{[L]}\times1$的，见图片右半部分<br><a href="/2020/02/13/deep-learning/5.png" data-fancybox="group" data-caption class="fancybox"><img src="/2020/02/13/deep-learning/5.png" alt title></a><br>之后可以将$z^{[1]}$叠加起来，m为样本数量<br><a href="/2020/02/13/deep-learning/6.png" data-fancybox="group" data-caption class="fancybox"><img src="/2020/02/13/deep-learning/6.png" alt title></a></p><h1 id="参数随机初始化（Random-Initialization）"><a href="#参数随机初始化（Random-Initialization）" class="headerlink" title="参数随机初始化（Random+Initialization）"></a>参数随机初始化（Random+Initialization）</h1><p>$W^{[1]}=np.random.rando(2,2)*0.01,b=np.zeros((2,1))$<br>为什么是0.01，而不是100或者1000。我们通常倾向于初始化为很小的随机数。因为如果你用tanh或者sigmoid激活函数，或者说只在输出层有一个Sigmoid，如果$W$很大，$Z$就会很大或者很小，因此这种情况下你很可能停在tanh/sigmoid函数的平坦的地方(见图3.8.2)，这些地方梯度很小也就意味着梯度下降会很慢，因此学习也就很慢。</p><h1 id="正则化（Regularization）"><a href="#正则化（Regularization）" class="headerlink" title="正则化（Regularization）"></a>正则化（Regularization）</h1><p>1.为什么只正则化参数$w$？为什么不再加上参数$b$呢？你可以这么做，只是我习惯省略不写，因为通常是一个高维参数矢量，已经可以表达高偏差问题，可能包含有很多参数，我们不可能拟合所有参数，而$b$只是单个数字，所以$w$几乎涵盖所有参数，而不是$b$，如果加了参数$b$，其实也没太大影响，因为只是众多参数中的一个，所以我通常省略不计，如果你想加上这个参数，完全没问题。</p><p>2.为什么正则化会有用？当$\lambda$增大，$w$接近于0，会减少很多隐藏单元的影响，网络会变得简单，接近于逻辑回归，$z$也会很小($z^{[l]}=w^{[l]}a^{[l-1]}+b^{[l]}$),会呈线性。<br>3.其他正则化方法：数据扩增（比如图片翻转、裁剪、扭曲），early stop<br><a href="/2020/02/13/deep-learning/7.png" data-fancybox="group" data-caption class="fancybox"><img src="/2020/02/13/deep-learning/7.png" alt title></a><br>early stop无法将降低损失函数和过拟合独立处理，会很复杂，所以更倾向L2正则化，虽然要尝试很多不同的$\lambda$，计算代价会很大</p><h1 id="归一化"><a href="#归一化" class="headerlink" title="归一化"></a>归一化</h1><p>为什么要归一化？代价函数看起来会更对称，无论从哪个位置开始都能更直接的找到最小值，可以使用较大的步长。</p><h2 id="padding"><a href="#padding" class="headerlink" title="padding"></a>padding</h2><p>普通的卷积两个缺点，第一个缺点是每次做卷积操作，你的图像就会缩小，从6×6缩小到4×4，你可能做了几次之后，你的图像就会变得很小了，可能会缩小到只有1×1的大小。你可不想让你的图像在每次识别边缘或其他特征时都缩小，这就是第一个缺点。第二个缺点时，如果你注意角落边缘的像素，这个像素点只被一个输出所触碰或者使用，因为它位于这个3×3的区域的一角。但如果是在中间的像素点，就会有许多3×3的区域与之重叠。所以那些在角落或者边缘区域的像素点在输出中采用较少，意味着你丢掉了图像边缘位置的许多信息。<br>对于$N \times N/$的图像，$f \times f$的filter（通常为奇数），paddy为p，步长stride为2，最后得到的矩阵为$[\frac{n+2p-f}{s}+1] \times [\frac{n+2p-f}{s}+1]$,如果这个不是整数，我们向下取整，</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="深度学习" scheme="https://sunxin18.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>knn_application</title>
    <link href="https://sunxin18.github.io/2020/02/10/knn-application/"/>
    <id>https://sunxin18.github.io/2020/02/10/knn-application/</id>
    <published>2020-02-10T06:18:05.000Z</published>
    <updated>2020-02-14T14:36:33.195Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>python counter类:<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">"hello pinsily"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = Counter(s)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d</span><br><span class="line">Counter(&#123;<span class="string">'l'</span>: <span class="number">3</span>, <span class="string">'i'</span>: <span class="number">2</span>, <span class="string">'h'</span>: <span class="number">1</span>, <span class="string">'e'</span>: <span class="number">1</span>, <span class="string">'o'</span>: <span class="number">1</span>, <span class="string">' '</span>: <span class="number">1</span>, <span class="string">'p'</span>: <span class="number">1</span>, <span class="string">'n'</span>: <span class="number">1</span>, <span class="string">'s'</span>: <span class="number">1</span>, <span class="string">'y'</span>: <span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure></div></p><p>most_common(n)<br>返回数量最多的前 n 个元素<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.most_common(<span class="number">3</span>)</span><br><span class="line">[(<span class="string">'l'</span>, <span class="number">3</span>), (<span class="string">'i'</span>, <span class="number">2</span>), (<span class="string">'h'</span>, <span class="number">1</span>)]</span><br></pre></td></tr></table></figure></div></p><p>代码实现：<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> sqrt</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> style</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line">style.use(<span class="string">'fivethirtyeight'</span>)</span><br><span class="line">dataset = &#123;<span class="string">'k'</span>:[[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">1</span>]], <span class="string">'r'</span>:[[<span class="number">6</span>,<span class="number">5</span>],[<span class="number">7</span>,<span class="number">7</span>],[<span class="number">8</span>,<span class="number">6</span>]]&#125;</span><br><span class="line">new_features = [<span class="number">5</span>,<span class="number">7</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> dataset:</span><br><span class="line">    <span class="keyword">for</span> ii <span class="keyword">in</span> dataset[i]:</span><br><span class="line">        plt.scatter(ii[<span class="number">0</span>],ii[<span class="number">1</span>],s=<span class="number">100</span>,color=i)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">k_nearest_neighbors</span><span class="params">(data, predict, k=<span class="number">3</span>)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(data) &gt;= k:</span><br><span class="line">        warnings.warn(<span class="string">'K is set to a value less than total voting groups!'</span>)</span><br><span class="line">        </span><br><span class="line">    distances = []</span><br><span class="line">    <span class="keyword">for</span> group <span class="keyword">in</span> data:</span><br><span class="line">        <span class="keyword">for</span> features <span class="keyword">in</span> data[group]:</span><br><span class="line">            euclidean_distance = np.linalg.norm(np.array(features)-np.array(predict))  <span class="comment">#欧几里得距离</span></span><br><span class="line">            distances.append([euclidean_distance,group])</span><br><span class="line"></span><br><span class="line">    votes = [i[<span class="number">1</span>] <span class="keyword">for</span> i <span class="keyword">in</span> sorted(distances)[:k]]</span><br><span class="line">    vote_result = Counter(votes).most_common(<span class="number">1</span>)[<span class="number">0</span>][<span class="number">0</span>] <span class="comment">#不使用[0][0],得到的是[('r', 3)]. [0][0]得到元组中第一个元素</span></span><br><span class="line">    <span class="keyword">return</span> vote_result</span><br><span class="line"></span><br><span class="line">result = k_nearest_neighbors(dataset,new_features,k=<span class="number">3</span>)</span><br><span class="line">print(result)</span><br><span class="line">plt.scatter(new_features[<span class="number">0</span>],new_features[<span class="number">1</span>],s=<span class="number">50</span>,color=result)<span class="comment">#预测的数据用小红点表示</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></div></p><p>运行结果：<br><a href="/2020/02/10/knn-application/1.png" data-fancybox="group" data-caption class="fancybox"><img src="/2020/02/10/knn-application/1.png" alt title></a><br>然后用这个代码来跑下癌症预测，代码如下<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> style</span><br><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">k_nearest_neighbors</span><span class="params">(data, predict, k=<span class="number">3</span>)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(data) &gt;= k:</span><br><span class="line">        warnings.warn(<span class="string">'K is set to a value less than total voting groups!'</span>)</span><br><span class="line">        </span><br><span class="line">    distances = []</span><br><span class="line">    <span class="keyword">for</span> group <span class="keyword">in</span> data:</span><br><span class="line">        <span class="keyword">for</span> features <span class="keyword">in</span> data[group]:</span><br><span class="line">            euclidean_distance = np.linalg.norm(np.array(features)-np.array(predict))</span><br><span class="line">            distances.append([euclidean_distance,group])</span><br><span class="line"></span><br><span class="line">    votes = [i[<span class="number">1</span>] <span class="keyword">for</span> i <span class="keyword">in</span> sorted(distances)[:k]]</span><br><span class="line">    vote_result = Counter(votes).most_common(<span class="number">1</span>)[<span class="number">0</span>][<span class="number">0</span>] <span class="comment">#不使用[0][0],得到的是[('r', 3)]. [0][0]得到元组中第一个元素</span></span><br><span class="line">    <span class="keyword">return</span> vote_result</span><br><span class="line"></span><br><span class="line">df = pd.read_csv(<span class="string">'breast-cancer-wisconsin.txt'</span>)</span><br><span class="line">df.replace(<span class="string">'?'</span>,<span class="number">-99999</span>,inplace=<span class="keyword">True</span>)</span><br><span class="line">df.drop([<span class="string">'id'</span>],<span class="number">1</span>,inplace=<span class="keyword">True</span>)</span><br><span class="line">full_data = df.astype(float).values.tolist()</span><br><span class="line"></span><br><span class="line">test_size = <span class="number">0.2</span></span><br><span class="line">train_set = &#123;<span class="number">2</span>:[], <span class="number">4</span>:[]&#125;<span class="comment">#良性恶性两个lable</span></span><br><span class="line">test_set = &#123;<span class="number">2</span>:[], <span class="number">4</span>:[]&#125;</span><br><span class="line">train_data = full_data[:-int(test_size*len(full_data))]</span><br><span class="line">test_data = full_data[-int(test_size*len(full_data)):]   <span class="comment">#最后20%</span></span><br><span class="line">correct = <span class="number">0</span></span><br><span class="line">total = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> train_data:</span><br><span class="line">    train_set[i[<span class="number">-1</span>]].append(i[:<span class="number">-1</span>]) <span class="comment">#去掉label，将属性填入</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> test_data:</span><br><span class="line">    test_set[i[<span class="number">-1</span>]].append(i[:<span class="number">-1</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> group <span class="keyword">in</span> test_set:</span><br><span class="line">    <span class="keyword">for</span> data <span class="keyword">in</span> test_set[group]:</span><br><span class="line">        vote = k_nearest_neighbors(train_set, data, k=<span class="number">5</span>)</span><br><span class="line">        <span class="keyword">if</span> group == vote:</span><br><span class="line">            correct += <span class="number">1</span></span><br><span class="line">        total += <span class="number">1</span></span><br><span class="line">print(<span class="string">'Accuracy:'</span>, correct/total)</span><br></pre></td></tr></table></figure></div></p><p><a href="/2020/02/10/knn-application/2.png" data-fancybox="group" data-caption class="fancybox"><img src="/2020/02/10/knn-application/2.png" alt title></a><br>准确度很高！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="机器学习" scheme="https://sunxin18.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="KNN" scheme="https://sunxin18.github.io/tags/KNN/"/>
    
      <category term="python" scheme="https://sunxin18.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>leetcode113</title>
    <link href="https://sunxin18.github.io/2020/02/08/leetcode113/"/>
    <id>https://sunxin18.github.io/2020/02/08/leetcode113/</id>
    <published>2020-02-08T10:50:42.000Z</published>
    <updated>2020-02-28T10:53:30.465Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>112.给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        sum=sum-root-&gt;val;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left==<span class="literal">NULL</span>&amp;&amp;root-&gt;right==<span class="literal">NULL</span>&amp;&amp;sum==<span class="number">0</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> hasPathSum(root-&gt;left,sum)||hasPathSum(root-&gt;right,sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></p><p>对于113题，做一点思考，看下面两段代码：<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;res;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;path;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; pathSum(TreeNode* root, <span class="keyword">int</span> sum) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> res;</span><br><span class="line">        DFS(path,root,sum);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;path,TreeNode* root, <span class="keyword">int</span> sum)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        path.push_back(root-&gt;val);</span><br><span class="line">        sum=sum-root-&gt;val;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left==<span class="literal">NULL</span>&amp;&amp;root-&gt;right==<span class="literal">NULL</span>&amp;&amp;sum==<span class="number">0</span>)res.push_back(path);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="keyword">if</span>(root-&gt;left)</span><br><span class="line">            &#123;</span><br><span class="line">                 DFS(path,root-&gt;left,sum);</span><br><span class="line">                 path.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;right)</span><br><span class="line">            &#123;</span><br><span class="line">                DFS(path,root-&gt;right,sum);</span><br><span class="line">                path.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></p><p><a href="/2020/02/08/leetcode113/1.png" data-fancybox="group" data-caption class="fancybox"><img src="/2020/02/08/leetcode113/1.png" alt title></a><br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;res;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;path;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; pathSum(TreeNode* root, <span class="keyword">int</span> sum) &#123;<span class="comment">//!!!!!!</span></span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> res;</span><br><span class="line">        DFS(path,root,sum);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;path,TreeNode* root, <span class="keyword">int</span> sum)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        path.push_back(root-&gt;val);</span><br><span class="line">        sum=sum-root-&gt;val;</span><br><span class="line">        <span class="keyword">if</span>(sum==<span class="number">0</span>&amp;&amp;root-&gt;left==<span class="literal">NULL</span>&amp;&amp;root-&gt;right==<span class="literal">NULL</span>)res.push_back(path);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="keyword">if</span>(root-&gt;left)</span><br><span class="line">            &#123;</span><br><span class="line">                 DFS(path,root-&gt;left,sum); <span class="comment">//!!!!!!</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;right)</span><br><span class="line">            &#123;</span><br><span class="line">                DFS(path,root-&gt;right,sum);<span class="comment">//!!!!!!</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">![](<span class="number">2.</span>png)</span><br></pre></td></tr></table></figure></div></p><p>区别主要是，第一种每层递归函数都使用的一个容器，所以要加上引用，递归返回需要弹出之前的元素，而第二种是每次递归函数都复制一个容器。</p><p>17.电话号码的字母组合<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="built_in">string</span>&gt; mp=&#123;&#123;<span class="string">'2'</span>,<span class="string">"abc"</span>&#125;,&#123;<span class="string">'3'</span>,<span class="string">"def"</span>&#125;,&#123;<span class="string">'4'</span>,<span class="string">"ghi"</span>&#125;,&#123;<span class="string">'5'</span>,<span class="string">"jkl"</span>&#125;,&#123;<span class="string">'6'</span>,<span class="string">"mno"</span>&#125;,&#123;<span class="string">'7'</span>,<span class="string">"pqrs"</span>&#125;,&#123;<span class="string">'8'</span>,<span class="string">"tuv"</span>&#125;,&#123;<span class="string">'9'</span>,<span class="string">"wxyz"</span>&#125;&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;res;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="built_in">string</span> cur,<span class="built_in">string</span> next_word)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(next_word.size()==<span class="number">0</span>)</span><br><span class="line">            res.push_back(cur);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span> digit=next_word[<span class="number">0</span>];</span><br><span class="line">            <span class="built_in">string</span> letters=mp[digit];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;letters.size();i++)</span><br><span class="line">            &#123;</span><br><span class="line">                cur=cur+letters.substr(i,<span class="number">1</span>);</span><br><span class="line">                next_word=next_word.substr(<span class="number">1</span>);</span><br><span class="line">                DFS(cur,next_word);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; letterCombinations(<span class="built_in">string</span> digits)&#123;</span><br><span class="line">          <span class="keyword">if</span>(digits.size()==<span class="number">0</span>)</span><br><span class="line">              <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">              DFS(<span class="string">""</span>,digits);</span><br><span class="line">          <span class="keyword">return</span> res;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></p><p>93.复原IP地址<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">       vector&lt;string&gt; res;</span><br><span class="line">    </span><br><span class="line">    vector&lt;string&gt; restoreIpAddresses(string s) &#123;</span><br><span class="line">        string temp;</span><br><span class="line">        dfs(s,temp,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void dfs(string s,string &amp;temp,int num)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(num==<span class="number">4</span>)&#123;</span><br><span class="line">           <span class="keyword">if</span>(s.empty())res.push_back(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(num&gt;<span class="number">0</span>)temp+=<span class="string">'.'</span>;</span><br><span class="line">            <span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;<span class="number">4</span>&amp;&amp; i &lt;= s.length();i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(valid(s.substr(<span class="number">0</span>,i)))</span><br><span class="line">                &#123;</span><br><span class="line">                      temp=temp+s.substr(<span class="number">0</span>,i);</span><br><span class="line">                     dfs(s.substr(i,s.length()-i),temp,num+<span class="number">1</span>);</span><br><span class="line">                     temp.erase(temp.length()-i,i);</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">                  temp.pop_back();       </span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"> bool valid(const string&amp; s)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.empty() || (s[<span class="number">0</span>] == <span class="string">'0'</span> &amp;&amp; s.size()&gt;<span class="number">1</span>) ) <span class="keyword">return</span> false;</span><br><span class="line">        int val = stoi(s);</span><br><span class="line">        <span class="keyword">if</span>(val &gt;= <span class="number">0</span> &amp;&amp; val &lt;= <span class="number">255</span>) <span class="keyword">return</span> true;</span><br><span class="line">        <span class="keyword">return</span> false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="算法编程" scheme="https://sunxin18.github.io/categories/%E7%AE%97%E6%B3%95%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="DFS" scheme="https://sunxin18.github.io/tags/DFS/"/>
    
      <category term="树" scheme="https://sunxin18.github.io/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>Pagerank</title>
    <link href="https://sunxin18.github.io/2020/02/07/pagerank/"/>
    <id>https://sunxin18.github.io/2020/02/07/pagerank/</id>
    <published>2020-02-07T11:28:45.000Z</published>
    <updated>2020-02-15T13:26:41.829Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="The-web-as-a-graph"><a href="#The-web-as-a-graph" class="headerlink" title="The web as a graph"></a>The web as a graph</h1><p>pagerank是谷歌用来计算网页重要性的算法，我们把网页想象成节点，超链接想象成边，这就形成了一张有向图。<br>当然我们只考虑静态网页，不考虑防火墙拦截、无法访问这些情况。</p><p>两种有向图：<br>1.强连通图Strongly connected graphs：任意节点可以到达任意节点。<br>2.有向无环图Directed Acyclic Graph (DAG):首先没有环，u能达到v，但v不能达到u。<br>求strongly connected components (SCCs):对给定节点分别求入度和出度的BFS,然后对两个集合求交集<br><a href="/2020/02/07/pagerank/1.png" data-fancybox="group" data-caption class="fancybox"><img src="/2020/02/07/pagerank/1.png" alt title></a></p><h1 id="Bowtie-structure-of-the-web-graph"><a href="#Bowtie-structure-of-the-web-graph" class="headerlink" title="Bowtie structure of the web graph"></a>Bowtie structure of the web graph</h1><p>Broder et al. (1999) took a large snapshot of the web and tried to understand how the SCCs in the web graph fit together as a DAG<br>这张图Here the starting nodes are sorted by the number of nodes that BFS visits when starting from that node<br><a href="/2020/02/07/pagerank/2.png" data-fancybox="group" data-caption class="fancybox"><img src="/2020/02/07/pagerank/2.png" alt title></a><br>图中蓝色节点只能访问一小部分节点，紫红色节点可以访问很多节点<br>通过这个我们可以得出网络中的图组成<a href="/2020/02/07/pagerank/3.png" data-fancybox="group" data-caption class="fancybox"><img src="/2020/02/07/pagerank/3.png" alt title></a></p><h1 id="PageRank-Ranking-nodes-on-the-graph"><a href="#PageRank-Ranking-nodes-on-the-graph" class="headerlink" title="PageRank - Ranking nodes on the graph"></a>PageRank - Ranking nodes on the graph</h1><p>核心想法是吧links当作votes，一个节点的重要性是由被所指向的其他节点决定的<br><a href="/2020/02/07/pagerank/4.png" data-fancybox="group" data-caption class="fancybox"><img src="/2020/02/07/pagerank/4.png" alt title></a><br>公式为$r_{j}= \sum _ {i \rightarrow j}\frac{r_{i}}{d_{i}}$</p><h2 id="Matrix-formulation"><a href="#Matrix-formulation" class="headerlink" title="Matrix formulation"></a>Matrix formulation</h2><p>这种计算方法需要N个式子，需要很长的时间。所以我们用邻接矩阵M来代替，M的每个列的和为1$if j \rightarrow i,then W_{^{ij}}=\frac{1}{d_{j}}$,则$r=Mr$，如下图的计算过程<br><a href="/2020/02/07/pagerank/5.png" data-fancybox="group" data-caption class="fancybox"><img src="/2020/02/07/pagerank/5.png" alt title></a><br>之后进行不断地迭代，$M(M…(M(Mr)$直到$|r-r^{‘}|&lt; \varepsilon$</p><h1 id="PageRank-Problems"><a href="#PageRank-Problems" class="headerlink" title="PageRank: Problems"></a>PageRank: Problems</h1><p>1.dead ends:没有out-links<br><a href="/2020/02/07/pagerank/6.png" data-fancybox="group" data-caption class="fancybox"><img src="/2020/02/07/pagerank/6.png" alt title></a><br>2.Spider traps：节点发出的边只有自环，最终会吸收所有的重要性，比如图中b会聚集所有的重要性，a会没有重要性<br><a href="/2020/02/07/pagerank/7.png" data-fancybox="group" data-caption class="fancybox"><img src="/2020/02/07/pagerank/7.png" alt title></a></p><h2 id="解决方法是random-teleportation或者random-jumps"><a href="#解决方法是random-teleportation或者random-jumps" class="headerlink" title="解决方法是random teleportation或者random jumps"></a>解决方法是random teleportation或者random jumps</h2><p>当一次随机游走完成，下次网上冲浪有两种选择，有概率$\beta $跟随link，$1-\beta $跳到其它网页,跳到其他的网页节点有相同的可能性，$\beta $通常设定在0.8到0.9<br>综合起来就是:$r_{j}= \sum _ {i\rightarrow j}\frac{r_{i}}{d_{i}}+(1-\beta )\frac{1}{N}$<br>下面可以定义谷歌矩阵$A= \beta \times M+(1-\beta )[\frac{1}{N}]_ {N \times N}$，$r=A \times r$<br>注意这个公式假设M没有dead ends。我们可以提前处理矩阵M去除dead ends或者使用概率为1的随机random teleports</p><h2 id="Computing-PageRank-Sparse-matrix-formulation"><a href="#Computing-PageRank-Sparse-matrix-formulation" class="headerlink" title="Computing PageRank: Sparse matrix formulation"></a>Computing PageRank: Sparse matrix formulation</h2><p>但是这样对于节点太多的话，存储矩阵$A(N\times N)$需要大量的空间，我们可以这样来计算：$r=\beta M \times r+\frac{1-\beta }{N}$ , $\frac{1-\beta }{N}$是一个向量，因为这样M是个稀疏矩阵，与向量乘机就没有那么大的计算量了<br><a href="/2020/02/07/pagerank/8.png" data-fancybox="group" data-caption class="fancybox"><img src="/2020/02/07/pagerank/8.png" alt title></a><br>下面给出完整的算法流程<br><a href="/2020/02/07/pagerank/9.png" data-fancybox="group" data-caption class="fancybox"><img src="/2020/02/07/pagerank/9.png" alt title></a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="图" scheme="https://sunxin18.github.io/categories/%E5%9B%BE/"/>
    
    
      <category term="pagerank" scheme="https://sunxin18.github.io/tags/pagerank/"/>
    
  </entry>
  
  <entry>
    <title>gragh representation learning(图的表征学习)</title>
    <link href="https://sunxin18.github.io/2020/02/06/representation-learning/"/>
    <id>https://sunxin18.github.io/2020/02/06/representation-learning/</id>
    <published>2020-02-06T06:59:24.000Z</published>
    <updated>2020-03-06T02:09:59.456Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>核心思想：map each node in a network into a low-dimensional space把每个节点映射到低维空间<br>在学习一个网络表示的时候需要注意的几个性质：</p><ol><li><strong>适应性</strong>，网络表示必须能适应网络的变化。网络是一个动态的图，不断地会有新的节点和边添加进来，网络表示需要适应网络的正常演化。</li><li><strong>属于同一个社区的节点有着类似的表示</strong>。网络中往往会出现一些特征相似的点构成的团状结构，这些节点表示成向量后必须相似。</li><li><strong>低维</strong>。代表每个顶点的向量维数不能过高，过高会有过拟合的风险，对网络中有缺失数据的情况处理能力较差。</li><li><strong>连续性</strong>。低维的向量应该是连续的。<h1 id="Embedding-Nodes"><a href="#Embedding-Nodes" class="headerlink" title="Embedding Nodes"></a>Embedding Nodes</h1>node embedding的目标是在原网络的similarity近似于embedding space的相似度（内积）<br>1.定义一个encoder(i.e., a mapping from nodes to embeddings)<br>2.定义相似度函数（原始网络中的相似度）<br>3.优化encoder的参数，使得原始网络中u，v的相似度近似于embedding的点积<br><a href="/2020/02/06/representation-learning/1.png" data-fancybox="group" data-caption class="fancybox"><img src="/2020/02/06/representation-learning/1.png" alt title></a></li></ol><h1 id="deep-walk"><a href="#deep-walk" class="headerlink" title="deep walk"></a>deep walk</h1><p>given a graph and a starting point, we select a neighbor of it at random, and move to this neighbor; then we select a neighbor of this point at random, and move to it, etc. The (random) sequence of points selected this way is a random walk on the graph. So $similarity(u,v)$ is defined as the probability that<br>u and v co-occur on a random walk over a network.</p><p>思想来源于语言模型，我们想要在所有训练短语中最大化概率$Pr(w_{n}|w_{0},w_{1},….,w_{n-1})$，The direct analog is to estimate the likelihood of observing vertex vi given all the previous vertices visited so far in the random walk.<br>deep walk中算法主要包括两个部分，一个是random walk gengerator，第二个是更新程序.<br><a href="https://zhuanlan.zhihu.com/p/45167021" target="_blank" rel="noopener">deep walk 论文笔记</a></p><p>random-walk embeddings有如下几步：<br>1.Estimate probability of visiting node v on a random walk starting from node u using some random walk strategy R. The simplest idea is just to run fixed-length, unbiased random walks starting from each node <a href="https://arxiv.org/abs/1403.6652" target="_blank" rel="noopener">i.e., DeepWalk from Perozzi et al., 2013</a><br>2.Optimize embeddings to encode these random walk statistics, so the similarity between embeddings (e.g., dot product) encodes Random Walk similarity.</p><h2 id="deep-walk配置"><a href="#deep-walk配置" class="headerlink" title="deep walk配置"></a>deep walk配置</h2><ol><li><p>首先克隆代码到本地，进入目录<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><figcaption><span>C:\Users\Administrator\Downloads\deepwalk-master```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2. 执行```pip install -r requirements.txt</span><br></pre></td></tr></table></figure></div></p></li><li><p>执行<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><figcaption><span>setup.py install```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4.</span> 执行```deepwalk --input example_graphs/karate.adjlist --output karate.embeddings</span><br></pre></td></tr></table></figure></div></p></li></ol><p><a href="/2020/02/06/representation-learning/4.png" data-fancybox="group" data-caption class="fancybox"><img src="/2020/02/06/representation-learning/4.png" alt title></a><br>embedding结果：<br><a href="/2020/02/06/representation-learning/5.png" data-fancybox="group" data-caption class="fancybox"><img src="/2020/02/06/representation-learning/5.png" alt title></a></p><p>代码的解读：<a href="https://blog.csdn.net/github_36326955/article/details/82702379" target="_blank" rel="noopener">https://blog.csdn.net/github_36326955/article/details/82702379</a></p><h1 id="Random-walk-optimization-and-Negative-Sampling"><a href="#Random-walk-optimization-and-Negative-Sampling" class="headerlink" title="Random walk optimization and Negative Sampling"></a>Random walk optimization and Negative Sampling</h1><p>待更新</p><h1 id="Node2vec"><a href="#Node2vec" class="headerlink" title="Node2vec"></a>Node2vec</h1><p>考虑灵活变长的random walk，可以权衡网络的局部和全局的结构，有两种策略BFS,DFS<br><a href="/2020/02/06/representation-learning/2.png" data-fancybox="group" data-caption class="fancybox"><img src="/2020/02/06/representation-learning/2.png" alt title></a><br>定义两个参数，p为返回之前节点的概率，q来调节DFS，BFS<br><a href="/2020/02/06/representation-learning/3.png" data-fancybox="group" data-caption class="fancybox"><img src="/2020/02/06/representation-learning/3.png" alt title></a><br>算法：<br>1.估算random walk概率<br>2.对于每个节点u模拟r次长度为l的random walk<br>3.使用随机梯度下降进行更新</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="图" scheme="https://sunxin18.github.io/categories/%E5%9B%BE/"/>
    
    
      <category term="embedding" scheme="https://sunxin18.github.io/tags/embedding/"/>
    
      <category term="负采样，deep walk" scheme="https://sunxin18.github.io/tags/%E8%B4%9F%E9%87%87%E6%A0%B7%EF%BC%8Cdeep-walk/"/>
    
  </entry>
  
  <entry>
    <title>hashtbale</title>
    <link href="https://sunxin18.github.io/2020/02/04/hashtbale/"/>
    <id>https://sunxin18.github.io/2020/02/04/hashtbale/</id>
    <published>2020-02-04T14:32:43.000Z</published>
    <updated>2020-02-05T12:57:39.401Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目49<br>给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。</p><p>思路：哈希表，对排序后的单词作为索引。<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; groupAnagrams(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;res;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;cur;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> str:strs)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> s=str;</span><br><span class="line">            sort(s.begin(),s.end());</span><br><span class="line">            cur[s].push_back(str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it=cur.begin();it!=cur.end();it++)</span><br><span class="line">            res.push_back(it-&gt;second);</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="算法编程" scheme="https://sunxin18.github.io/categories/%E7%AE%97%E6%B3%95%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="字符串" scheme="https://sunxin18.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="哈希表" scheme="https://sunxin18.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>C++编程总结(持续更新)</title>
    <link href="https://sunxin18.github.io/2020/02/03/C/"/>
    <id>https://sunxin18.github.io/2020/02/03/C/</id>
    <published>2020-02-03T14:07:37.000Z</published>
    <updated>2020-02-04T03:38:24.855Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="删除末尾字符"><a href="#删除末尾字符" class="headerlink" title="删除末尾字符"></a>删除末尾字符</h2><p>1.str = str.substr(0, str.length() - 1);<br>2.str.erase(str.end() - 1);<br>3.str.pop_back();</p><h1 id="图编程"><a href="#图编程" class="headerlink" title="图编程"></a>图编程</h1><p>1.以u为顶点出发寻找与u，v能构成三角形的顶点w是，需要遍历u的临边，要注意过跳过v，添加if（v==w）continue<br>2.变量的作用域重叠，导致后来定义会覆盖掉之前的，应定义新的变量<br>3.入队出队寻找followers时，忘记对访问过的边做已访问标记，导致队列不会走空，进入无限循环，运行时间很久，诊断发现内存不断增加。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="算法编程" scheme="https://sunxin18.github.io/categories/%E7%AE%97%E6%B3%95%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="C++" scheme="https://sunxin18.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>2.3</title>
    <link href="https://sunxin18.github.io/2020/02/03/2-3/"/>
    <id>https://sunxin18.github.io/2020/02/03/2-3/</id>
    <published>2020-02-03T12:34:59.000Z</published>
    <updated>2020-02-05T12:57:13.807Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目402：给定一个以字符串表示的非负整数 num，移除这个数中的 k 位数字，使得剩下的数字最小。<br>测试用例  112,<br>思路要想使移除k个元素后的数最小，则应该移除最靠左的k个相邻逆序对，包括在一次移除后形成的新的逆序对.</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">removeKdigits</span><span class="params">(<span class="built_in">string</span> num, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">int</span> n = num.size(), m = n - k;        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : num) &#123;</span><br><span class="line">            <span class="keyword">while</span> (k &amp;&amp; res.size() &amp;&amp; res.back() &gt; c) &#123;</span><br><span class="line">                res.pop_back();</span><br><span class="line">                --k;</span><br><span class="line">            &#125;</span><br><span class="line">            res.push_back(c);</span><br><span class="line">        &#125;</span><br><span class="line">        res.resize(m);</span><br><span class="line">        <span class="comment">//去除前导0， 如10200，k = 1</span></span><br><span class="line">        <span class="keyword">while</span> (!res.empty() &amp;&amp; res[<span class="number">0</span>] == <span class="string">'0'</span>) &#123;</span><br><span class="line">            res.erase(res.begin());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.empty() ? <span class="string">"0"</span> : res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="算法编程" scheme="https://sunxin18.github.io/categories/%E7%AE%97%E6%B3%95%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="贪婪算法" scheme="https://sunxin18.github.io/tags/%E8%B4%AA%E5%A9%AA%E7%AE%97%E6%B3%95/"/>
    
      <category term="字符串" scheme="https://sunxin18.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>knn应用（癌症判断）</title>
    <link href="https://sunxin18.github.io/2020/02/03/knn/"/>
    <id>https://sunxin18.github.io/2020/02/03/knn/</id>
    <published>2020-02-03T07:54:50.000Z</published>
    <updated>2020-02-11T02:53:15.075Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://archive.ics.uci.edu/ml/datasets/Breast+Cancer+Wisconsin+%28Original%29" target="_blank" rel="noopener">癌症数据</a><br><a href="https://archive.ics.uci.edu/ml/machine-learning-databases/breast-cancer-wisconsin/" target="_blank" rel="noopener">下载链接</a></p><p>属性信息：</p><ol><li>Sample code number: id number </li><li>Clump Thickness: 1 - 10 </li><li>Uniformity of Cell Size: 1 - 10 </li><li>Uniformity of Cell Shape: 1 - 10 </li><li>Marginal Adhesion: 1 - 10 </li><li>Single Epithelial Cell Size: 1 - 10 </li><li>Bare Nuclei: 1 - 10 </li><li>Bland Chromatin: 1 - 10 </li><li>Normal Nucleoli: 1 - 10 </li><li>Mitoses: 1 - 10 </li><li>Class: (2 for benign, 4 for malignant)（2为良性，4为恶性）</li></ol><p>为数据添加label，在第一行加入id,clump_thickness,uniform_cell_size,<br>uniform_cell_shape,marginal_adhesion,<br>single_epi_cell_size,bare_nuclei,bland_chromation,<br>normal_nucleoli,mitoses,class</p><p>数据样式：<br>   clumb_thickness  unif_cell_size  unif_cell_shape  marg_adhesion  single_epith_cell_size bare_nuclei  bland_chrom  norm_nucleoli  mitoses  class<br>0                5               1                1              1                       2           1            3              1        1      2<br>1                5               4                4              5                       7          10            3              2        1      2<br>2                3               1                1              1                       2           2            3              1        1      2<br>3                6               8                8              1                       3           4            3              7        1      2<br>4                4               1                1              3                       2           1            3              1        1      2</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> preprocessing ,model_selection,neighbors</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LinearRegression</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">df = pd.read_csv(<span class="string">'breast-cancer-wisconsin.txt'</span>)<span class="comment">#encoding='utf-8',header=None,sep = '\t'</span></span><br><span class="line">df.replace(<span class="string">'?'</span>,<span class="number">-99999</span>, inplace=<span class="keyword">True</span>)</span><br><span class="line"><span class="comment">#print([column for column in df])</span></span><br><span class="line">df.drop([<span class="string">'id'</span>], <span class="number">1</span>, inplace=<span class="keyword">True</span>)  <span class="comment">#df.drop returns a new dataframe with our chosen column(s) dropped.</span></span><br><span class="line"><span class="comment">#df=df.iloc[:,1:]#.iloc使用全是以0开头的行号和列号，不能直接用其它索引哦。而.loc使用的实际设置的索引和列名。 这就是.loc和.iloc的区别。在实际运用中，我还发现一点区别，.iloc只能选取数据表里实际有的行和列，而.loc可以选取没有的行和列，赋值后就可以添加新行或者列。</span></span><br><span class="line">X = np.array(df.drop([<span class="string">'class'</span>],<span class="number">1</span>))</span><br><span class="line">y = np.array(df[<span class="string">'class'</span>])</span><br><span class="line"></span><br><span class="line">X_train, X_test, y_train, y_test = model_selection.train_test_split(X, y, test_size=<span class="number">0.2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#print([column for column in df])</span></span><br><span class="line"><span class="comment">#clf = LinearRegression(n_jobs=-1)#SVM.svr() kernel='poly'</span></span><br><span class="line">clf = neighbors.KNeighborsClassifier()</span><br><span class="line">clf.fit(X_train,y_train)</span><br><span class="line"></span><br><span class="line">accuracy = clf.score(X_test,y_test)</span><br><span class="line">print(accuracy)</span><br><span class="line">print(df.head())</span><br><span class="line"></span><br><span class="line"><span class="comment">#example_measures = np.array([4,2,1,1,1,2,3,2,1])  #一个sample</span></span><br><span class="line"><span class="comment">#example_measures = example_measures.reshape(1, -1)  #Reshape your data either using array.reshape(-1, 1) if your data has a single feature or array.reshape(1, -1) if it contains a single sample</span></span><br><span class="line">example_measures = np.array([[<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>],[<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]])<span class="comment">#测试用例</span></span><br><span class="line">example_measures = example_measures.reshape(len(example_measures), <span class="number">-1</span>)</span><br><span class="line">prediction = clf.predict(example_measures)</span><br><span class="line"></span><br><span class="line">print(prediction)</span><br></pre></td></tr></table></figure></div><p>accuracy:0.9714285714285714<br>预测结果：prediction[2 2]  两个都为良性</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="机器学习" scheme="https://sunxin18.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="KNN" scheme="https://sunxin18.github.io/tags/KNN/"/>
    
      <category term="应用" scheme="https://sunxin18.github.io/tags/%E5%BA%94%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>实现regression</title>
    <link href="https://sunxin18.github.io/2020/02/01/regression/"/>
    <id>https://sunxin18.github.io/2020/02/01/regression/</id>
    <published>2020-02-01T06:32:13.000Z</published>
    <updated>2020-02-08T07:59:32.569Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="两个error：bias-variance"><a href="#两个error：bias-variance" class="headerlink" title="两个error：bias,variance"></a>两个error：bias,variance</h1><p><a href="/2020/02/01/regression/1.png" data-fancybox="group" data-caption class="fancybox"><img src="/2020/02/01/regression/1.png" alt title></a><br><a href="/2020/02/01/regression/2.png" data-fancybox="group" data-caption class="fancybox"><img src="/2020/02/01/regression/2.png" alt title></a><br>What to do with large bias?<br>1.Add more features as input<br>2.模型更复杂<br>What to do with large variance?<br>1.更多数据<br>2.增加正则化</p><h1 id="梯度下降"><a href="#梯度下降" class="headerlink" title="梯度下降"></a>梯度下降</h1><p>学习率和损失函数的关系：<br>学习率大容易错过loss的最低点，学习率小下降慢<br><a href="/2020/02/01/regression/4.png" data-fancybox="group" data-caption class="fancybox"><img src="/2020/02/01/regression/4.png" alt title></a></p><p>随着我们更新次数的增大，我们是希望我们的学习率越来越慢，因为分母是累加梯度的平方，到后面累加的比较大。因为我们认为在学习率的最初阶段，我们是距离损失函数最优解很远的，随着更新的次数的增多，我们认为越来越接近最优解，于是学习速率也随之变慢。<br><a href="/2020/02/01/regression/5.png" data-fancybox="group" data-caption class="fancybox"><img src="/2020/02/01/regression/5.png" alt title></a><br><a href="/2020/02/01/regression/6.png" data-fancybox="group" data-caption class="fancybox"><img src="/2020/02/01/regression/6.png" alt title></a></p><p><a href="chrome-extension://cdonnmffkdaoajfknoeeecmchibpmkmg/assets/pdf/web/viewer.html?file=http%3A%2F%2Fspeech.ee.ntu.edu.tw%2F~tlkagk%2Fcourses%2FML_2016%2FLecture%2FGradient%2520Descent%2520(v2" target="_blank" rel="noopener">梯度下降理论</a>.pdf)<br>实际是用泰勒函数的近似<br><a href="/2020/02/01/regression/7.png" data-fancybox="group" data-caption class="fancybox"><img src="/2020/02/01/regression/7.png" alt title></a><br><a href="/2020/02/01/regression/8.png" data-fancybox="group" data-caption class="fancybox"><img src="/2020/02/01/regression/8.png" alt title></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> statistics <span class="keyword">import</span> mean</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> style</span><br><span class="line">style.use(<span class="string">'ggplot'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_dataset</span><span class="params">(hm,variance,step=<span class="number">2</span>,correlation=False)</span>:</span></span><br><span class="line">    val = <span class="number">1</span></span><br><span class="line">    ys = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(hm):</span><br><span class="line">        y = val + random.randrange(-variance,variance)</span><br><span class="line">        ys.append(y)</span><br><span class="line">        <span class="keyword">if</span> correlation <span class="keyword">and</span> correlation == <span class="string">'pos'</span>:</span><br><span class="line">            val+=step</span><br><span class="line">        <span class="keyword">elif</span> correlation <span class="keyword">and</span> correlation == <span class="string">'neg'</span>:</span><br><span class="line">            val-=step</span><br><span class="line"></span><br><span class="line">    xs = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(len(ys))]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> np.array(xs, dtype=np.float64),np.array(ys,dtype=np.float64)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">best_fit_slope_and_intercept</span><span class="params">(xs,ys)</span>:</span></span><br><span class="line">    m = (mean(xs)*mean(ys)-mean(xs*ys)) / (mean(xs)*mean(xs)-mean(xs*xs))</span><br><span class="line">    b= mean(ys)-m*mean(xs)</span><br><span class="line">    <span class="keyword">return</span> m,b</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">squared_error</span><span class="params">(ys_orig,ys_line)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> sum((ys_line - ys_orig) * (ys_line - ys_orig))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">coefficient_of_determination</span><span class="params">(ys_orig,ys_line)</span>:</span></span><br><span class="line">    y_mean_line = [mean(ys_orig) <span class="keyword">for</span> y <span class="keyword">in</span> ys_orig]</span><br><span class="line"></span><br><span class="line">    squared_error_regr = sum((ys_line - ys_orig) * (ys_line - ys_orig))</span><br><span class="line">    squared_error_y_mean = sum((y_mean_line - ys_orig) * (y_mean_line - ys_orig))</span><br><span class="line"></span><br><span class="line">    print(squared_error_regr)</span><br><span class="line">    print(squared_error_y_mean)</span><br><span class="line"></span><br><span class="line">    r_squared = <span class="number">1</span> - (squared_error_regr/squared_error_y_mean)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> r_squared</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">xs, ys = create_dataset(<span class="number">40</span>,<span class="number">40</span>,<span class="number">2</span>,correlation=<span class="string">'pos'</span>)</span><br><span class="line">m, b = best_fit_slope_and_intercept(xs,ys)</span><br><span class="line">regression_line = [(m*x)+b <span class="keyword">for</span> x <span class="keyword">in</span> xs]</span><br><span class="line">r_squared = coefficient_of_determination(ys,regression_line)</span><br><span class="line">print(r_squared)</span><br><span class="line">plt.scatter(xs,ys,color=<span class="string">'#003F72'</span>, label = <span class="string">'data'</span>)</span><br><span class="line">plt.plot(xs, regression_line, label = <span class="string">'regression line'</span>)</span><br><span class="line">plt.legend(loc=<span class="number">4</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></div><p>R-square：分子是预测数据与原始数据均值之差的平方和，分母是原始数据和均值之差的平方和<br>R-square=0.5288792849075254<br><a href="/2020/02/01/regression/3.png" data-fancybox="group" data-caption class="fancybox"><img src="/2020/02/01/regression/3.png" alt title></a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="机器学习" scheme="https://sunxin18.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="线性回归" scheme="https://sunxin18.github.io/tags/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/"/>
    
      <category term="梯度下降" scheme="https://sunxin18.github.io/tags/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D/"/>
    
  </entry>
  
  <entry>
    <title>中国加油！</title>
    <link href="https://sunxin18.github.io/2020/01/28/china/"/>
    <id>https://sunxin18.github.io/2020/01/28/china/</id>
    <published>2020-01-28T05:58:55.000Z</published>
    <updated>2020-02-06T06:55:19.428Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>时代的一粒灰，落在个人头上，就是一座山。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>lalala</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://sunxin18.github.io/"/>
  <updated>2020-02-25T10:54:26.015Z</updated>
  <id>https://sunxin18.github.io/</id>
  
  <author>
    <name>Sunxin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>virus</title>
    <link href="https://sunxin18.github.io/2020/02/25/virus/"/>
    <id>https://sunxin18.github.io/2020/02/25/virus/</id>
    <published>2020-02-25T07:07:31.000Z</published>
    <updated>2020-02-25T10:54:26.015Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>闲来无事，做一个确诊人数的预测吧，希望拐点早日降临。<br>首先数据就是日期和总确诊人数，走势是平缓到爆发到平缓，所以用logistics函数。总治愈目前处于上升趋势，多项式拟合吧。大体思路就是自变量特征从1到总的天数，然后把数字映射到日期，制图。<br>附上代码</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> scipy.optimize <span class="keyword">import</span> curve_fit</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">date_encode</span><span class="params">(date)</span>:</span></span><br><span class="line">    <span class="comment"># '01.24' -&gt; 1 * 100 + 24 = 124</span></span><br><span class="line">    d = date.split(<span class="string">'/'</span>)</span><br><span class="line">    <span class="keyword">return</span> int(d[<span class="number">1</span>]),int(d[<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">date_decode</span><span class="params">(date)</span>:</span></span><br><span class="line">    <span class="comment"># 124 -&gt; '01.24'</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'&#123;&#125;.&#123;&#125;'</span>.format(str(date // <span class="number">100</span>), str(date % <span class="number">100</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">df = pd.read_csv(<span class="string">'data.csv'</span>)<span class="comment">#encoding='utf-8',header=None,sep = '\t'</span></span><br><span class="line">df.drop([<span class="number">33</span>],inplace=<span class="keyword">True</span>)</span><br><span class="line">X = np.array(df.iloc[:,<span class="number">0</span>])    <span class="comment">#日期太多显示会重叠，前十天数据很平缓故先忽略掉</span></span><br><span class="line">cur_month,cur_day=date_encode(X[<span class="number">0</span>])</span><br><span class="line">y = np.array(df[<span class="string">'total_confirmed'</span>])</span><br><span class="line">z= np.array(df[<span class="string">'new_recoveries'</span>])</span><br><span class="line">x = np.arange(len(y))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_date_list</span><span class="params">(cur_month,cur_day,days,prediction=<span class="number">7</span>)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    得到原始数据和预测的日期</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    month_day = [<span class="number">0</span>, <span class="number">31</span>, <span class="number">29</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>]</span><br><span class="line">    ans = []</span><br><span class="line">    n=days+prediction</span><br><span class="line">    <span class="keyword">while</span> n:</span><br><span class="line">        <span class="keyword">if</span> cur_day &lt;= month_day[cur_month]:</span><br><span class="line">            d = <span class="string">"0"</span> + str(cur_day) <span class="keyword">if</span> cur_day &lt; <span class="number">10</span> <span class="keyword">else</span> str(cur_day)</span><br><span class="line">            ans += [str(cur_month) + <span class="string">"/"</span> + d]</span><br><span class="line">            cur_day += <span class="number">1</span></span><br><span class="line">            n=n<span class="number">-1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cur_day = <span class="number">1</span></span><br><span class="line">            cur_month += <span class="number">1</span></span><br><span class="line">            n=n<span class="number">-1</span></span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ans = get_date_list(cur_month,cur_day,len(y),prediction=<span class="number">7</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">logistic_function</span><span class="params">(t, K, P0, r)</span>:</span></span><br><span class="line">    r=<span class="number">0.27</span></span><br><span class="line">    t0 = <span class="number">0</span></span><br><span class="line">    exp = np.exp(r * (t - t0))</span><br><span class="line">    <span class="keyword">return</span> (K * exp * P0) / (K + (exp - <span class="number">1</span>) * P0)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f_3</span><span class="params">(x, A, B, C, D)</span>:</span>  </span><br><span class="line">    <span class="keyword">return</span> A*x*x*x + B*x*x + C*x + D</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">popt, pcov = curve_fit(logistic_function, x, y)</span><br><span class="line">popt1, pcov1 = curve_fit(f_3, x, z)</span><br><span class="line">predict_x = list(x)+[x[<span class="number">-1</span>] + i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">8</span>)] <span class="comment">#数组合并不能直接相加</span></span><br><span class="line">predict_x = np.array(predict_x)</span><br><span class="line">predict_y = logistic_function(predict_x, popt[<span class="number">0</span>], popt[<span class="number">1</span>], popt[<span class="number">2</span>])</span><br><span class="line">predict_y = [int(i) <span class="keyword">for</span> i <span class="keyword">in</span> predict_y]</span><br><span class="line">predict_z = f_3(predict_x, popt1[<span class="number">0</span>], popt1[<span class="number">1</span>], popt1[<span class="number">2</span>],popt1[<span class="number">3</span>])</span><br><span class="line">predict_z = [int(i) <span class="keyword">for</span> i <span class="keyword">in</span> predict_z]</span><br><span class="line"><span class="comment">#print(ans[-7:],predict_y[-7:])</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#输出新增确诊</span></span><br><span class="line">new_infected = [predict_y[i]-predict_y[i<span class="number">-1</span>] <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">-7</span>,<span class="number">0</span>)] </span><br><span class="line">print(ans[<span class="number">-7</span>:],new_infected)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#plt.scatter(x,y,color='purple',label='real')</span></span><br><span class="line"><span class="comment">#plt.plot(x,y,color='gray')</span></span><br><span class="line"><span class="comment">#plt.scatter(predict_x,predict_y,marker='x',color='red',label='predicted data')</span></span><br><span class="line"><span class="comment">#plt.xticks(predict_x,ans,rotation=90)</span></span><br><span class="line"><span class="comment">#plt.suptitle("Logistic Fitting Curve for 2019-nCov total infected numbers", fontsize=16, fontweight="bold")</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#输出新增治愈</span></span><br><span class="line">new_cured = [predict_z[i]-predict_z[i<span class="number">-1</span>] <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">-7</span>,<span class="number">0</span>)] </span><br><span class="line">print(ans[<span class="number">-7</span>:],new_cured)</span><br><span class="line"></span><br><span class="line">plt.scatter(x,z,color=<span class="string">'purple'</span>,label=<span class="string">'real'</span>)</span><br><span class="line">plt.plot(x,z,color=<span class="string">'gray'</span>)</span><br><span class="line">plt.scatter(predict_x,predict_z,marker=<span class="string">'x'</span>,color=<span class="string">'red'</span>,label=<span class="string">'predicted data'</span>)</span><br><span class="line">plt.xticks(predict_x,ans,rotation=<span class="number">90</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">plt.suptitle(<span class="string">"polynomial regression Fitting Curve for 2019-nCov total cured numbers"</span>, fontsize=<span class="number">16</span>, fontweight=<span class="string">"bold"</span>)</span><br><span class="line">plt.xlabel(<span class="string">'date'</span>, fontsize=<span class="number">14</span>)</span><br><span class="line">plt.ylabel(<span class="string">'infected number'</span>, fontsize=<span class="number">14</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></div><p>预测走势<br><a href="/2020/02/25/virus/1.png" data-fancybox="group" data-caption class="fancybox"><img src="/2020/02/25/virus/1.png" alt title></a><br>总确诊人数：<br><a href="/2020/02/25/virus/2.png" data-fancybox="group" data-caption class="fancybox"><img src="/2020/02/25/virus/2.png" alt title></a><br>新增治愈趋势：<br><a href="/2020/02/25/virus/3.png" data-fancybox="group" data-caption class="fancybox"><img src="/2020/02/25/virus/3.png" alt title></a><br>新增治愈人数：<br><a href="/2020/02/25/virus/4.png" data-fancybox="group" data-caption class="fancybox"><img src="/2020/02/25/virus/4.png" alt title></a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="机器学习" scheme="https://sunxin18.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>leetcode1326</title>
    <link href="https://sunxin18.github.io/2020/02/21/leetcode1326/"/>
    <id>https://sunxin18.github.io/2020/02/21/leetcode1326/</id>
    <published>2020-02-21T12:26:26.000Z</published>
    <updated>2020-02-25T10:50:31.790Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ol start="91"><li>解码方式<br>首先分析几个特殊的情况，之后开始dp<br>dp[j]对应s[0]到s[i-1]的译码总数<br>如果s[i]=0,前一位只能是1或2，dp[j]=dp[j-2];<br>如果s[i-1]==’1’或者s[i-1]==’2’&amp;&amp;s[i]&lt;=’6’，这两种情况后两位可以合并或者分开译码s[i-1]和s[i]分开译码就是dp[j-1]，合并译码就是dp[j-2]<br>其他情况就是只能分开译码了</li></ol><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(s[<span class="number">0</span>]==<span class="string">'0'</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(s.length()==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> dp[s.size()+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>]=dp[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,j=<span class="number">2</span>;i&lt;s.size();i++,j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">'0'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i<span class="number">-1</span>]==<span class="string">'1'</span>||s[i<span class="number">-1</span>]==<span class="string">'2'</span>) dp[j]=dp[j<span class="number">-2</span>];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i<span class="number">-1</span>]==<span class="string">'1'</span>||s[i<span class="number">-1</span>]==<span class="string">'2'</span>&amp;&amp;s[i]&lt;=<span class="string">'6'</span>)</span><br><span class="line">                dp[j]=dp[j<span class="number">-1</span>]+dp[j<span class="number">-2</span>];</span><br><span class="line">            <span class="keyword">else</span>  </span><br><span class="line">                 dp[j]=dp[j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[s.size()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><ol start="343"><li>整数拆分<br>给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int integerBreak(int n) &#123;</span><br><span class="line">        vector&lt;int&gt;dp(n+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        dp[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(int i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="keyword">for</span>(int j=i<span class="number">-1</span>;j&gt;=<span class="number">1</span>;j--)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i]=max(dp[i],dp[j]*(i-j));</span><br><span class="line">                dp[i]=max(dp[i],j*(i-j));</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></li></ol><p>357.计算各个位数不同的数字个数<br><a href="/2020/02/21/leetcode1326/1.png" data-fancybox="group" data-caption class="fancybox"><img src="/2020/02/21/leetcode1326/1.png" alt title></a><br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int countNumbersWithUniqueDigits(int n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>;   //n=<span class="number">0</span>时，数组长度为<span class="number">1</span>，运行到dp[<span class="number">1</span>]会指向空地址</span><br><span class="line">        vector&lt;int&gt;dp(n+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>]=<span class="number">10</span>;</span><br><span class="line">        <span class="keyword">for</span>(int i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i]=dp[i<span class="number">-1</span>]+(dp[i<span class="number">-1</span>]-dp[i<span class="number">-2</span>])*(<span class="number">10</span>-(i<span class="number">-1</span>));  之前的解加上新增的i位数情况，i位数是由i<span class="number">-1</span>位数加上一位数，再加的一位数只有<span class="number">10</span>-(i<span class="number">-1</span>)种情况。</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></p><p>以n=3为例，n=2已经计算了0-99之间不重复的数字了，我们需要判断的是100-999之间不重复的数字，那也就只能用10-99之间的不重复的数去组成三位数，而不能使用0-9之间的不重复的数，因为他们也组成不了3位数。而10-99之间不重复的数等于dp[2]-dp[1]。<br>当i=2时，说明之前选取的数字只有1位，那么我们只要与这一位不重复即可，所以其实有9(10-1)种情况（比如1，后面可以跟0,2,3,4,5,6,7,8,9）。当i=3时，说明之前选取的数字有2位，那么我们需要与2位不重复，所以剩余的有8（10-2）种（比如12，后面可以跟0,3,4,5,6,7,8,9）</p><p>1326.灌溉花园的最少水龙头数目</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> dp[<span class="number">10001</span>];</span><br><span class="line">    <span class="keyword">int</span> INF= <span class="number">0x3f3f3f3f</span>;    <span class="comment">//定义为无穷大，意味着无法灌溉</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minTaps</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; ranges)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(dp,INF,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ranges.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> L = max(<span class="number">0</span>,i-ranges[i]);</span><br><span class="line">            <span class="keyword">int</span> R = min(n,i+ranges[i]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = L; j &lt;= R; j++)&#123;</span><br><span class="line">                dp[j] = min(dp[j],dp[L]+<span class="number">1</span>); <span class="comment">//</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n] == INF ? <span class="number">-1</span> : dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="算法编程" scheme="https://sunxin18.github.io/categories/%E7%AE%97%E6%B3%95%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="动态规划" scheme="https://sunxin18.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>face</title>
    <link href="https://sunxin18.github.io/2020/02/20/face/"/>
    <id>https://sunxin18.github.io/2020/02/20/face/</id>
    <published>2020-02-20T03:07:34.000Z</published>
    <updated>2020-02-20T03:07:34.765Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>leetcode207</title>
    <link href="https://sunxin18.github.io/2020/02/13/leetcode207/"/>
    <id>https://sunxin18.github.io/2020/02/13/leetcode207/</id>
    <published>2020-02-13T13:35:58.000Z</published>
    <updated>2020-02-14T14:53:55.674Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>207.课程表<br>这道题等价于判断图里有没有环，两种方法一个是拓扑排序，一个是DFS</p><h1 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h1><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">      <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; degree(numCourses, <span class="number">0</span>);<span class="comment">//   map&lt;int,int&gt;degree;for(int i=0;i&lt;numCourses;i++)degree[i]=0;</span></span><br><span class="line">  <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;cur;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;prerequisites.size();i++)&#123;</span><br><span class="line">            cur[prerequisites[i][<span class="number">1</span>]].push_back(prerequisites[i][<span class="number">0</span>]);</span><br><span class="line">            degree[prerequisites[i][<span class="number">0</span>]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;degree.size();i++) <span class="comment">//不是cur.size()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(degree[i]==<span class="number">0</span>)</span><br><span class="line">                q.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> node=q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            ans++;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;cur[node].size();i++)</span><br><span class="line">            &#123;</span><br><span class="line">                degree[cur[node][i]]--;</span><br><span class="line">                <span class="keyword">if</span>(degree[cur[node][i]]==<span class="number">0</span>)</span><br><span class="line">                    q.push(cur[node][i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ans==numCourses)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><p>在这里我犯了一个错误，找了半天…啊我的时间都去哪了….<br>对于入度容器我开始设计是<code>C++ map&lt;int,vector&lt;int&gt;&gt;cur</code>这样没有考虑度为0的节点，首先默认节点入度都为0，然后根据图来更新入度，这种情况可以就地改进见注释，或者直接用vector初始化</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="图" scheme="https://sunxin18.github.io/categories/%E5%9B%BE/"/>
    
    
  </entry>
  
  <entry>
    <title>deep_learning</title>
    <link href="https://sunxin18.github.io/2020/02/13/deep-learning/"/>
    <id>https://sunxin18.github.io/2020/02/13/deep-learning/</id>
    <published>2020-02-13T02:09:02.000Z</published>
    <updated>2020-02-22T00:37:53.148Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="激活函数（Activation-functions）"><a href="#激活函数（Activation-functions）" class="headerlink" title="激活函数（Activation functions）"></a>激活函数（Activation functions）</h1><p>如果不使用激活函数，无论神经网络多少层都会是个线性激活函数<br><a href="/2020/02/13/deep-learning/4.png" data-fancybox="group" data-caption class="fancybox"><img src="/2020/02/13/deep-learning/4.png" alt title></a><br>除了二分类问题，不要使用sigmoid，tanh变现总是更好，但这些函数当z很大时，梯度会很小，训练会很慢，所以推荐relu函数。<br>ReLu函数只要$z$是正值的情况下，导数恒等于1，当是$z$负值的时候，导数恒等于0。从实际上来说，当使用的导数时，$z$=0的导数是没有定义的。但是当编程实现的时候，$z$的取值刚好等于0.00000001，这个值相当小，所以，在实践中，不需要担心这个值，$z$是等于0的时候，假设一个导数是1或者0效果都可以。这里也有另一个版本的Relu被称为Leaky Relu,这个函数通常比Relu激活函数效果要好，尽管在实际中Leaky ReLu使用的并不多.<br><a href="/2020/02/13/deep-learning/3.png" data-fancybox="group" data-caption class="fancybox"><img src="/2020/02/13/deep-learning/3.png" alt title></a><br>对于sigmoid函数$g(z)=\frac{1}{1+e^{-x}}$,他的导数等于$g(z)\times (1-g(z))$<br>对于tanh函数$\frac{e^{x}-e^{-x}}{e^{x}+e^{-x}}$,他的导数等于$1-(tanh(z))^{2}$<br>Relu函数$g(z)=max(0,z)$,leaky Relu函数$g(z)=max(0.01z,z)$</p><h1 id="矩阵的维数"><a href="#矩阵的维数" class="headerlink" title="矩阵的维数"></a>矩阵的维数</h1><p>比如图中的神经网络，第一个隐藏层$z^{[1]}=w^{[1]}x+b^{[1]}$,$z^{[1]}$是3×1的矩阵，$x$是2×1的矩阵，所以$w^{[1]}$是3×2的，总结起来就是$w^{[L]}$是$n^{[L]}\times n^{[L-1]}$的，对$dw$也是一样的，$b^{[L]}$就是$n^{[L]}\times1$的，见图片右半部分<br><a href="/2020/02/13/deep-learning/5.png" data-fancybox="group" data-caption class="fancybox"><img src="/2020/02/13/deep-learning/5.png" alt title></a><br>之后可以将$z^{[1]}$叠加起来，m为样本数量<br><a href="/2020/02/13/deep-learning/6.png" data-fancybox="group" data-caption class="fancybox"><img src="/2020/02/13/deep-learning/6.png" alt title></a></p><h1 id="参数随机初始化（Random-Initialization）"><a href="#参数随机初始化（Random-Initialization）" class="headerlink" title="参数随机初始化（Random+Initialization）"></a>参数随机初始化（Random+Initialization）</h1><p>$W^{[1]}=np.random.rando(2,2)*0.01,b=np.zeros((2,1))$<br>为什么是0.01，而不是100或者1000。我们通常倾向于初始化为很小的随机数。因为如果你用tanh或者sigmoid激活函数，或者说只在输出层有一个Sigmoid，如果$W$很大，$Z$就会很大或者很小，因此这种情况下你很可能停在tanh/sigmoid函数的平坦的地方(见图3.8.2)，这些地方梯度很小也就意味着梯度下降会很慢，因此学习也就很慢。</p><h1 id="正则化（Regularization）"><a href="#正则化（Regularization）" class="headerlink" title="正则化（Regularization）"></a>正则化（Regularization）</h1><p>1.为什么只正则化参数$w$？为什么不再加上参数$b$呢？你可以这么做，只是我习惯省略不写，因为通常是一个高维参数矢量，已经可以表达高偏差问题，可能包含有很多参数，我们不可能拟合所有参数，而$b$只是单个数字，所以$w$几乎涵盖所有参数，而不是$b$，如果加了参数$b$，其实也没太大影响，因为只是众多参数中的一个，所以我通常省略不计，如果你想加上这个参数，完全没问题。</p><p>2.为什么正则化会有用？当$\lambda$增大，$w$接近于0，会减少很多隐藏单元的影响，网络会变得简单，接近于逻辑回归，$z$也会很小($z^{[l]}=w^{[l]}a^{[l-1]}+b^{[l]}$),会呈线性。<br>3.其他正则化方法：数据扩增（比如图片翻转、裁剪、扭曲），early stop<br><a href="/2020/02/13/deep-learning/7.png" data-fancybox="group" data-caption class="fancybox"><img src="/2020/02/13/deep-learning/7.png" alt title></a><br>early stop无法将降低损失函数和过拟合独立处理，会很复杂，所以更倾向L2正则化，虽然要尝试很多不同的$\lambda$，计算代价会很大</p><h1 id="归一化"><a href="#归一化" class="headerlink" title="归一化"></a>归一化</h1><p>为什么要归一化？代价函数看起来会更对称，无论从哪个位置开始都能更直接的找到最小值，可以使用较大的步长。</p><h2 id="padding"><a href="#padding" class="headerlink" title="padding"></a>padding</h2><p>普通的卷积两个缺点，第一个缺点是每次做卷积操作，你的图像就会缩小，从6×6缩小到4×4，你可能做了几次之后，你的图像就会变得很小了，可能会缩小到只有1×1的大小。你可不想让你的图像在每次识别边缘或其他特征时都缩小，这就是第一个缺点。第二个缺点时，如果你注意角落边缘的像素，这个像素点只被一个输出所触碰或者使用，因为它位于这个3×3的区域的一角。但如果是在中间的像素点，就会有许多3×3的区域与之重叠。所以那些在角落或者边缘区域的像素点在输出中采用较少，意味着你丢掉了图像边缘位置的许多信息。<br>对于$N \times N/$的图像，$f \times f$的filter（通常为奇数），paddy为p，步长stride为2，最后得到的矩阵为$[\frac{n+2p-f}{s}+1] \times [\frac{n+2p-f}{s}+1]$,如果这个不是整数，我们向下取整，</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="深度学习" scheme="https://sunxin18.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>knn_application</title>
    <link href="https://sunxin18.github.io/2020/02/10/knn-application/"/>
    <id>https://sunxin18.github.io/2020/02/10/knn-application/</id>
    <published>2020-02-10T06:18:05.000Z</published>
    <updated>2020-02-14T14:36:33.195Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>python counter类:<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">"hello pinsily"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = Counter(s)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d</span><br><span class="line">Counter(&#123;<span class="string">'l'</span>: <span class="number">3</span>, <span class="string">'i'</span>: <span class="number">2</span>, <span class="string">'h'</span>: <span class="number">1</span>, <span class="string">'e'</span>: <span class="number">1</span>, <span class="string">'o'</span>: <span class="number">1</span>, <span class="string">' '</span>: <span class="number">1</span>, <span class="string">'p'</span>: <span class="number">1</span>, <span class="string">'n'</span>: <span class="number">1</span>, <span class="string">'s'</span>: <span class="number">1</span>, <span class="string">'y'</span>: <span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure></div></p><p>most_common(n)<br>返回数量最多的前 n 个元素<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.most_common(<span class="number">3</span>)</span><br><span class="line">[(<span class="string">'l'</span>, <span class="number">3</span>), (<span class="string">'i'</span>, <span class="number">2</span>), (<span class="string">'h'</span>, <span class="number">1</span>)]</span><br></pre></td></tr></table></figure></div></p><p>代码实现：<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> sqrt</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> style</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line">style.use(<span class="string">'fivethirtyeight'</span>)</span><br><span class="line">dataset = &#123;<span class="string">'k'</span>:[[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">1</span>]], <span class="string">'r'</span>:[[<span class="number">6</span>,<span class="number">5</span>],[<span class="number">7</span>,<span class="number">7</span>],[<span class="number">8</span>,<span class="number">6</span>]]&#125;</span><br><span class="line">new_features = [<span class="number">5</span>,<span class="number">7</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> dataset:</span><br><span class="line">    <span class="keyword">for</span> ii <span class="keyword">in</span> dataset[i]:</span><br><span class="line">        plt.scatter(ii[<span class="number">0</span>],ii[<span class="number">1</span>],s=<span class="number">100</span>,color=i)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">k_nearest_neighbors</span><span class="params">(data, predict, k=<span class="number">3</span>)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(data) &gt;= k:</span><br><span class="line">        warnings.warn(<span class="string">'K is set to a value less than total voting groups!'</span>)</span><br><span class="line">        </span><br><span class="line">    distances = []</span><br><span class="line">    <span class="keyword">for</span> group <span class="keyword">in</span> data:</span><br><span class="line">        <span class="keyword">for</span> features <span class="keyword">in</span> data[group]:</span><br><span class="line">            euclidean_distance = np.linalg.norm(np.array(features)-np.array(predict))  <span class="comment">#欧几里得距离</span></span><br><span class="line">            distances.append([euclidean_distance,group])</span><br><span class="line"></span><br><span class="line">    votes = [i[<span class="number">1</span>] <span class="keyword">for</span> i <span class="keyword">in</span> sorted(distances)[:k]]</span><br><span class="line">    vote_result = Counter(votes).most_common(<span class="number">1</span>)[<span class="number">0</span>][<span class="number">0</span>] <span class="comment">#不使用[0][0],得到的是[('r', 3)]. [0][0]得到元组中第一个元素</span></span><br><span class="line">    <span class="keyword">return</span> vote_result</span><br><span class="line"></span><br><span class="line">result = k_nearest_neighbors(dataset,new_features,k=<span class="number">3</span>)</span><br><span class="line">print(result)</span><br><span class="line">plt.scatter(new_features[<span class="number">0</span>],new_features[<span class="number">1</span>],s=<span class="number">50</span>,color=result)<span class="comment">#预测的数据用小红点表示</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></div></p><p>运行结果：<br><a href="/2020/02/10/knn-application/1.png" data-fancybox="group" data-caption class="fancybox"><img src="/2020/02/10/knn-application/1.png" alt title></a><br>然后用这个代码来跑下癌症预测，代码如下<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> style</span><br><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">k_nearest_neighbors</span><span class="params">(data, predict, k=<span class="number">3</span>)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(data) &gt;= k:</span><br><span class="line">        warnings.warn(<span class="string">'K is set to a value less than total voting groups!'</span>)</span><br><span class="line">        </span><br><span class="line">    distances = []</span><br><span class="line">    <span class="keyword">for</span> group <span class="keyword">in</span> data:</span><br><span class="line">        <span class="keyword">for</span> features <span class="keyword">in</span> data[group]:</span><br><span class="line">            euclidean_distance = np.linalg.norm(np.array(features)-np.array(predict))</span><br><span class="line">            distances.append([euclidean_distance,group])</span><br><span class="line"></span><br><span class="line">    votes = [i[<span class="number">1</span>] <span class="keyword">for</span> i <span class="keyword">in</span> sorted(distances)[:k]]</span><br><span class="line">    vote_result = Counter(votes).most_common(<span class="number">1</span>)[<span class="number">0</span>][<span class="number">0</span>] <span class="comment">#不使用[0][0],得到的是[('r', 3)]. [0][0]得到元组中第一个元素</span></span><br><span class="line">    <span class="keyword">return</span> vote_result</span><br><span class="line"></span><br><span class="line">df = pd.read_csv(<span class="string">'breast-cancer-wisconsin.txt'</span>)</span><br><span class="line">df.replace(<span class="string">'?'</span>,<span class="number">-99999</span>,inplace=<span class="keyword">True</span>)</span><br><span class="line">df.drop([<span class="string">'id'</span>],<span class="number">1</span>,inplace=<span class="keyword">True</span>)</span><br><span class="line">full_data = df.astype(float).values.tolist()</span><br><span class="line"></span><br><span class="line">test_size = <span class="number">0.2</span></span><br><span class="line">train_set = &#123;<span class="number">2</span>:[], <span class="number">4</span>:[]&#125;<span class="comment">#良性恶性两个lable</span></span><br><span class="line">test_set = &#123;<span class="number">2</span>:[], <span class="number">4</span>:[]&#125;</span><br><span class="line">train_data = full_data[:-int(test_size*len(full_data))]</span><br><span class="line">test_data = full_data[-int(test_size*len(full_data)):]   <span class="comment">#最后20%</span></span><br><span class="line">correct = <span class="number">0</span></span><br><span class="line">total = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> train_data:</span><br><span class="line">    train_set[i[<span class="number">-1</span>]].append(i[:<span class="number">-1</span>]) <span class="comment">#去掉label，将属性填入</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> test_data:</span><br><span class="line">    test_set[i[<span class="number">-1</span>]].append(i[:<span class="number">-1</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> group <span class="keyword">in</span> test_set:</span><br><span class="line">    <span class="keyword">for</span> data <span class="keyword">in</span> test_set[group]:</span><br><span class="line">        vote = k_nearest_neighbors(train_set, data, k=<span class="number">5</span>)</span><br><span class="line">        <span class="keyword">if</span> group == vote:</span><br><span class="line">            correct += <span class="number">1</span></span><br><span class="line">        total += <span class="number">1</span></span><br><span class="line">print(<span class="string">'Accuracy:'</span>, correct/total)</span><br></pre></td></tr></table></figure></div></p><p><a href="/2020/02/10/knn-application/2.png" data-fancybox="group" data-caption class="fancybox"><img src="/2020/02/10/knn-application/2.png" alt title></a><br>准确度很高！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="机器学习" scheme="https://sunxin18.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="KNN" scheme="https://sunxin18.github.io/tags/KNN/"/>
    
      <category term="python" scheme="https://sunxin18.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>leetcode113</title>
    <link href="https://sunxin18.github.io/2020/02/08/leetcode113/"/>
    <id>https://sunxin18.github.io/2020/02/08/leetcode113/</id>
    <published>2020-02-08T10:50:42.000Z</published>
    <updated>2020-02-11T12:26:00.158Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>112.给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        sum=sum-root-&gt;val;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left==<span class="literal">NULL</span>&amp;&amp;root-&gt;right==<span class="literal">NULL</span>&amp;&amp;sum==<span class="number">0</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> hasPathSum(root-&gt;left,sum)||hasPathSum(root-&gt;right,sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></p><p>对于113题，做一点思考，看下面两段代码：<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;res;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;path;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; pathSum(TreeNode* root, <span class="keyword">int</span> sum) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> res;</span><br><span class="line">        DFS(path,root,sum);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;path,TreeNode* root, <span class="keyword">int</span> sum)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        path.push_back(root-&gt;val);</span><br><span class="line">        sum=sum-root-&gt;val;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left==<span class="literal">NULL</span>&amp;&amp;root-&gt;right==<span class="literal">NULL</span>&amp;&amp;sum==<span class="number">0</span>)res.push_back(path);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="keyword">if</span>(root-&gt;left)</span><br><span class="line">            &#123;</span><br><span class="line">                 DFS(path,root-&gt;left,sum);</span><br><span class="line">                 path.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;right)</span><br><span class="line">            &#123;</span><br><span class="line">                DFS(path,root-&gt;right,sum);</span><br><span class="line">                path.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></p><p><a href="/2020/02/08/leetcode113/1.png" data-fancybox="group" data-caption class="fancybox"><img src="/2020/02/08/leetcode113/1.png" alt title></a><br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;res;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;path;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; pathSum(TreeNode* root, <span class="keyword">int</span> sum) &#123;<span class="comment">//!!!!!!</span></span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> res;</span><br><span class="line">        DFS(path,root,sum);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;path,TreeNode* root, <span class="keyword">int</span> sum)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        path.push_back(root-&gt;val);</span><br><span class="line">        sum=sum-root-&gt;val;</span><br><span class="line">        <span class="keyword">if</span>(sum==<span class="number">0</span>&amp;&amp;root-&gt;left==<span class="literal">NULL</span>&amp;&amp;root-&gt;right==<span class="literal">NULL</span>)res.push_back(path);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="keyword">if</span>(root-&gt;left)</span><br><span class="line">            &#123;</span><br><span class="line">                 DFS(path,root-&gt;left,sum); <span class="comment">//!!!!!!</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;right)</span><br><span class="line">            &#123;</span><br><span class="line">                DFS(path,root-&gt;right,sum);<span class="comment">//!!!!!!</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">![](<span class="number">2.</span>png)</span><br></pre></td></tr></table></figure></div></p><p>区别主要是，第一种每层递归函数都使用的一个容器，所以要加上引用，递归返回需要弹出之前的元素，而第二种是每次递归函数都复制一个容器。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="算法编程" scheme="https://sunxin18.github.io/categories/%E7%AE%97%E6%B3%95%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="DFS" scheme="https://sunxin18.github.io/tags/DFS/"/>
    
      <category term="树" scheme="https://sunxin18.github.io/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>Pagerank</title>
    <link href="https://sunxin18.github.io/2020/02/07/pagerank/"/>
    <id>https://sunxin18.github.io/2020/02/07/pagerank/</id>
    <published>2020-02-07T11:28:45.000Z</published>
    <updated>2020-02-15T13:26:41.829Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="The-web-as-a-graph"><a href="#The-web-as-a-graph" class="headerlink" title="The web as a graph"></a>The web as a graph</h1><p>pagerank是谷歌用来计算网页重要性的算法，我们把网页想象成节点，超链接想象成边，这就形成了一张有向图。<br>当然我们只考虑静态网页，不考虑防火墙拦截、无法访问这些情况。</p><p>两种有向图：<br>1.强连通图Strongly connected graphs：任意节点可以到达任意节点。<br>2.有向无环图Directed Acyclic Graph (DAG):首先没有环，u能达到v，但v不能达到u。<br>求strongly connected components (SCCs):对给定节点分别求入度和出度的BFS,然后对两个集合求交集<br><a href="/2020/02/07/pagerank/1.png" data-fancybox="group" data-caption class="fancybox"><img src="/2020/02/07/pagerank/1.png" alt title></a></p><h1 id="Bowtie-structure-of-the-web-graph"><a href="#Bowtie-structure-of-the-web-graph" class="headerlink" title="Bowtie structure of the web graph"></a>Bowtie structure of the web graph</h1><p>Broder et al. (1999) took a large snapshot of the web and tried to understand how the SCCs in the web graph fit together as a DAG<br>这张图Here the starting nodes are sorted by the number of nodes that BFS visits when starting from that node<br><a href="/2020/02/07/pagerank/2.png" data-fancybox="group" data-caption class="fancybox"><img src="/2020/02/07/pagerank/2.png" alt title></a><br>图中蓝色节点只能访问一小部分节点，紫红色节点可以访问很多节点<br>通过这个我们可以得出网络中的图组成<a href="/2020/02/07/pagerank/3.png" data-fancybox="group" data-caption class="fancybox"><img src="/2020/02/07/pagerank/3.png" alt title></a></p><h1 id="PageRank-Ranking-nodes-on-the-graph"><a href="#PageRank-Ranking-nodes-on-the-graph" class="headerlink" title="PageRank - Ranking nodes on the graph"></a>PageRank - Ranking nodes on the graph</h1><p>核心想法是吧links当作votes，一个节点的重要性是由被所指向的其他节点决定的<br><a href="/2020/02/07/pagerank/4.png" data-fancybox="group" data-caption class="fancybox"><img src="/2020/02/07/pagerank/4.png" alt title></a><br>公式为$r_{j}= \sum _ {i \rightarrow j}\frac{r_{i}}{d_{i}}$</p><h2 id="Matrix-formulation"><a href="#Matrix-formulation" class="headerlink" title="Matrix formulation"></a>Matrix formulation</h2><p>这种计算方法需要N个式子，需要很长的时间。所以我们用邻接矩阵M来代替，M的每个列的和为1$if j \rightarrow i,then W_{^{ij}}=\frac{1}{d_{j}}$,则$r=Mr$，如下图的计算过程<br><a href="/2020/02/07/pagerank/5.png" data-fancybox="group" data-caption class="fancybox"><img src="/2020/02/07/pagerank/5.png" alt title></a><br>之后进行不断地迭代，$M(M…(M(Mr)$直到$|r-r^{‘}|&lt; \varepsilon$</p><h1 id="PageRank-Problems"><a href="#PageRank-Problems" class="headerlink" title="PageRank: Problems"></a>PageRank: Problems</h1><p>1.dead ends:没有out-links<br><a href="/2020/02/07/pagerank/6.png" data-fancybox="group" data-caption class="fancybox"><img src="/2020/02/07/pagerank/6.png" alt title></a><br>2.Spider traps：节点发出的边只有自环，最终会吸收所有的重要性，比如图中b会聚集所有的重要性，a会没有重要性<br><a href="/2020/02/07/pagerank/7.png" data-fancybox="group" data-caption class="fancybox"><img src="/2020/02/07/pagerank/7.png" alt title></a></p><h2 id="解决方法是random-teleportation或者random-jumps"><a href="#解决方法是random-teleportation或者random-jumps" class="headerlink" title="解决方法是random teleportation或者random jumps"></a>解决方法是random teleportation或者random jumps</h2><p>当一次随机游走完成，下次网上冲浪有两种选择，有概率$\beta $跟随link，$1-\beta $跳到其它网页,跳到其他的网页节点有相同的可能性，$\beta $通常设定在0.8到0.9<br>综合起来就是:$r_{j}= \sum _ {i\rightarrow j}\frac{r_{i}}{d_{i}}+(1-\beta )\frac{1}{N}$<br>下面可以定义谷歌矩阵$A= \beta \times M+(1-\beta )[\frac{1}{N}]_ {N \times N}$，$r=A \times r$<br>注意这个公式假设M没有dead ends。我们可以提前处理矩阵M去除dead ends或者使用概率为1的随机random teleports</p><h2 id="Computing-PageRank-Sparse-matrix-formulation"><a href="#Computing-PageRank-Sparse-matrix-formulation" class="headerlink" title="Computing PageRank: Sparse matrix formulation"></a>Computing PageRank: Sparse matrix formulation</h2><p>但是这样对于节点太多的话，存储矩阵$A(N\times N)$需要大量的空间，我们可以这样来计算：$r=\beta M \times r+\frac{1-\beta }{N}$ , $\frac{1-\beta }{N}$是一个向量，因为这样M是个稀疏矩阵，与向量乘机就没有那么大的计算量了<br><a href="/2020/02/07/pagerank/8.png" data-fancybox="group" data-caption class="fancybox"><img src="/2020/02/07/pagerank/8.png" alt title></a><br>下面给出完整的算法流程<br><a href="/2020/02/07/pagerank/9.png" data-fancybox="group" data-caption class="fancybox"><img src="/2020/02/07/pagerank/9.png" alt title></a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="图" scheme="https://sunxin18.github.io/categories/%E5%9B%BE/"/>
    
    
      <category term="pagerank" scheme="https://sunxin18.github.io/tags/pagerank/"/>
    
  </entry>
  
  <entry>
    <title>gragh representation learning(图的表征学习)</title>
    <link href="https://sunxin18.github.io/2020/02/06/representation-learning/"/>
    <id>https://sunxin18.github.io/2020/02/06/representation-learning/</id>
    <published>2020-02-06T06:59:24.000Z</published>
    <updated>2020-02-07T11:26:48.511Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>核心思想：map each node in a network into a low-dimensional space把每个节点映射到低维空间<br>在学习一个网络表示的时候需要注意的几个性质：<br>1.<strong>适应性</strong>，网络表示必须能适应网络的变化。网络是一个动态的图，不断地会有新的节点和边添加进来，网络表示需要适应网络的正常演化。<br>2.<strong>属于同一个社区的节点有着类似的表示</strong>。网络中往往会出现一些特征相似的点构成的团状结构，这些节点表示成向量后必须相似。<br>3.<strong>低维</strong>。代表每个顶点的向量维数不能过高，过高会有过拟合的风险，对网络中有缺失数据的情况处理能力较差。<br>4.<strong>连续性</strong>。低维的向量应该是连续的。</p><h1 id="Embedding-Nodes"><a href="#Embedding-Nodes" class="headerlink" title="Embedding Nodes"></a>Embedding Nodes</h1><p>node embedding的目标是在原网络的similarity近似于embedding space的相似度（内积）<br>1.定义一个encoder(i.e., a mapping from nodes to embeddings)<br>2.定义相似度函数（原始网络中的相似度）<br>3.优化encoder的参数，使得原始网络中u，v的相似度近似于embedding的点积<br><a href="/2020/02/06/representation-learning/1.png" data-fancybox="group" data-caption class="fancybox"><img src="/2020/02/06/representation-learning/1.png" alt title></a></p><h1 id="deep-walk"><a href="#deep-walk" class="headerlink" title="deep walk"></a>deep walk</h1><p>given a graph and a starting point, we select a neighbor of it at random, and move to this neighbor; then we select a neighbor of this point at random, and move to it, etc. The (random) sequence of points selected this way is a random walk on the graph. So $similarity(u,v)$ is defined as the probability that<br>u and v co-occur on a random walk over a network.</p><p>思想来源于语言模型，我们想要在所有训练短语中最大化概率$Pr(w_{n}|w_{0},w_{1},….,w_{n-1})$，The direct analog is to estimate the likelihood of observing vertex vi given all the previous vertices visited so far in the random walk.<br>deep walk中算法主要包括两个部分，一个是random walk gengerator，第二个是更新程序.<br><a href="https://zhuanlan.zhihu.com/p/45167021" target="_blank" rel="noopener">deep walk 论文笔记</a></p><p>random-walk embeddings有如下几步：<br>1.Estimate probability of visiting node v on a random walk starting from node u using some random walk strategy R. The simplest idea is just to run fixed-length, unbiased random walks starting from each node <a href="https://arxiv.org/abs/1403.6652" target="_blank" rel="noopener">i.e., DeepWalk from Perozzi et al., 2013</a><br>2.Optimize embeddings to encode these random walk statistics, so the similarity between embeddings (e.g., dot product) encodes Random Walk similarity.</p><h1 id="Random-walk-optimization-and-Negative-Sampling"><a href="#Random-walk-optimization-and-Negative-Sampling" class="headerlink" title="Random walk optimization and Negative Sampling"></a>Random walk optimization and Negative Sampling</h1><p>待更新</p><h1 id="Node2vec"><a href="#Node2vec" class="headerlink" title="Node2vec"></a>Node2vec</h1><p>考虑灵活变长的random walk，可以权衡网络的局部和全局的结构，有两种策略BFS,DFS<br><a href="/2020/02/06/representation-learning/2.png" data-fancybox="group" data-caption class="fancybox"><img src="/2020/02/06/representation-learning/2.png" alt title></a><br>定义两个参数，p为返回之前节点的概率，q来调节DFS，BFS<br><a href="/2020/02/06/representation-learning/3.png" data-fancybox="group" data-caption class="fancybox"><img src="/2020/02/06/representation-learning/3.png" alt title></a><br>算法：<br>1.估算random walk概率<br>2.对于每个节点u模拟r次长度为l的random walk<br>3.使用随机梯度下降进行更新</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="图" scheme="https://sunxin18.github.io/categories/%E5%9B%BE/"/>
    
    
      <category term="embedding" scheme="https://sunxin18.github.io/tags/embedding/"/>
    
      <category term="负采样" scheme="https://sunxin18.github.io/tags/%E8%B4%9F%E9%87%87%E6%A0%B7/"/>
    
  </entry>
  
  <entry>
    <title>hashtbale</title>
    <link href="https://sunxin18.github.io/2020/02/04/hashtbale/"/>
    <id>https://sunxin18.github.io/2020/02/04/hashtbale/</id>
    <published>2020-02-04T14:32:43.000Z</published>
    <updated>2020-02-05T12:57:39.401Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目49<br>给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。</p><p>思路：哈希表，对排序后的单词作为索引。<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; groupAnagrams(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;res;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;cur;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> str:strs)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> s=str;</span><br><span class="line">            sort(s.begin(),s.end());</span><br><span class="line">            cur[s].push_back(str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it=cur.begin();it!=cur.end();it++)</span><br><span class="line">            res.push_back(it-&gt;second);</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="算法编程" scheme="https://sunxin18.github.io/categories/%E7%AE%97%E6%B3%95%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="字符串" scheme="https://sunxin18.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="哈希表" scheme="https://sunxin18.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>C++编程总结(持续更新)</title>
    <link href="https://sunxin18.github.io/2020/02/03/C/"/>
    <id>https://sunxin18.github.io/2020/02/03/C/</id>
    <published>2020-02-03T14:07:37.000Z</published>
    <updated>2020-02-04T03:38:24.855Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="删除末尾字符"><a href="#删除末尾字符" class="headerlink" title="删除末尾字符"></a>删除末尾字符</h2><p>1.str = str.substr(0, str.length() - 1);<br>2.str.erase(str.end() - 1);<br>3.str.pop_back();</p><h1 id="图编程"><a href="#图编程" class="headerlink" title="图编程"></a>图编程</h1><p>1.以u为顶点出发寻找与u，v能构成三角形的顶点w是，需要遍历u的临边，要注意过跳过v，添加if（v==w）continue<br>2.变量的作用域重叠，导致后来定义会覆盖掉之前的，应定义新的变量<br>3.入队出队寻找followers时，忘记对访问过的边做已访问标记，导致队列不会走空，进入无限循环，运行时间很久，诊断发现内存不断增加。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="算法编程" scheme="https://sunxin18.github.io/categories/%E7%AE%97%E6%B3%95%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="C++" scheme="https://sunxin18.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>2.3</title>
    <link href="https://sunxin18.github.io/2020/02/03/2-3/"/>
    <id>https://sunxin18.github.io/2020/02/03/2-3/</id>
    <published>2020-02-03T12:34:59.000Z</published>
    <updated>2020-02-05T12:57:13.807Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目402：给定一个以字符串表示的非负整数 num，移除这个数中的 k 位数字，使得剩下的数字最小。<br>测试用例  112,<br>思路要想使移除k个元素后的数最小，则应该移除最靠左的k个相邻逆序对，包括在一次移除后形成的新的逆序对.</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">removeKdigits</span><span class="params">(<span class="built_in">string</span> num, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">int</span> n = num.size(), m = n - k;        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : num) &#123;</span><br><span class="line">            <span class="keyword">while</span> (k &amp;&amp; res.size() &amp;&amp; res.back() &gt; c) &#123;</span><br><span class="line">                res.pop_back();</span><br><span class="line">                --k;</span><br><span class="line">            &#125;</span><br><span class="line">            res.push_back(c);</span><br><span class="line">        &#125;</span><br><span class="line">        res.resize(m);</span><br><span class="line">        <span class="comment">//去除前导0， 如10200，k = 1</span></span><br><span class="line">        <span class="keyword">while</span> (!res.empty() &amp;&amp; res[<span class="number">0</span>] == <span class="string">'0'</span>) &#123;</span><br><span class="line">            res.erase(res.begin());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.empty() ? <span class="string">"0"</span> : res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="算法编程" scheme="https://sunxin18.github.io/categories/%E7%AE%97%E6%B3%95%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="贪婪算法" scheme="https://sunxin18.github.io/tags/%E8%B4%AA%E5%A9%AA%E7%AE%97%E6%B3%95/"/>
    
      <category term="字符串" scheme="https://sunxin18.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>knn应用（癌症判断）</title>
    <link href="https://sunxin18.github.io/2020/02/03/knn/"/>
    <id>https://sunxin18.github.io/2020/02/03/knn/</id>
    <published>2020-02-03T07:54:50.000Z</published>
    <updated>2020-02-11T02:53:15.075Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://archive.ics.uci.edu/ml/datasets/Breast+Cancer+Wisconsin+%28Original%29" target="_blank" rel="noopener">癌症数据</a><br><a href="https://archive.ics.uci.edu/ml/machine-learning-databases/breast-cancer-wisconsin/" target="_blank" rel="noopener">下载链接</a></p><p>属性信息：</p><ol><li>Sample code number: id number </li><li>Clump Thickness: 1 - 10 </li><li>Uniformity of Cell Size: 1 - 10 </li><li>Uniformity of Cell Shape: 1 - 10 </li><li>Marginal Adhesion: 1 - 10 </li><li>Single Epithelial Cell Size: 1 - 10 </li><li>Bare Nuclei: 1 - 10 </li><li>Bland Chromatin: 1 - 10 </li><li>Normal Nucleoli: 1 - 10 </li><li>Mitoses: 1 - 10 </li><li>Class: (2 for benign, 4 for malignant)（2为良性，4为恶性）</li></ol><p>为数据添加label，在第一行加入id,clump_thickness,uniform_cell_size,<br>uniform_cell_shape,marginal_adhesion,<br>single_epi_cell_size,bare_nuclei,bland_chromation,<br>normal_nucleoli,mitoses,class</p><p>数据样式：<br>   clumb_thickness  unif_cell_size  unif_cell_shape  marg_adhesion  single_epith_cell_size bare_nuclei  bland_chrom  norm_nucleoli  mitoses  class<br>0                5               1                1              1                       2           1            3              1        1      2<br>1                5               4                4              5                       7          10            3              2        1      2<br>2                3               1                1              1                       2           2            3              1        1      2<br>3                6               8                8              1                       3           4            3              7        1      2<br>4                4               1                1              3                       2           1            3              1        1      2</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> preprocessing ,model_selection,neighbors</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LinearRegression</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">df = pd.read_csv(<span class="string">'breast-cancer-wisconsin.txt'</span>)<span class="comment">#encoding='utf-8',header=None,sep = '\t'</span></span><br><span class="line">df.replace(<span class="string">'?'</span>,<span class="number">-99999</span>, inplace=<span class="keyword">True</span>)</span><br><span class="line"><span class="comment">#print([column for column in df])</span></span><br><span class="line">df.drop([<span class="string">'id'</span>], <span class="number">1</span>, inplace=<span class="keyword">True</span>)  <span class="comment">#df.drop returns a new dataframe with our chosen column(s) dropped.</span></span><br><span class="line"><span class="comment">#df=df.iloc[:,1:]#.iloc使用全是以0开头的行号和列号，不能直接用其它索引哦。而.loc使用的实际设置的索引和列名。 这就是.loc和.iloc的区别。在实际运用中，我还发现一点区别，.iloc只能选取数据表里实际有的行和列，而.loc可以选取没有的行和列，赋值后就可以添加新行或者列。</span></span><br><span class="line">X = np.array(df.drop([<span class="string">'class'</span>],<span class="number">1</span>))</span><br><span class="line">y = np.array(df[<span class="string">'class'</span>])</span><br><span class="line"></span><br><span class="line">X_train, X_test, y_train, y_test = model_selection.train_test_split(X, y, test_size=<span class="number">0.2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#print([column for column in df])</span></span><br><span class="line"><span class="comment">#clf = LinearRegression(n_jobs=-1)#SVM.svr() kernel='poly'</span></span><br><span class="line">clf = neighbors.KNeighborsClassifier()</span><br><span class="line">clf.fit(X_train,y_train)</span><br><span class="line"></span><br><span class="line">accuracy = clf.score(X_test,y_test)</span><br><span class="line">print(accuracy)</span><br><span class="line">print(df.head())</span><br><span class="line"></span><br><span class="line"><span class="comment">#example_measures = np.array([4,2,1,1,1,2,3,2,1])  #一个sample</span></span><br><span class="line"><span class="comment">#example_measures = example_measures.reshape(1, -1)  #Reshape your data either using array.reshape(-1, 1) if your data has a single feature or array.reshape(1, -1) if it contains a single sample</span></span><br><span class="line">example_measures = np.array([[<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>],[<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]])<span class="comment">#测试用例</span></span><br><span class="line">example_measures = example_measures.reshape(len(example_measures), <span class="number">-1</span>)</span><br><span class="line">prediction = clf.predict(example_measures)</span><br><span class="line"></span><br><span class="line">print(prediction)</span><br></pre></td></tr></table></figure></div><p>accuracy:0.9714285714285714<br>预测结果：prediction[2 2]  两个都为良性</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="机器学习" scheme="https://sunxin18.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="KNN" scheme="https://sunxin18.github.io/tags/KNN/"/>
    
      <category term="应用" scheme="https://sunxin18.github.io/tags/%E5%BA%94%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>实现regression</title>
    <link href="https://sunxin18.github.io/2020/02/01/regression/"/>
    <id>https://sunxin18.github.io/2020/02/01/regression/</id>
    <published>2020-02-01T06:32:13.000Z</published>
    <updated>2020-02-08T07:59:32.569Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="两个error：bias-variance"><a href="#两个error：bias-variance" class="headerlink" title="两个error：bias,variance"></a>两个error：bias,variance</h1><p><a href="/2020/02/01/regression/1.png" data-fancybox="group" data-caption class="fancybox"><img src="/2020/02/01/regression/1.png" alt title></a><br><a href="/2020/02/01/regression/2.png" data-fancybox="group" data-caption class="fancybox"><img src="/2020/02/01/regression/2.png" alt title></a><br>What to do with large bias?<br>1.Add more features as input<br>2.模型更复杂<br>What to do with large variance?<br>1.更多数据<br>2.增加正则化</p><h1 id="梯度下降"><a href="#梯度下降" class="headerlink" title="梯度下降"></a>梯度下降</h1><p>学习率和损失函数的关系：<br>学习率大容易错过loss的最低点，学习率小下降慢<br><a href="/2020/02/01/regression/4.png" data-fancybox="group" data-caption class="fancybox"><img src="/2020/02/01/regression/4.png" alt title></a></p><p>随着我们更新次数的增大，我们是希望我们的学习率越来越慢，因为分母是累加梯度的平方，到后面累加的比较大。因为我们认为在学习率的最初阶段，我们是距离损失函数最优解很远的，随着更新的次数的增多，我们认为越来越接近最优解，于是学习速率也随之变慢。<br><a href="/2020/02/01/regression/5.png" data-fancybox="group" data-caption class="fancybox"><img src="/2020/02/01/regression/5.png" alt title></a><br><a href="/2020/02/01/regression/6.png" data-fancybox="group" data-caption class="fancybox"><img src="/2020/02/01/regression/6.png" alt title></a></p><p><a href="chrome-extension://cdonnmffkdaoajfknoeeecmchibpmkmg/assets/pdf/web/viewer.html?file=http%3A%2F%2Fspeech.ee.ntu.edu.tw%2F~tlkagk%2Fcourses%2FML_2016%2FLecture%2FGradient%2520Descent%2520(v2" target="_blank" rel="noopener">梯度下降理论</a>.pdf)<br>实际是用泰勒函数的近似<br><a href="/2020/02/01/regression/7.png" data-fancybox="group" data-caption class="fancybox"><img src="/2020/02/01/regression/7.png" alt title></a><br><a href="/2020/02/01/regression/8.png" data-fancybox="group" data-caption class="fancybox"><img src="/2020/02/01/regression/8.png" alt title></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> statistics <span class="keyword">import</span> mean</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> style</span><br><span class="line">style.use(<span class="string">'ggplot'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_dataset</span><span class="params">(hm,variance,step=<span class="number">2</span>,correlation=False)</span>:</span></span><br><span class="line">    val = <span class="number">1</span></span><br><span class="line">    ys = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(hm):</span><br><span class="line">        y = val + random.randrange(-variance,variance)</span><br><span class="line">        ys.append(y)</span><br><span class="line">        <span class="keyword">if</span> correlation <span class="keyword">and</span> correlation == <span class="string">'pos'</span>:</span><br><span class="line">            val+=step</span><br><span class="line">        <span class="keyword">elif</span> correlation <span class="keyword">and</span> correlation == <span class="string">'neg'</span>:</span><br><span class="line">            val-=step</span><br><span class="line"></span><br><span class="line">    xs = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(len(ys))]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> np.array(xs, dtype=np.float64),np.array(ys,dtype=np.float64)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">best_fit_slope_and_intercept</span><span class="params">(xs,ys)</span>:</span></span><br><span class="line">    m = (mean(xs)*mean(ys)-mean(xs*ys)) / (mean(xs)*mean(xs)-mean(xs*xs))</span><br><span class="line">    b= mean(ys)-m*mean(xs)</span><br><span class="line">    <span class="keyword">return</span> m,b</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">squared_error</span><span class="params">(ys_orig,ys_line)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> sum((ys_line - ys_orig) * (ys_line - ys_orig))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">coefficient_of_determination</span><span class="params">(ys_orig,ys_line)</span>:</span></span><br><span class="line">    y_mean_line = [mean(ys_orig) <span class="keyword">for</span> y <span class="keyword">in</span> ys_orig]</span><br><span class="line"></span><br><span class="line">    squared_error_regr = sum((ys_line - ys_orig) * (ys_line - ys_orig))</span><br><span class="line">    squared_error_y_mean = sum((y_mean_line - ys_orig) * (y_mean_line - ys_orig))</span><br><span class="line"></span><br><span class="line">    print(squared_error_regr)</span><br><span class="line">    print(squared_error_y_mean)</span><br><span class="line"></span><br><span class="line">    r_squared = <span class="number">1</span> - (squared_error_regr/squared_error_y_mean)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> r_squared</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">xs, ys = create_dataset(<span class="number">40</span>,<span class="number">40</span>,<span class="number">2</span>,correlation=<span class="string">'pos'</span>)</span><br><span class="line">m, b = best_fit_slope_and_intercept(xs,ys)</span><br><span class="line">regression_line = [(m*x)+b <span class="keyword">for</span> x <span class="keyword">in</span> xs]</span><br><span class="line">r_squared = coefficient_of_determination(ys,regression_line)</span><br><span class="line">print(r_squared)</span><br><span class="line">plt.scatter(xs,ys,color=<span class="string">'#003F72'</span>, label = <span class="string">'data'</span>)</span><br><span class="line">plt.plot(xs, regression_line, label = <span class="string">'regression line'</span>)</span><br><span class="line">plt.legend(loc=<span class="number">4</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></div><p>R-square：分子是预测数据与原始数据均值之差的平方和，分母是原始数据和均值之差的平方和<br>R-square=0.5288792849075254<br><a href="/2020/02/01/regression/3.png" data-fancybox="group" data-caption class="fancybox"><img src="/2020/02/01/regression/3.png" alt title></a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="机器学习" scheme="https://sunxin18.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="线性回归" scheme="https://sunxin18.github.io/tags/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/"/>
    
      <category term="梯度下降" scheme="https://sunxin18.github.io/tags/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D/"/>
    
  </entry>
  
  <entry>
    <title>中国加油！</title>
    <link href="https://sunxin18.github.io/2020/01/28/china/"/>
    <id>https://sunxin18.github.io/2020/01/28/china/</id>
    <published>2020-01-28T05:58:55.000Z</published>
    <updated>2020-02-06T06:55:19.428Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>时代的一粒灰，落在个人头上，就是一座山。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>博客报错总结</title>
    <link href="https://sunxin18.github.io/2020/01/21/error/"/>
    <id>https://sunxin18.github.io/2020/01/21/error/</id>
    <published>2020-01-21T05:55:03.000Z</published>
    <updated>2020-02-05T12:58:18.478Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>github解决端口22不能连接错误<br>报错内容：ssh: connect to host github.com port 22: Connection timed out</p><p>解决方法：<br>打开这个文件C:\Program Files\Git\etc\ssh\ssh_config</p><p>添加以下内容：Host github.com<br>User <a href="mailto:xxxxx@email.com" target="_blank" rel="noopener">xxxxx@email.com</a><br>Hostname ssh.github.com<br>PreferredAuthentications publickey<br>IdentityFile ~/.ssh/id_rsa<br>Port 443</p><p>报错内容： 出现了npm ERR! Error: EPERM: operation not permitted, open ‘C:\Users\Administrator，npm-v显示bash: npm-v: command not found，<br>解决方法： 输入npm install hexo-deployer-git –save。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>gragh</title>
    <link href="https://sunxin18.github.io/2020/01/21/gragh/"/>
    <id>https://sunxin18.github.io/2020/01/21/gragh/</id>
    <published>2020-01-21T02:41:25.000Z</published>
    <updated>2020-01-21T02:41:25.498Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>linear regression实战（股票预测）</title>
    <link href="https://sunxin18.github.io/2020/01/14/machine-learning/"/>
    <id>https://sunxin18.github.io/2020/01/14/machine-learning/</id>
    <published>2020-01-14T11:54:12.000Z</published>
    <updated>2020-02-04T03:24:09.336Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>从quandl获取股票数据(Open：开盘价Close：收盘价High：最高价Low：最低价Volume：成交量),留下有用的feature<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> quandl</span><br><span class="line">df =quandl.get(<span class="string">"WIKI/GOOGL"</span>)</span><br><span class="line">df =df[[<span class="string">'Adj. Open'</span>,  <span class="string">'Adj. High'</span>,  <span class="string">'Adj. Low'</span>,  <span class="string">'Adj. Close'</span>, <span class="string">'Adj. Volume'</span>]]</span><br><span class="line">df[<span class="string">'HL_PCT'</span>] = (df[<span class="string">'Adj. High'</span>] - df[<span class="string">'Adj. Low'</span>]) / df[<span class="string">'Adj. Close'</span>] * <span class="number">100.0</span></span><br><span class="line">df[<span class="string">'PCT_change'</span>]=(df[<span class="string">'Adj. Close'</span>] - df[<span class="string">'Adj. Open'</span>]) / df[<span class="string">'Adj. Open'</span>] * <span class="number">100.0</span></span><br><span class="line">df = df[[<span class="string">'Adj. Close'</span>, <span class="string">'HL_PCT'</span>, <span class="string">'PCT_change'</span>, <span class="string">'Adj. Volume'</span>]]</span><br><span class="line">print(df.head())</span><br></pre></td></tr></table></figure></div></p><pre><code>Adj. Close    HL_PCT  PCT_change  Adj. Volume</code></pre><p>Date<br>2004-08-19   50.322842  8.072956    0.324968   44659000.0<br>2004-08-20   54.322689  7.921706    7.227007   22834300.0<br>2004-08-23   54.869377  4.049360   -1.227880   18256100.0<br>2004-08-24   52.597363  7.657099   -5.726357   15247300.0</p><p>fillna() 函数：有一个inplace参数，默认为false，不会对原来dataframe中进行替换，为True时候会修改原来的</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">forecast_col=<span class="string">'Adj.Close'</span></span><br><span class="line">df.fillna(value=<span class="number">-9999</span>,inplace=true)</span><br><span class="line">forecast_out = int(math.ceil(<span class="number">0.01</span> * len(df)))<span class="comment">#比如现在有100天的数据，去预测未来一天的</span></span><br><span class="line"></span><br><span class="line">x=np.array(df.drop([<span class="string">'lable'</span>,<span class="number">1</span>]) <span class="comment">#当你要删除某一行或者某一列时，用drop函数，它不改变原有的df中的数据，而是返回另一个dataframe来存放删除后的数据</span></span><br><span class="line">y=np..array(df[<span class="string">'labble'</span>])</span><br><span class="line">X=preprocessing.scale(X) <span class="comment">#特征在[-1,1]</span></span><br></pre></td></tr></table></figure></div><p>Fit(): Method calculates the parameters μ and σ and saves them as internal objects.<br>解释：简单来说，就是求得训练集X的均值啊，方差啊，最大值啊，最小值啊这些训练集X固有的属性。可以理解为一个训练过程</p><p>Transform(): Method using these calculated parameters apply the transformation to a particular dataset.<br>解释：在Fit的基础上，进行标准化，降维，归一化等操作（看具体用的是哪个工具，如PCA，StandardScaler等）。</p><p>Fit_transform(): joins the fit() and transform() method for transformation of dataset.<br>解释：fit_transform是fit和transform的组合，既包括了训练又包含了转换。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">X_lately = X[-forecast_out:]</span><br><span class="line">X_lately=X[-forecast_out:]</span><br><span class="line">y = np.array(df[<span class="string">'label'</span>])</span><br><span class="line">print(len(X), len(y))</span><br><span class="line">X_train, X_test, y_train, y_test = model_selection.train_test_split(X, y, test_size=<span class="number">0.2</span>)</span><br><span class="line">clf = svm.SVR()<span class="comment">#kernel='poly'</span></span><br><span class="line">clf.fit(X_train, y_train)</span><br><span class="line">confidence = clf.score(X_test, y_test)</span><br><span class="line">forecast_set = clf.predict(X_lately)</span><br><span class="line">print(confidence,forecast_set)</span><br><span class="line">df[<span class="string">'Forecast'</span>] = np.nan</span><br><span class="line"></span><br><span class="line">last_date = df.iloc[<span class="number">-1</span>].name  <span class="comment">#iloc,loc:https://www.jianshu.com/p/f430d4f1b33f</span></span><br><span class="line">last_unix = last_date.timestamp() <span class="comment">#转化为时间戳</span></span><br><span class="line">one_day = <span class="number">86400</span></span><br><span class="line">next_unix = last_unix + one_day</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> forecast_set:</span><br><span class="line">    next_date = datetime.datetime.fromtimestamp(next_unix)</span><br><span class="line">    next_unix += <span class="number">86400</span></span><br><span class="line">    df.loc[next_date]= [np.nan <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(df.columns)<span class="number">-1</span>)]+[i]</span><br><span class="line"></span><br><span class="line">df[<span class="string">'Adj. Close'</span>].plot()</span><br><span class="line">df[<span class="string">'Forecast'</span>].plot()</span><br><span class="line">plt.legend(loc=<span class="number">4</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Date'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Price'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="机器学习" scheme="https://sunxin18.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="应用" scheme="https://sunxin18.github.io/tags/%E5%BA%94%E7%94%A8/"/>
    
      <category term="regression" scheme="https://sunxin18.github.io/tags/regression/"/>
    
  </entry>
  
  <entry>
    <title>dp</title>
    <link href="https://sunxin18.github.io/2019/12/06/dp/"/>
    <id>https://sunxin18.github.io/2019/12/06/dp/</id>
    <published>2019-12-06T15:55:55.000Z</published>
    <updated>2019-12-06T15:58:28.059Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>1.最大子序和<br>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p>示例:<br>输入: [-2,1,-3,4,-1,2,1,-5,4],<br>输出: 6<br>解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> dp=<span class="number">0</span>,result=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++)&#123;</span><br><span class="line">              <span class="keyword">if</span>(dp&gt;<span class="number">0</span>)</span><br><span class="line">                dp=dp+nums[i];</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                dp=nums[i];</span><br><span class="line">               result=max(result,dp);</span><br><span class="line">                 </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></p><p>2.最小路径和<br>给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p><p>说明：每次只能向下或者向右移动一步。</p><p>示例:</p><p>输入:<br>[<br>  [1,3,1],<br>  [1,5,1],<br>  [4,2,1]<br>]<br>输出: 7<br>解释: 因为路径 1→3→1→1→1 的总和最小。<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(grid.empty())<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> dp[grid.size()][grid[<span class="number">0</span>].size()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;grid.size();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;grid[<span class="number">0</span>].size();j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(i==<span class="number">0</span>&amp;&amp;j==<span class="number">0</span>)  dp[<span class="number">0</span>][<span class="number">0</span>]=grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(i==<span class="number">0</span>)</span><br><span class="line">                        dp[i][j]= dp[i][j<span class="number">-1</span>]+grid[i][j];</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(j==<span class="number">0</span>)</span><br><span class="line">                        dp[i][j]= dp[i<span class="number">-1</span>][j]+grid[i][j];</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        dp[i][j]=min(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>])+grid[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[grid.size()<span class="number">-1</span>][grid[<span class="number">0</span>].size()<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Node Classification</title>
    <link href="https://sunxin18.github.io/2019/11/05/classify/"/>
    <id>https://sunxin18.github.io/2019/11/05/classify/</id>
    <published>2019-11-05T13:52:18.000Z</published>
    <updated>2020-02-13T08:33:17.301Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Node-Classification"><a href="#Node-Classification" class="headerlink" title="Node Classification"></a>Node Classification</h1><p>Node Classification is the process of assigning labels to nodes within a graph, given a set of existing node labels. This setting corresponds to a semi-supervised setting. While it would be nice to be able to collect the true label values of every node, oftentimes, in real world settings, it is extremely expensive to collect those labels. Consequently, we rely on random sampling to obtain these labels. Then we use that small sample of labels to develop models that generate trustworthy node label predictions for our graph.</p><p>Collective Classification is an umbrella term describing how we assign labels to all nodes in the network together. We then propagate the information from these labels around the network and attempt to come up with stable assignments for each node. We are able to do these tasks because networks have special properties, specifically, correlations between nodes, that we can leverage to build our predictor. Essentially, collective classification relies on the Markov Assumption that the labely $Y_{i}$ of one node depends on the labels of its neighbors, which can be mathematically written as:$P(Y_{i}|i)=P(Y_{i}|N_{i})$</p><p>The three main techniques that are used are Relational Classification, Iterative Classification, and Belief Classification, roughly ordered byhow advanced these methods are.</p><h1 id="Correlations-in-a-Network"><a href="#Correlations-in-a-Network" class="headerlink" title="Correlations in a Network"></a>Correlations in a Network</h1><h2 id="Homophily"><a href="#Homophily" class="headerlink" title="Homophily"></a>Homophily</h2><p>Homophily generally refers to the tendency of individuals to associate and bond with similar others. Similarities, for instance in a social network, can include a variety of attributes, including age, gender, organizational affiliation, taste, and more.</p><h2 id="Influence"><a href="#Influence" class="headerlink" title="Influence"></a>Influence</h2><p>Another example of why networks may demonstrate correlations is Influence. Under these circumstances, the links and edges formed can influence the behavior of the node itself</p><h2 id="Confounding"><a href="#Confounding" class="headerlink" title="Confounding"></a>Confounding</h2><p>Confounding variables can cause nodes to exhibit similar characteristics. For instance, the environment we are raised in may influence our similarity in multiple dimensions, from the language we speak, to our music tastes, to our political preferences.</p><h1 id="Leveraging-Network-Correlations-for-Classification-of-Network-Data"><a href="#Leveraging-Network-Correlations-for-Classification-of-Network-Data" class="headerlink" title="Leveraging Network Correlations for Classification of Network Data"></a>Leveraging Network Correlations for Classification of Network Data</h1><p>Whether or not a particular node X receives a particular label may depend on a variety of factors. In our context, those most commonly include:<br><em>X的featrue</em>X邻居的feature<br><em>X邻居的lable<br>我们也要考虑网络的拓扑结构。Collective classification包括三个部分</em>A local classifier初始化节点lable<br>    -根据节点的属性和特征，不考虑拓扑结构<br><em>A relational classifier is useful because it allows us to capture correlations (e.g. the homophily, influence) between nodes in the network.<br>    -This classifier predicts the label of one node based on the labels and features of its neighbors.<br>    -This classifier predicts the label of one node based on the labels and features of its neighbors.</em>Collective inference propagates the correlations through the network. 经过多次传递，得到邻居点间的contribution<br>    -当节点和邻点之间的差异最小或者到达最大递归次数停止<br>    -节点结构对最终预测有很大的影响<br><a href="/2019/11/05/classify/1.png" data-fancybox="group" data-caption class="fancybox"><img src="/2019/11/05/classify/1.png" alt title></a></p><p>To make those predictions, we will use a Probabilistic Relational Classifier, the basic idea of which is that the class probability of $Y_{i}$<br> is a weighted average of the class probabilities of its neighbors. To initialize, we will use the ground-truth labels of our labeled nodes, and for the unlabeled nodes, we will initialize Y uniformly。使用随机的序列</p><p> week points:不能保证收敛，模型没有使用node feature</p><h1 id="Iterative-Classification"><a href="#Iterative-Classification" class="headerlink" title="Iterative Classification"></a>Iterative Classification</h1><p>This is very similar to what we did before with the relational classifier, the key difference being that we now use the feature vector and once again, convergence is not guaranteed.</p><h1 id="Message-Passing-Belief-Propagation"><a href="#Message-Passing-Belief-Propagation" class="headerlink" title="Message Passing/Belief Propagation"></a>Message Passing/Belief Propagation</h1><p><a href="/2019/11/05/classify/2.png" data-fancybox="group" data-caption class="fancybox"><img src="/2019/11/05/classify/2.png" alt title></a><br><a href="/2019/11/05/classify/3.png" data-fancybox="group" data-caption class="fancybox"><img src="/2019/11/05/classify/3.png" alt title></a><br>This equation summarizes our task: to calculate the message from i to j, we will sum over all of our states the label-label potential multiplied by our prior, multiplied by the product of all the messages sent by neighbors from the previous rounds. To initialize, we set all of our messages equal to 1. Then, we calculate our message from i to j, using the formula described above. We will repeat this for each node until we reach convergence, and then we can calculate our final assignment, i’s belief of being in state $Y_{i}$ or $b(Y_{i})$<br><a href="/2019/11/05/classify/4.png" data-fancybox="group" data-caption class="fancybox"><img src="/2019/11/05/classify/4.png" alt title></a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="图" scheme="https://sunxin18.github.io/categories/%E5%9B%BE/"/>
    
    
  </entry>
  
</feed>

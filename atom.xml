<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>lalala</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://sunxin18.github.io/"/>
  <updated>2020-05-08T08:13:41.249Z</updated>
  <id>https://sunxin18.github.io/</id>
  
  <author>
    <name>Sunxin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>华为云口罩配送大赛经验分享</title>
    <link href="https://sunxin18.github.io/2020/05/08/huawei/"/>
    <id>https://sunxin18.github.io/2020/05/08/huawei/</id>
    <published>2020-05-08T01:06:27.000Z</published>
    <updated>2020-05-08T08:13:41.249Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>比赛链接：<a href="https://competition.huaweicloud.com/information/1000037176/introduction" target="_blank" rel="noopener">https://competition.huaweicloud.com/information/1000037176/introduction</a></p><h3 id="赛题分析："><a href="#赛题分析：" class="headerlink" title="赛题分析："></a>赛题分析：</h3><ol><li>地图大小为12×12，需求点固定为5个，配送目标是将所有需求点的需求进行满足，配送过程中会随机生成捐赠小区</li><li>纯命令行交互，使用标准I/O作为命令（S/R/G）和移动方向(E/W/S/N)的传递途径</li><li>在1000张地图上测试</li></ol><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>我没有做太多的思考，思路也很容易理解，首先先到的就是greedy策略，每次都选择当前最好的选择，当然这只能考虑到局部最优，但最后结果还不错，能排进前二十。</li><li>每次配送的时候都优先选择离当前最近的需求点配送，取货的时候给每个捐赠小区一个ranking，就按照捐赠数量/距离来做，试了一下距离的平方结果不如绝对值。</li><li>配送有几种情况需要考虑：<ul><li>车上口罩为0，那么肯定要去取货，那么就按ranking来选择</li><li>车上口罩为100，那么肯定要去送货，就选择最近的，因为最远的周边可能后续会生成捐赠小区    </li><li>接下的两种情况最难考虑，就是送完一个小区或者刚取完一些车上还剩，那么是去接着送别的小区，还是取货呢？我的想法就是也写一个ranking比较，送货和取货的价值比较，但要考虑一些特殊情况，如果此时的货够最近的需求小区a那么就去送，如果此时的货加上离aranking最高的取货点足够那么就直接去取货点取货，当然这考虑非常不够，很需要改进,可以学习依一下别的选手的思路。</li></ul></li></ol><h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><p>下面对我的代码进行讲解，用python写的.<br>load:当前装载量<br>target：目标地<br>R(字典)：对应坐标的货量，需求点就是负值，捐赠和仓库就是正值，<em>坐标要用元组，不是列表</em></p><h4 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h4><h5 id="需求小区仓库初始化"><a href="#需求小区仓库初始化" class="headerlink" title="需求小区仓库初始化"></a>需求小区仓库初始化</h5><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    new_string=input()</span><br><span class="line">    s_list=new_string.split()</span><br><span class="line">    S=(int(s_list[<span class="number">1</span>]),int(s_list[<span class="number">2</span>]))</span><br><span class="line">    R=&#123;&#125;</span><br><span class="line">    R[(int(s_list[<span class="number">1</span>]),int(s_list[<span class="number">2</span>]))]=<span class="number">100</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">5</span>):</span><br><span class="line">        new_string=input()</span><br><span class="line">        r_list=new_string.split()</span><br><span class="line">        R[(int(r_list[<span class="number">1</span>]),int(r_list[<span class="number">2</span>]))]=int(r_list[<span class="number">3</span>])</span><br><span class="line">    p=list(S)</span><br><span class="line">    load=<span class="number">0</span>             <span class="comment">#初始化装载量为0</span></span><br><span class="line">    target=S</span><br></pre></td></tr></table></figure></div><h5 id="选择（每次到达小区或者捐赠点就行下一步的选择"><a href="#选择（每次到达小区或者捐赠点就行下一步的选择" class="headerlink" title="选择（每次到达小区或者捐赠点就行下一步的选择)"></a>选择（每次到达小区或者捐赠点就行下一步的选择)</h5><p>这里我加入了一个配送时如果有顺路的捐赠小区，那就去取一下<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        P=tuple(p)</span><br><span class="line">        <span class="keyword">if</span> P == S:</span><br><span class="line">            load = <span class="number">100</span></span><br><span class="line">            target = choose_na_target(p)</span><br><span class="line">        <span class="keyword">elif</span> P <span class="keyword">in</span> R.keys():</span><br><span class="line">            sum=load+R[P]</span><br><span class="line">            <span class="keyword">if</span> R[P] &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> sum&lt;<span class="number">0</span>:</span><br><span class="line">                    load=<span class="number">0</span></span><br><span class="line">                    R[P]=sum</span><br><span class="line">                    <span class="keyword">if</span> R[closest(p)] &gt;= -R[P]:</span><br><span class="line">                        target = closest(p)</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        target= choose_target(p)        <span class="comment">#车空就去送取货</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">del</span> R[P]</span><br><span class="line">                    <span class="keyword">if</span> len(R)==<span class="number">0</span>:</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                    <span class="keyword">if</span> min(R.values())&gt;<span class="number">0</span>:</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                    load=sum</span><br><span class="line">                    target1 = choose_na_target(p)</span><br><span class="line">                    target2 = choose_target(p)</span><br><span class="line">                    target3 = choose_target(target1)</span><br><span class="line">                    <span class="keyword">if</span> load &gt;= -R[target1]: </span><br><span class="line">                        target = target1</span><br><span class="line">                    <span class="keyword">elif</span> load + R[target3] &gt;= -R[target1]:</span><br><span class="line">                        target = target3</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        target =  com_value(p ,target1,target2)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> sum &gt; <span class="number">100</span>:</span><br><span class="line">                    load=<span class="number">100</span></span><br><span class="line">                    R[P]=sum<span class="number">-100</span></span><br><span class="line">                    target = choose_na_target(p)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">del</span> R[P]</span><br><span class="line">                    load=sum</span><br><span class="line">                    target1 = choose_na_target(p)</span><br><span class="line">                    target2 = choose_target(p)</span><br><span class="line">                    <span class="keyword">if</span> load &gt;= -R[target1]: </span><br><span class="line">                        target = target1</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        target =  com_value(p ,target1,target2)</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> R.keys():<span class="comment">#顺路就去取</span></span><br><span class="line">                <span class="keyword">if</span> R[k] &gt; <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">if</span>(k[<span class="number">0</span>]&gt;=target[<span class="number">0</span>] <span class="keyword">and</span>  k[<span class="number">0</span>]&lt;=p[<span class="number">0</span>]) <span class="keyword">or</span> (k[<span class="number">0</span>]&lt;=target[<span class="number">0</span>] <span class="keyword">and</span>  k[<span class="number">0</span>]&gt;=p[<span class="number">0</span>]):</span><br><span class="line">                        <span class="keyword">if</span>(k[<span class="number">1</span>]&gt;=target[<span class="number">1</span>] <span class="keyword">and</span>  k[<span class="number">1</span>]&lt;=p[<span class="number">1</span>]) <span class="keyword">or</span> (k[<span class="number">1</span>]&lt;=target[<span class="number">1</span>] <span class="keyword">and</span>  k[<span class="number">1</span>]&gt;=p[<span class="number">1</span>]):</span><br><span class="line">                            target = k</span><br></pre></td></tr></table></figure></div></p><h5 id="读取命令行输入"><a href="#读取命令行输入" class="headerlink" title="读取命令行输入"></a>读取命令行输入</h5><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">new_string=input()</span><br><span class="line">        <span class="keyword">if</span> new_string==<span class="string">'G'</span>:          <span class="comment">#读取到行动的命令，向target移动</span></span><br><span class="line">            p,next_step=step(p,target)</span><br><span class="line">            print(next_step)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            r_list=new_string.split()</span><br><span class="line">            <span class="keyword">if</span> p[<span class="number">0</span>] == int(r_list[<span class="number">1</span>]) <span class="keyword">and</span> p[<span class="number">1</span>] == int(r_list[<span class="number">2</span>]):                   <span class="comment">#空投贴脸hhh</span></span><br><span class="line">                <span class="keyword">if</span> load + int(r_list[<span class="number">3</span>]) &lt;= <span class="number">100</span>:</span><br><span class="line">                    load = load + int(r_list[<span class="number">3</span>])</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    R[(int(r_list[<span class="number">1</span>]),int(r_list[<span class="number">2</span>]))]=int(r_list[<span class="number">3</span>])<span class="number">-100</span>+load</span><br><span class="line">                    load = <span class="number">100</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                R[(int(r_list[<span class="number">1</span>]),int(r_list[<span class="number">2</span>]))]=int(r_list[<span class="number">3</span>])           <span class="comment">#更新一下选择</span></span><br><span class="line">                <span class="keyword">if</span>  R[target] &gt; <span class="number">0</span>:     <span class="comment">#注意R里没有S</span></span><br><span class="line">                    target = choose_target(p)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    cur_target = (int(r_list[<span class="number">1</span>]),int(r_list[<span class="number">2</span>]))</span><br><span class="line">                    target = com_value(p ,target,cur_target)</span><br></pre></td></tr></table></figure></div><h5 id="移动函数"><a href="#移动函数" class="headerlink" title="移动函数"></a>移动函数</h5><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">step</span><span class="params">(pos,to)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> pos[<span class="number">0</span>]&lt;to[<span class="number">0</span>]:</span><br><span class="line">        pos[<span class="number">0</span>]=pos[<span class="number">0</span>]+<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> pos,<span class="string">'S'</span></span><br><span class="line">    <span class="keyword">elif</span> pos[<span class="number">0</span>]&gt;to[<span class="number">0</span>]:</span><br><span class="line">        pos[<span class="number">0</span>]=pos[<span class="number">0</span>]<span class="number">-1</span></span><br><span class="line">        <span class="keyword">return</span> pos,<span class="string">'N'</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> pos[<span class="number">1</span>]&lt;to[<span class="number">1</span>]:</span><br><span class="line">            pos[<span class="number">1</span>]=pos[<span class="number">1</span>]+<span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> pos,<span class="string">'E'</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            pos[<span class="number">1</span>]=pos[<span class="number">1</span>]<span class="number">-1</span></span><br><span class="line">            <span class="keyword">return</span> pos,<span class="string">'W'</span></span><br></pre></td></tr></table></figure></div><h5 id="选择捐赠小区和需求小区"><a href="#选择捐赠小区和需求小区" class="headerlink" title="选择捐赠小区和需求小区"></a>选择捐赠小区和需求小区</h5><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">choose_na_target</span><span class="params">(pos)</span>:</span></span><br><span class="line">    na_distance=<span class="number">0</span></span><br><span class="line">    <span class="keyword">global</span> load</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> R.keys():</span><br><span class="line">        <span class="keyword">if</span> R[k] &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> k[<span class="number">0</span>]==pos[<span class="number">0</span>] <span class="keyword">and</span> k[<span class="number">1</span>]==pos[<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            cur_dis2 = <span class="number">1</span>/ (abs(pos[<span class="number">0</span>]-k[<span class="number">0</span>])+abs(pos[<span class="number">1</span>]-k[<span class="number">1</span>])+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> cur_dis2 &gt; na_distance:</span><br><span class="line">                na_distance = cur_dis2</span><br><span class="line">                tar = k</span><br><span class="line">    <span class="keyword">return</span> tar</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">choose_target</span><span class="params">(pos)</span>:</span></span><br><span class="line">    po_distance=<span class="number">0</span></span><br><span class="line">    <span class="keyword">global</span> load</span><br><span class="line">    distance = (<span class="number">100</span>-load)/ (abs(pos[<span class="number">0</span>]-S[<span class="number">0</span>])+abs(pos[<span class="number">1</span>]-S[<span class="number">1</span>])+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> R.keys():</span><br><span class="line">        <span class="keyword">if</span> R[k] &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> k[<span class="number">0</span>]==pos[<span class="number">0</span>] <span class="keyword">and</span> k[<span class="number">1</span>]==pos[<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> R[k] + load &gt; <span class="number">100</span>:</span><br><span class="line">                cur_dis1 = (<span class="number">100</span>-load)/ (abs(pos[<span class="number">0</span>]-k[<span class="number">0</span>])+abs(pos[<span class="number">1</span>]-k[<span class="number">1</span>])+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur_dis1 = R[k] / (abs(pos[<span class="number">0</span>] - k[<span class="number">0</span>]) + abs(pos[<span class="number">1</span>] - k[<span class="number">1</span>])+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> cur_dis1 &gt; po_distance:</span><br><span class="line">                po_distance = cur_dis1</span><br><span class="line">                tar =k   </span><br><span class="line">    <span class="keyword">if</span>  po_distance&gt; distance:</span><br><span class="line">        <span class="keyword">return</span> tar </span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> S</span><br></pre></td></tr></table></figure></div><h5 id="捐赠小区和需求小区的比较ranking"><a href="#捐赠小区和需求小区的比较ranking" class="headerlink" title="捐赠小区和需求小区的比较ranking"></a>捐赠小区和需求小区的比较ranking</h5><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">com_value</span><span class="params">(pos,target1,target2)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> target</span><br><span class="line">    <span class="keyword">if</span> load &lt; -R[target1]:</span><br><span class="line">        cur_value1 = load</span><br><span class="line">    <span class="keyword">else</span>: </span><br><span class="line">        cur_value1 = -R[target1]</span><br><span class="line">    value1 = cur_value1 / (abs(pos[<span class="number">0</span>]-target1[<span class="number">0</span>])+abs(pos[<span class="number">1</span>]-target1[<span class="number">1</span>])+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> load +R[target2] &gt; <span class="number">100</span>:</span><br><span class="line">        cur_value2 = <span class="number">100</span> -load</span><br><span class="line">    <span class="keyword">else</span>: </span><br><span class="line">        cur_value2 = R[target2]</span><br><span class="line">    value2 = cur_value2 / (abs(pos[<span class="number">0</span>]-target2[<span class="number">0</span>])+abs(pos[<span class="number">1</span>]-target2[<span class="number">1</span>])+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> value1 &gt;value2:</span><br><span class="line">        <span class="keyword">return</span> target1</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> target2</span><br></pre></td></tr></table></figure></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="比赛" scheme="https://sunxin18.github.io/tags/%E6%AF%94%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title>换新电脑hexo博客的迁移</title>
    <link href="https://sunxin18.github.io/2020/04/29/blog-trsf/"/>
    <id>https://sunxin18.github.io/2020/04/29/blog-trsf/</id>
    <published>2020-04-29T12:14:36.000Z</published>
    <updated>2020-04-30T02:31:42.148Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="一、拷贝原始电脑blog文件夹到新电脑"><a href="#一、拷贝原始电脑blog文件夹到新电脑" class="headerlink" title="一、拷贝原始电脑blog文件夹到新电脑"></a>一、拷贝原始电脑blog文件夹到新电脑</h2><h2 id="二、安装git、node-js"><a href="#二、安装git、node-js" class="headerlink" title="二、安装git、node.js"></a>二、安装git、node.js</h2><h2 id="三、安装-hexo"><a href="#三、安装-hexo" class="headerlink" title="三、安装 hexo"></a>三、安装 hexo</h2><p>在 cmd 下输入下面指令安装 hexo<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><figcaption><span>install hexo-cli -g```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 四、在blog文件夹下执行git bash，输入以下命令</span><br><span class="line">```npm install</span><br><span class="line">npm install hexo-deployer-git --save  // 文章部署到 git 的模块</span><br><span class="line">（下面为选择安装）</span><br><span class="line">npm install hexo-generator-feed --save  // 建立 RSS 订阅</span><br><span class="line">npm install hexo-generator-sitemap --save // 建立站点地图</span><br></pre></td></tr></table></figure></div></p><h2 id="五、创建ssh"><a href="#五、创建ssh" class="headerlink" title="五、创建ssh"></a>五、创建ssh</h2><h3 id="（1）打开git-bash，在用户主目录下运行：ssh-keygen-t-rsa-C-“你的邮箱”-把其中的邮件地址换成自己的邮件地址，然后一路回车"><a href="#（1）打开git-bash，在用户主目录下运行：ssh-keygen-t-rsa-C-“你的邮箱”-把其中的邮件地址换成自己的邮件地址，然后一路回车" class="headerlink" title="（1）打开git bash，在用户主目录下运行：ssh-keygen -t rsa -C “你的邮箱” 把其中的邮件地址换成自己的邮件地址，然后一路回车"></a>（1）打开git bash，在用户主目录下运行：ssh-keygen -t rsa -C “你的邮箱” 把其中的邮件地址换成自己的邮件地址，然后一路回车</h3><h3 id="（2）最后完成后，会在用户主目录下生成-ssh目录，里面有id-rsa和id-rsa-pub两个文件，这两个就是SSH-key密钥对，id-rsa是私钥，千万不能泄露出去，id-rsa-pub是公钥，可以放心地告诉任何人。"><a href="#（2）最后完成后，会在用户主目录下生成-ssh目录，里面有id-rsa和id-rsa-pub两个文件，这两个就是SSH-key密钥对，id-rsa是私钥，千万不能泄露出去，id-rsa-pub是公钥，可以放心地告诉任何人。" class="headerlink" title="（2）最后完成后，会在用户主目录下生成.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH key密钥对，id_rsa是私钥，千万不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。"></a>（2）最后完成后，会在用户主目录下生成.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH key密钥对，id_rsa是私钥，千万不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。</h3><h3 id="（3）登陆GitHub，打开「Settings」-gt-「SSH-and-GPG-keys」，然后点击「new-SSH-key」，填上任意Title，在Key文本框里粘贴公钥id-rsa-pub文件的内容（千万不要粘贴成私钥了！），最后点击「Add-SSH-Key」，你就应该看到已经添加的Key。"><a href="#（3）登陆GitHub，打开「Settings」-gt-「SSH-and-GPG-keys」，然后点击「new-SSH-key」，填上任意Title，在Key文本框里粘贴公钥id-rsa-pub文件的内容（千万不要粘贴成私钥了！），最后点击「Add-SSH-Key」，你就应该看到已经添加的Key。" class="headerlink" title="（3）登陆GitHub，打开「Settings」-&gt;「SSH and GPG keys」，然后点击「new SSH key」，填上任意Title，在Key文本框里粘贴公钥id_rsa.pub文件的内容（千万不要粘贴成私钥了！），最后点击「Add SSH Key」，你就应该看到已经添加的Key。"></a>（3）登陆GitHub，打开「Settings」-&gt;「SSH and GPG keys」，然后点击「new SSH key」，填上任意Title，在Key文本框里粘贴公钥id_rsa.pub文件的内容（千万不要粘贴成私钥了！），最后点击「Add SSH Key」，你就应该看到已经添加的Key。</h3><p><strong>注意：不要在git版本库中运行ssh，然后又将它提交，这样就把密码泄露出去了。</strong></p><h2 id="六、部署可能出现的问题"><a href="#六、部署可能出现的问题" class="headerlink" title="六、部署可能出现的问题"></a>六、部署可能出现的问题</h2><p>git上传包提交时出现：Please tell me who you are.<br><a href="/2020/04/29/blog-trsf/1.png" data-fancybox="group" data-caption class="fancybox"><img src="/2020/04/29/blog-trsf/1.png" alt title></a><br>解决方法：执行<br>git config –global user.email “你的邮箱<br>git config –global user.name “gihub用户名”</p><p>之后就可以正常使用啦</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="博客维护" scheme="https://sunxin18.github.io/categories/%E5%8D%9A%E5%AE%A2%E7%BB%B4%E6%8A%A4/"/>
    
    
      <category term="博客" scheme="https://sunxin18.github.io/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>并行矩阵求逆</title>
    <link href="https://sunxin18.github.io/2020/04/25/parallow/"/>
    <id>https://sunxin18.github.io/2020/04/25/parallow/</id>
    <published>2020-04-25T01:56:10.000Z</published>
    <updated>2020-05-03T12:12:36.464Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><h3 id="parallel"><a href="#parallel" class="headerlink" title="parallel　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　"></a>parallel　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　</h3><p>parallel表示其后语句将被多个线程并行执行，“#pragma omp parallel”后面的语句（或者，语句块）被称为parallel region。<br>多个线程的执行顺序是不能保证的。</p><h3 id="for"><a href="#for" class="headerlink" title="for　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　"></a>for　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　</h3><p>我们一般是对一个计算量庞大的任务进行划分，让多个线程分别执行计算任务的某一部分，从而达到缩短计算时间的目的。这里的关键是，每个线程执行的计算互不相同（操作的数据不同或者计算任务本身不同），多个线程协作完成所有计算。</p><p>OpenMP for指示将C++ for循环的多次迭代划分给多个线程（划分指，每个线程执行的迭代互不重复，所有线程的迭代并起来正好是C++ for循环的所有迭代），这里C++ for循环需要一些限制从而能在执行C++ for之前确定循环次数，例如C++ for中不应含有break等。</p><h3 id="测试下电脑是几核的-几线程"><a href="#测试下电脑是几核的-几线程" class="headerlink" title="测试下电脑是几核的(几线程)"></a>测试下电脑是几核的(几线程)</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;omp.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"parallel begin:\n"</span>;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">pragma</span> omp parallel</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; omp_get_thread_num();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n parallel end.\n"</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.get();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><a href="/2020/04/25/parallow/1.png" data-fancybox="group" data-caption class="fancybox"><img src="/2020/04/25/parallow/1.png" alt title></a></p><p>参考文献：<a href="https://blog.csdn.net/laobai1015/article/details/79020128" target="_blank" rel="noopener">https://blog.csdn.net/laobai1015/article/details/79020128</a></p><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><p>矩阵求逆大致有三个方法，待定系数法、伴随矩阵求逆矩阵，初等变换求逆矩阵。而待定系数法和伴随矩阵对维数大很难计算了，而初等变化法有着清晰的过程，比较容易用编程语言表达，并且遍历矩阵去操作归一化清零等过程可以很容易实现并行化，不同线程的操作是针对不同行和列也不会产生冲突导致错误。<br><a href="/2020/04/25/parallow/2.png" data-fancybox="group" data-caption class="fancybox"><img src="/2020/04/25/parallow/2.png" alt title></a></p><h3 id="实现方案："><a href="#实现方案：" class="headerlink" title="实现方案："></a>实现方案：</h3><p>使用高斯消元法，用二维vector来存储矩阵，方便实现矩阵维度的变化以及遍历，将可并行化的循环加上#pragma omp parallel for实现并行化。</p><h3 id="代码思路"><a href="#代码思路" class="headerlink" title="代码思路"></a>代码思路</h3><p><a href="/2020/04/25/parallow/3.png" data-fancybox="group" data-caption class="fancybox"><img src="/2020/04/25/parallow/3.png" alt title></a></p><h3 id="运行加速比和正确性验证"><a href="#运行加速比和正确性验证" class="headerlink" title="运行加速比和正确性验证"></a>运行加速比和正确性验证</h3><p><a href="/2020/04/25/parallow/4.png" data-fancybox="group" data-caption class="fancybox"><img src="/2020/04/25/parallow/4.png" alt title></a><br><a href="/2020/04/25/parallow/5.png" data-fancybox="group" data-caption class="fancybox"><img src="/2020/04/25/parallow/5.png" alt title></a></p><p>代码基于c++和openmp编写，需要代码邮件call我~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="并行计算" scheme="https://sunxin18.github.io/categories/%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/"/>
    
    
      <category term="openmp" scheme="https://sunxin18.github.io/tags/openmp/"/>
    
  </entry>
  
  <entry>
    <title>pachong</title>
    <link href="https://sunxin18.github.io/2020/04/21/pachong/"/>
    <id>https://sunxin18.github.io/2020/04/21/pachong/</id>
    <published>2020-04-21T02:35:50.000Z</published>
    <updated>2020-04-21T02:35:52.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>pytorch</title>
    <link href="https://sunxin18.github.io/2020/04/16/pytorch/"/>
    <id>https://sunxin18.github.io/2020/04/16/pytorch/</id>
    <published>2020-04-16T02:54:43.000Z</published>
    <updated>2020-05-08T00:57:03.799Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>深度学习有许多应用，这些应用往往包括以某种形式获取数据（例如图像或文本），并以另一种形式生成数据（例如标签，数字或更多文本）。从这个角度来看，深度学习包括构建一个将数据从一种表示转换为另一种表示的系统。<br>从一种数据形式到另一种数据形式的转换通常是由深度神经网络分层次学习的，这意味着我们可以将层次之间转换得到的数据视为一系列中间表示（intermediate representation）。以图像识别为例，浅层的表示可以是特征（例如边缘检测）或纹理（例如毛发），较深层次的表征可以捕获更复杂的结构（例如耳朵、鼻子或眼睛）。</p><h3 id="张量（tensor）"><a href="#张量（tensor）" class="headerlink" title="张量（tensor）"></a>张量（tensor）</h3><p>对于来自数学、物理学或工程学的人来说，张量一词是与空间、参考系以及它们之间的转换的概念是捆绑在一起的。对于其他人来说，张量是指将向量（vector）和矩阵（matrix）推广到任意维度，。与张量相同概念的另一个名称是多维数组（multidimensional array）。张量的维数与用来索引张量中某个标量值的索引数一致。<br><a href="/2020/04/16/pytorch/1.png" data-fancybox="group" data-caption class="fancybox"><img src="/2020/04/16/pytorch/1.png" alt title></a></p><h4 id="张量的优点"><a href="#张量的优点" class="headerlink" title="张量的优点"></a>张量的优点</h4><p>Python列表或数字元组（tuple）是在内存中单独分配的Python对象的集合，如图2.3左侧所示。然而，PyTorch张量或NumPy数组（通常）是连续内存块上的视图（view），这些内存块存有未封装（unboxed）的C数值类型，在本例中，如图2.3右侧所示，就是32位的浮点数（4字节），而不是Python对象。因此，包含100万个浮点数的一维张量需要400万个连续字节存储空间，再加上存放元数据（尺寸、数据类型等）的少量开销。<br><a href="/2020/04/16/pytorch/2.png" data-fancybox="group" data-caption class="fancybox"><img src="/2020/04/16/pytorch/2.png" alt title></a><br>比如可以用zeros或ones来初始化张量，同时用元组指定大小<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">points = torch.zeros(<span class="number">3</span>, <span class="number">2</span>)</span><br><span class="line">points</span><br></pre></td></tr></table></figure></div></p><p>输出：<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tensor([[<span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">        [<span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">        [<span class="number">0.</span>, <span class="number">0.</span>]])</span><br></pre></td></tr></table></figure></div></p><p>##</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="深度学习" scheme="https://sunxin18.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>trie</title>
    <link href="https://sunxin18.github.io/2020/03/28/trie/"/>
    <id>https://sunxin18.github.io/2020/03/28/trie/</id>
    <published>2020-03-28T05:11:50.000Z</published>
    <updated>2020-03-28T05:15:30.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minimumLengthEncoding</span><span class="params">(self, words)</span>:</span></span><br><span class="line">        res=set(words)</span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">1</span>,len(word)):</span><br><span class="line">                res.discard(word[k:])</span><br><span class="line">        <span class="keyword">return</span> sum(len(word) + <span class="number">1</span> <span class="keyword">for</span> word <span class="keyword">in</span> res)</span><br></pre></td></tr></table></figure></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>kmeans</title>
    <link href="https://sunxin18.github.io/2020/03/25/kmeans/"/>
    <id>https://sunxin18.github.io/2020/03/25/kmeans/</id>
    <published>2020-03-25T14:39:27.000Z</published>
    <updated>2020-03-27T14:59:20.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>k-means algorithm算法是一个聚类算法，把n的对象根据他们的属性分为k个分割，k &lt; n。假设对象属性来自于空间向量，并且目标是使各个群组内部的均方误差总和最小。通过迭代的方式将样本分到K个簇。</p><h1 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h1><ol><li>选取K个点做为初始聚集的簇心（也可选择非样本点）;</li><li>分别计算每个样本点到 K个簇核心的距离（这里的距离一般取欧氏距离或余弦距离），找到离该点最近的簇核心，将它归属到对应的簇；</li><li>所有点都归属到簇之后， M个点就分为了 K个簇。之后重新计算每个簇的重心（平均距离中心），将其定为新的“簇核心”；<br>反复迭代 2 - 3 步骤，直到达到某个中止条件</li></ol><h1 id="sklearn实现"><a href="#sklearn实现" class="headerlink" title="sklearn实现"></a>sklearn实现</h1><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> make_blobs</span><br><span class="line"><span class="keyword">from</span> sklearn.cluster <span class="keyword">import</span> KMeans</span><br><span class="line"></span><br><span class="line"><span class="comment">#产生数据</span></span><br><span class="line">k=<span class="number">4</span></span><br><span class="line">X,Y = make_blobs(n_samples=<span class="number">100</span>, n_features=<span class="number">2</span>, centers=k)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#构建模型</span></span><br><span class="line">km = KMeans(n_clusters=k, init=<span class="string">'k-means++'</span>, max_iter=<span class="number">300</span>)</span><br><span class="line">km.fit(X)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取簇心</span></span><br><span class="line">centroids = km.cluster_centers_</span><br><span class="line"><span class="comment"># 获取归集后的样本所属簇对应值</span></span><br><span class="line">y_kmean = km.predict(X)</span><br><span class="line">print(y_kmean)</span><br><span class="line"><span class="comment"># 呈现未归集前的数据</span></span><br><span class="line">plt.scatter(X[:, <span class="number">0</span>], X[:, <span class="number">1</span>], s=<span class="number">50</span>)</span><br><span class="line">plt.yticks(())</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line">plt.scatter(X[:, <span class="number">0</span>], X[:, <span class="number">1</span>], c=y_kmean, s=<span class="number">50</span>, cmap=<span class="string">'viridis'</span>)</span><br><span class="line">plt.scatter(centroids[:, <span class="number">0</span>], centroids[:, <span class="number">1</span>], c=<span class="string">'black'</span>, s=<span class="number">100</span>, alpha=<span class="number">0.5</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></div><p><a href="/2020/03/25/kmeans/1.png" data-fancybox="group" data-caption class="fancybox"><img src="/2020/03/25/kmeans/1.png" alt title></a><br><a href="/2020/03/25/kmeans/2.png" data-fancybox="group" data-caption class="fancybox"><img src="/2020/03/25/kmeans/2.png" alt title></a></p><h1 id="手工实现"><a href="#手工实现" class="headerlink" title="手工实现"></a>手工实现</h1><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> make_blobs</span><br><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> sqrt</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> spatial</span><br><span class="line"></span><br><span class="line"><span class="comment">#产生数据</span></span><br><span class="line">k=<span class="number">4</span></span><br><span class="line">X,Y = make_blobs(n_samples=<span class="number">100</span>, n_features=<span class="number">2</span>, centers=k)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calcuDistance</span><span class="params">(vec1, vec2)</span>:</span></span><br><span class="line">    <span class="comment"># 步骤1：定义欧式距离的公式</span></span><br><span class="line">    <span class="comment"># 计算两个向量之间的欧式距离：根号下[(x_1-x_2)^2+(y_1-y_2)^2+...+(x_n-y_n)^2]</span></span><br><span class="line">    <span class="comment"># ver1 - ver2：表示两个向量的对应元素相减</span></span><br><span class="line">    <span class="keyword">return</span> np.sqrt(np.sum(np.square(vec1 - vec2)))  <span class="comment">#注意这里的减号</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">k_means</span><span class="params">(data,k,Y)</span>:</span></span><br><span class="line">    m, n = data.shape <span class="comment"># m：样本数量，n：每个样本的属性值个数</span></span><br><span class="line">    cores = data[np.random.choice(np.arange(m), k, replace=<span class="keyword">False</span>)] <span class="comment"># 从m个数据样本中不重复地随机选择k个样本作为质心</span></span><br><span class="line">    print(cores)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>: <span class="comment"># 迭代计算</span></span><br><span class="line">        <span class="comment">#d = np.square(np.repeat(data, k, axis=0).reshape(m, k, n) - cores)</span></span><br><span class="line">        <span class="comment">#distance = np.sqrt(np.sum(d, axis=2)) # ndarray(m, k)，每个样本距离k个质心的距离，共有m行</span></span><br><span class="line">        distance = spatial.distance.cdist(data, cores,metric=<span class="string">'euclidean'</span>)</span><br><span class="line">        index_min = np.argmin(distance, axis=<span class="number">1</span>) <span class="comment"># 每个样本距离最近的质心索引序号</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (index_min == Y).all(): <span class="comment"># 如果样本聚类没有改变</span></span><br><span class="line">            <span class="keyword">return</span> Y, cores <span class="comment"># 则返回聚类结果和质心数据</span></span><br><span class="line">        </span><br><span class="line">        Y[:] = index_min <span class="comment"># 重新分类</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(k): <span class="comment"># 遍历质心集</span></span><br><span class="line">            items = Y==i <span class="comment"># 找出对应当前质心的子样本集 ，对应的items为[True,false......]</span></span><br><span class="line">            cores[i] = np.mean(data[items], axis=<span class="number">0</span>) <span class="comment"># 以子样本集的均值作为当前质心的位置</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">result,cores=k_means(X,k,Y)</span><br><span class="line">plt.scatter(X[:, <span class="number">0</span>], X[:, <span class="number">1</span>], s=<span class="number">50</span>)</span><br><span class="line">plt.yticks(())</span><br><span class="line">plt.show()</span><br><span class="line">print(Y)</span><br><span class="line">plt.scatter(X[:, <span class="number">0</span>], X[:, <span class="number">1</span>], c=Y, s=<span class="number">50</span>, cmap=<span class="string">'viridis'</span>)</span><br><span class="line">plt.scatter(cores[:, <span class="number">0</span>], cores[:, <span class="number">1</span>], c=<span class="string">'black'</span>, s=<span class="number">100</span>, alpha=<span class="number">0.5</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></div><h1 id="k-means的改进"><a href="#k-means的改进" class="headerlink" title="k-means的改进"></a>k-means的改进</h1><p>k-means改进的一个路线就是尽可能加快收敛速度，这个方向有几个思路：<br>1.质心初始化：选择初始质心之间有一些策略比如尽量远离，有助于反应数据的分布，加快收敛。<br>2.改进k-means的迭代过程，有几个方向，一个改进复杂度，比如数据的访问用KD树来索引，一个是改进目标函数（原始目标函数就是使同一类的离质心距离最小），有一个思路是时刻更新质心，比如移动一个样本到最近的类别，就立刻更新相应的两个类质心，这样改变了每轮都要对所有样本更新label的繁琐过程。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="机器学习" scheme="https://sunxin18.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="K-means" scheme="https://sunxin18.github.io/tags/K-means/"/>
    
  </entry>
  
  <entry>
    <title>es</title>
    <link href="https://sunxin18.github.io/2020/03/23/es/"/>
    <id>https://sunxin18.github.io/2020/03/23/es/</id>
    <published>2020-03-23T12:29:56.000Z</published>
    <updated>2020-03-26T14:15:54.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>开启外网访问的方法：对elasticsearch.yml文件修改下面参数<br>transport.host: localhost<br>network.host: 192.168.3.5</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>list</title>
    <link href="https://sunxin18.github.io/2020/03/20/list/"/>
    <id>https://sunxin18.github.io/2020/03/20/list/</id>
    <published>2020-03-20T11:57:33.000Z</published>
    <updated>2020-04-09T08:25:58.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ol start="203"><li>移除链表元素<br>一道简单题卡了很久….太长时间不做链表果然忘记太多，下面总结一下几点错误</li><li>leetcode的链表都没有头节点，head指针直接指向第一个元素，所以如果想要删除第一个的元素的话需要自己建立一个头节点</li><li>开始代码写得是return head，如果第一个元素被删除了，那么head后面的指向就断掉了</li><li>最开始循环里是这么写的<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">if</span>(p-&gt;next-&gt;val==val)&#123;</span><br><span class="line">    p-&gt;next=p-&gt;next-&gt;next;</span><br><span class="line">    p=p-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li></ol><p>这样的话删除后就会跳过一个元素了。<br>下面代码，<br><strong>常规</strong><br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">NULL</span>)<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">         ListNode*q = <span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line">         q-&gt;next = head;</span><br><span class="line">        ListNode*p = q;</span><br><span class="line">        <span class="keyword">while</span>(p-&gt;next!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;next-&gt;val==val)</span><br><span class="line">                p-&gt;next=p-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p=p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> q-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></p><p><strong>递归</strong><br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        head-&gt;next = removeElements(head-&gt;next, val);</span><br><span class="line">        <span class="keyword">return</span> head-&gt;val == val ? head-&gt;next : head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="算法编程" scheme="https://sunxin18.github.io/categories/%E7%AE%97%E6%B3%95%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="链表" scheme="https://sunxin18.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>python编程(持续更新)</title>
    <link href="https://sunxin18.github.io/2020/03/14/python/"/>
    <id>https://sunxin18.github.io/2020/03/14/python/</id>
    <published>2020-03-14T02:53:38.000Z</published>
    <updated>2020-03-18T02:57:12.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://blog.csdn.net/ImwaterP/article/details/96282230" target="_blank" rel="noopener">https://blog.csdn.net/ImwaterP/article/details/96282230</a></p><h1 id="argmin"><a href="#argmin" class="headerlink" title="argmin"></a>argmin</h1><p>该函数主要用来检索数组中最小值的位置，并返回其下标值。同理，argmax()函数就是用来检索最大值的下标<br>在没有指定axis值的情况下，默认为None。在默认情况下，就相当于将n维的arry平铺在一起。举个简单的例子，当二维arry（[1,2,3],[4,5,6]）平铺开来就是（[1,2,3,4,5,6]）。<br>当axis = 1时，按照方向来，对于[2,5,6]来说最小值的下标是0，对于[7,6,1]来说最小值的下标是2。所以，最后输出的值就是[0,2]。<br>当axis = 0时，这时按照方向来，[2,7],[5,6],[6,1]分别在一个轴上，所以检索每个轴上的最小值，并返回下标，最后就可以得到输出值[0,0,1]。</p><h1 id="关于切片"><a href="#关于切片" class="headerlink" title="关于切片"></a>关于切片</h1><p>在list里面，只存在元素，不存在元素中的元素；list里元素就是最小的成分，不可以再切片。numpy 的array可以切片<br>例如<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a=np.array([[<span class="number">1</span>,<span class="number">5</span>],[<span class="number">2</span>,<span class="number">6</span>],[<span class="number">3</span>,<span class="number">7</span>]])</span><br><span class="line">print(a[<span class="number">2</span>]) print(a[<span class="number">2</span>,:])都可以</span><br><span class="line">a=[[<span class="number">1</span>,<span class="number">5</span>],[<span class="number">2</span>,<span class="number">6</span>],[<span class="number">3</span>,<span class="number">7</span>]]</span><br><span class="line">print(a[<span class="number">2</span>,:])会报错</span><br></pre></td></tr></table></figure></div></p><h1 id="scipy-spatial-distance-cdist"><a href="#scipy-spatial-distance-cdist" class="headerlink" title="scipy.spatial.distance.cdist"></a>scipy.spatial.distance.cdist</h1><p>该函数用于计算两个输入集合的距离，通过metric参数指定计算距离的不同方式得到不同的距离度量值<br><a href="https://blog.csdn.net/kancy110/article/details/75675574" target="_blank" rel="noopener">https://blog.csdn.net/kancy110/article/details/75675574</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="算法编程" scheme="https://sunxin18.github.io/categories/%E7%AE%97%E6%B3%95%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="pyton" scheme="https://sunxin18.github.io/tags/pyton/"/>
    
  </entry>
  
  <entry>
    <title>linux</title>
    <link href="https://sunxin18.github.io/2020/03/12/linux/"/>
    <id>https://sunxin18.github.io/2020/03/12/linux/</id>
    <published>2020-03-12T13:44:06.000Z</published>
    <updated>2020-05-02T13:22:36.779Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="共享文件夹there-no-need"><a href="#共享文件夹there-no-need" class="headerlink" title="共享文件夹there no need"></a>共享文件夹there no need</h1><p>现在本地建立一个文件夹，这里是F:\test然后点击设备–共享文件夹，勾选自动挂载，自动分配，<br>此处我选择在/mnt下创建一个“share”目录，将刚刚的“gongxiang”目录与“share”目录关联起来。<br>进入/mnt：<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd/mnt</span><br></pre></td></tr></table></figure></div></p><p>创建share目录：<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo makdir share</span><br></pre></td></tr></table></figure></div></p><p>将“test”目录与“share”目录进行关联：<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mount -t vboxsf test /mnt/share</span><br></pre></td></tr></table></figure></div></p><h1 id="报错对omp-getnum-threads未定义的引用"><a href="#报错对omp-getnum-threads未定义的引用" class="headerlink" title="报错对omp_getnum_threads未定义的引用"></a>报错对omp_getnum_threads未定义的引用</h1><p><a href="https://stackoverflow.com/questions/9685377/undefined-reference-to-omp-get-max-threads" target="_blank" rel="noopener">https://stackoverflow.com/questions/9685377/undefined-reference-to-omp-get-max-threads</a></p><p><a href="https://stackoverflow.com/questions/9685377/undefined-reference-to-omp-get-max-threads" target="_blank" rel="noopener">https://stackoverflow.com/questions/9685377/undefined-reference-to-omp-get-max-threads</a></p><p>#更改分辨率<br>先使用xrandr命令看下分辨率的索引<br>然后xrandr –size 0<em>0(这是800</em>800的)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="linux" scheme="https://sunxin18.github.io/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>say somethingto myself</title>
    <link href="https://sunxin18.github.io/2020/03/10/for-me/"/>
    <id>https://sunxin18.github.io/2020/03/10/for-me/</id>
    <published>2020-03-10T10:30:11.000Z</published>
    <updated>2020-03-10T12:02:58.000Z</updated>
    
    <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="哎呀你输错了！" data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">该文章已加密, 请输入密码查看。</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="4468f32117079e40bc33a8823841de91774a3f1f6688e975a1585ce5a6d730f2">38cd76bef1cf79f27267863aa0f1e10aff0a55b3032fb665653565d974dcbbb6fb9e335fcb6f2cac947609853f0c56f0dbf7300ebc6e47358c153341a4c18fe59abedea6571c7603dd0c3ebeb08faededad4174f6c6eeda32fe389116f16e28f0210187cfa4a272439508fc90658c1b2309a116992d303d700f05971b0e4855d4f4ff589cfc7838359191bd9ee6077a648cc1789b19943078668c653d9694c0c484aaaa3e126d8a153c6e91c689217e97fdcb7997cda884612bdc08273526ce2ae6489c37d097434752f4027a4af6877</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      Here&#39;s something encrypted, password is required to continue reading.
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>gragh_convolution</title>
    <link href="https://sunxin18.github.io/2020/03/08/gragh-convolution/"/>
    <id>https://sunxin18.github.io/2020/03/08/gragh-convolution/</id>
    <published>2020-03-08T01:57:31.000Z</published>
    <updated>2020-03-08T04:46:30.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="graghsage"><a href="#graghsage" class="headerlink" title="graghsage"></a>graghsage</h1><p>论文链接：<a href="https://arxiv.org/abs/1706.02216" target="_blank" rel="noopener">https://arxiv.org/abs/1706.02216</a></p><p>github链接：<a href="https://github.com/williamleif/GraphSAGE" target="_blank" rel="noopener">https://github.com/williamleif/GraphSAGE</a></p><p>官方介绍链接：<a href="http://snap.stanford.edu/graphsage/" target="_blank" rel="noopener">http://snap.stanford.edu/graphsage/</a></p><p>优秀介绍： <a href="https://blog.csdn.net/yyl424525/article/details/100532849?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">https://blog.csdn.net/yyl424525/article/details/100532849?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task</a></p><h2 id="gcn"><a href="#gcn" class="headerlink" title="gcn"></a>gcn</h2><p>现存的方法需要图中所有的顶点在训练embedding的时候都出现；这些前人的方法本质上是transductive，不能自然地泛化到未见过的顶点。<br><strong>GraphSAGE是为了学习一种节点表示方法，即如何通过从一个顶点的局部邻居采样并聚合顶点特征，而不是为每个顶点训练单独的embedding。</strong><br>GCN虽然能提取图中顶点的embedding，但是存在一些问题：</p><ol><li>GCN的基本思想： 把一个节点在图中的高纬度邻接信息降维到一个低维的向量表示。</li><li>GCN的优点： 可以捕捉graph的全局信息，从而很好地表示node的特征。</li><li>GCN的缺点： Transductive learning的方式，需要把所有节点都参与训练才能得到node embedding，无法快速得到新node的embedding。<br><strong>GCN等transductive的方法，学到的是每个节点的一个唯一确定的embedding； 而GraphSAGE方法学到的node embedding，是根据node的邻居关系的变化而变化的，也就是说，即使是旧的node，如果建立了一些新的link，那么其对应的embedding也会变化，而且也很方便地学到。</strong></li></ol><h1 id="算法概述"><a href="#算法概述" class="headerlink" title="算法概述"></a>算法概述</h1><p><a href="/2020/03/08/gragh-convolution/1.png" data-fancybox="group" data-caption class="fancybox"><img src="/2020/03/08/gragh-convolution/1.png" alt title></a><br>$K$:K是网络的层数，也代表着每个顶点能够聚合的邻接点的跳数，如K=2的时候每个顶点可以最多根据其2跳邻接点的信息学习其自身的embedding表示。每增加一层可以聚合更远节点的信息<br>$N_{(v)}$:GraphSAGE中每一层的节点邻居都是是从上一层网络采样的，并不是所有邻居参与，并且采样的后的邻居的size是固定的<br><a href="/2020/03/08/gragh-convolution/2.png" data-fancybox="group" data-caption class="fancybox"><img src="/2020/03/08/gragh-convolution/2.png" alt title></a><br>其运行流程如上图所示，可以分为三个步骤：</p><ol><li>对图中每个顶点邻居顶点进行采样，因为每个节点的度是不一致的，为了计算高效， 为每个节点采样固定数量的邻居</li><li>根据聚合函数聚合邻居顶点蕴含的信息</li><li>得到图中各顶点的向量表示供下游任务使用</li></ol><h2 id="Neighborhood-definition-采样邻居顶点"><a href="#Neighborhood-definition-采样邻居顶点" class="headerlink" title="Neighborhood definition - 采样邻居顶点"></a>Neighborhood definition - 采样邻居顶点</h2><p>出于对计算效率的考虑，对每个顶点采样一定数量的邻居顶点作为待聚合信息的顶点。设需要的邻居数量，即采样数量为SSS，若顶点邻居数少于SSS,则采用有放回的抽样方法，直到采样出SSS个顶点。若顶点邻居数大于SSS，则采用无放回的抽样。(<strong>即采用有放回的重采样/负采样方法达到SSS</strong>)</p><p>当然，若不考虑计算效率，完全可以对每个顶点利用其所有的邻居顶点进行信息聚合，这样是信息无损的。<br>文中在较大的数据集上实验。因此，统一采样一个固定大小的邻域集，以保持每个batch的计算占用空间是固定的（即 graphSAGE并不是使用全部的相邻节点，而是做了固定size的采样）。</p><p>这样固定size的采样，每个节点和采样后的邻居的个数都相同，可以把每个节点和它们的邻居拼成一个batch送到GPU中进行批训练。<br>论文里说<strong>固定长度的随机游走其实就是随机选择了固定数量的邻居</strong></p><h2 id="聚合函数的选取"><a href="#聚合函数的选取" class="headerlink" title="聚合函数的选取"></a>聚合函数的选取</h2><p>在图中顶点的邻居是无序的，所以希望构造出的聚合函数是对称的（即也就是对它输入的各种排列，函数的输出结果不变），同时具有较高的表达能力。 聚合函数的对称性（symmetry property）确保了神经网络模型可以被训练且可以应用于任意顺序的顶点邻居特征集合上。<br>主要有mean embedding，LSTM,pooling</p><h1 id="代码理解"><a href="#代码理解" class="headerlink" title="代码理解"></a>代码理解</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="图" scheme="https://sunxin18.github.io/categories/%E5%9B%BE/"/>
    
    
      <category term="graghsage" scheme="https://sunxin18.github.io/tags/graghsage/"/>
    
  </entry>
  
  <entry>
    <title>word2vec</title>
    <link href="https://sunxin18.github.io/2020/03/06/skipgram/"/>
    <id>https://sunxin18.github.io/2020/03/06/skipgram/</id>
    <published>2020-03-06T02:08:52.000Z</published>
    <updated>2020-03-26T12:33:26.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="自然语言模型的发展与引出"><a href="#自然语言模型的发展与引出" class="headerlink" title="自然语言模型的发展与引出"></a>自然语言模型的发展与引出</h1><p><a href="https://www.cnblogs.com/guoyaohua/p/9240336.html" target="_blank" rel="noopener">https://www.cnblogs.com/guoyaohua/p/9240336.html</a><br>基于频率或者预测模型：<a href="https://www.analyticsvidhya.com/blog/2017/06/word-embeddings-count-word2veec/" target="_blank" rel="noopener">https://www.analyticsvidhya.com/blog/2017/06/word-embeddings-count-word2veec/</a><br>语言模型会给一个正常的语句很高的概率<br>unigram:$$P(w_{1},w_{2}…w_{n})=\prod_{i=1}^{n}P(w_{i})$$<br>然而下一个词很大程度会取决于前面序列的词，这样独立概率会让一些愚蠢的语句也可以得到很大的值，所以引出了<br>Bigram model:$$P(w_{1},w_{2}…w_{n})=\prod_{i=2}^{n}P(w_{i}|w_{i-1})$$</p><h1 id="模型解析"><a href="#模型解析" class="headerlink" title="模型解析"></a>模型解析</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>语料(corpus)是指文本所有内容，包括重复的词，词典$D$是从语料中抽取出来的不包括重复词语<br>one-hot这种表示方式使得每一个词映射到高维空间中都是互相正交的，也就是说one-hot向量空间中词与词之间没有任何关联关系，这显然与实际情况不符合，因为实际中词与词之间有近义、反义等多种关系。Word2vec虽然学习不到反义这种高层次语义信息，但它巧妙的运用了一种思想：“具有相同上下文的词语包含相似的语义”，使得语义相近的词在映射到欧式空间后中具有较高的余弦相似度</p><p>其实总体思想还是降维，one-hot表达维度太大了，svd矩阵分解两个低纬度矩阵。</p><h2 id="权重矩阵"><a href="#权重矩阵" class="headerlink" title="权重矩阵"></a>权重矩阵</h2><p> <a href="https://blog.csdn.net/itplus/article/details/37969979" target="_blank" rel="noopener">https://blog.csdn.net/itplus/article/details/37969979</a><br>以skipgram为例主要有两个权重矩阵,第一个是中心词的向量表达矩阵$V$,第二个是上下文单词的向量表达矩阵$U$,他们都是$D\times V$维的<br>下面总结一下计算过程:<br>1.首先输入中心词$\omega_{t}$的one-hot编码($V\times 1$)<br>2.接着与矩阵$V$运算得到中心词的representation $v_{c}=\omega_{t}\cdot V$ ($D\times1$)<br>3.下一步就是中心词向量$v_{c}$与矩阵$U$相乘（$u_{0}^{T}v_{c}$,$u_{0}$就是矩阵$U$的某一行，其实这个就是即某个上下文词的one-hot的表达乘以$U$得到representation,$u_{0}^{T}v_{c}$这最后得到的就是$V\times 1$向量的一维)<br>可以听cs24n的视频讲解</p><ol start="4"><li>下面用softmax把相似性大小转变为概率<br><a href="/2020/03/06/skipgram/1.png" data-fancybox="group" data-caption class="fancybox"><img src="/2020/03/06/skipgram/1.png" alt title></a><br>详细的一个例子：<a href="https://cloud.tencent.com/developer/article/1591734" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1591734</a></li></ol><h2 id="输出层"><a href="#输出层" class="headerlink" title="输出层"></a>输出层</h2><p>对应一颗二叉树，词典中的词作为叶子节点，根据单词出现次数作为权值，构造huffman树，叶子节点一共$|D|$个,每一次分支都是二分类，分到左面是负类，右面是正类，<a href="https://blog.csdn.net/itplus/article/details/37969979" target="_blank" rel="noopener">详细过程</a>,<a href="https://www.cnblogs.com/neopenx/p/4571996.html" target="_blank" rel="noopener">https://www.cnblogs.com/neopenx/p/4571996.html</a></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><a href="https://github.com/chrisjmccormick/word2vec_commented" target="_blank" rel="noopener">源代码</a></p><p>#构造一个神经网络，输入词语，输出词向量<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn, optim</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment">#训练数据</span></span><br><span class="line"><span class="comment">#text = "I like dog i like cat i like animal dog cat animal apple cat dog like dog fish milk like dog \</span></span><br><span class="line"><span class="comment">#cat eyes like i like apple apple i hate apple i movie book music like cat dog hate cat dog like"</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'/content/text8'</span>) <span class="keyword">as</span> f: <span class="comment">#colab上的路径</span></span><br><span class="line">    text = f.read()</span><br><span class="line"></span><br><span class="line"><span class="comment">#参数设置</span></span><br><span class="line">EMBEDDING_DIM = <span class="number">2</span> <span class="comment">#词向量维度</span></span><br><span class="line">PRINT_EVERY = <span class="number">1000</span> <span class="comment">#可视化频率</span></span><br><span class="line">EPOCHS = <span class="number">3</span> <span class="comment">#训练的轮数</span></span><br><span class="line">BATCH_SIZE = <span class="number">5</span> <span class="comment">#每一批训练数据大小</span></span><br><span class="line">N_SAMPLES = <span class="number">3</span> <span class="comment">#负样本大小</span></span><br><span class="line">WINDOW_SIZE = <span class="number">5</span> <span class="comment">#周边词窗口大小</span></span><br><span class="line">FREQ = <span class="number">0</span> <span class="comment">#词汇出现频率</span></span><br><span class="line">DELETE_WORDS = <span class="keyword">False</span> <span class="comment">#是否删除部分高频词</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#文本预处理</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">preprocess</span><span class="params">(text, FREQ)</span>:</span></span><br><span class="line">    text = text.lower()</span><br><span class="line">    words = text.split()</span><br><span class="line">    <span class="comment">#去除低频词</span></span><br><span class="line">    word_counts = Counter(words)</span><br><span class="line">    trimmed_words = [word <span class="keyword">for</span> word <span class="keyword">in</span> words <span class="keyword">if</span> word_counts[word] &gt; FREQ]</span><br><span class="line">    <span class="keyword">return</span> trimmed_words</span><br><span class="line">words = preprocess(text, FREQ)</span><br><span class="line"></span><br><span class="line"><span class="comment">#构建词典</span></span><br><span class="line">vocab = set(words)</span><br><span class="line">vocab2int = &#123;w: c <span class="keyword">for</span> c, w <span class="keyword">in</span> enumerate(vocab)&#125;</span><br><span class="line">int2vocab = &#123;c: w <span class="keyword">for</span> c, w <span class="keyword">in</span> enumerate(vocab)&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#将文本转化为数值</span></span><br><span class="line">int_words = [vocab2int[w] <span class="keyword">for</span> w <span class="keyword">in</span> words]</span><br><span class="line"></span><br><span class="line"><span class="comment">#计算单词频次</span></span><br><span class="line">int_word_counts = Counter(int_words)</span><br><span class="line">total_count = len(int_words)</span><br><span class="line">word_freqs = &#123;w: c/total_count <span class="keyword">for</span> w, c <span class="keyword">in</span> int_word_counts.items()&#125;<span class="comment">#items()方法把字典中每对key和value组成一个元组，并把这些元组放在列表中返回。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#去除出现频次高的词汇</span></span><br><span class="line"><span class="keyword">if</span> DELETE_WORDS:</span><br><span class="line">    t = <span class="number">1e-5</span></span><br><span class="line">    prob_drop = &#123;w: <span class="number">1</span>-np.sqrt(t/word_freqs[w]) <span class="keyword">for</span> w <span class="keyword">in</span> int_word_counts&#125;</span><br><span class="line">    train_words = [w <span class="keyword">for</span> w <span class="keyword">in</span> int_words <span class="keyword">if</span> random.random()&lt;(<span class="number">1</span>-prob_drop[w])]</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    train_words = int_words</span><br><span class="line"></span><br><span class="line"><span class="comment">#单词分布</span></span><br><span class="line">word_freqs = np.array(list(word_freqs.values()))</span><br><span class="line">unigram_dist = word_freqs / word_freqs.sum()</span><br><span class="line">noise_dist = torch.from_numpy(unigram_dist ** (<span class="number">0.75</span>) / np.sum(unigram_dist ** (<span class="number">0.75</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment">#获取目标词汇</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_target</span><span class="params">(words, idx, WINDOW_SIZE)</span>:</span></span><br><span class="line">  target_window = np.random.randint(<span class="number">1</span>, WINDOW_SIZE+<span class="number">1</span>)</span><br><span class="line">  start_point = idx-target_window <span class="keyword">if</span> (idx-target_window)&gt;<span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">  end_point = idx+target_window</span><br><span class="line">  targets = set(words[start_point:idx]+words[idx+<span class="number">1</span>:end_point+<span class="number">1</span>])</span><br><span class="line">  <span class="keyword">return</span> list(targets)</span><br><span class="line"></span><br><span class="line"><span class="comment">#批次化数据</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_batch</span><span class="params">(words, BATCH_SIZE, WINDOW_SIZE)</span>:</span></span><br><span class="line">  n_batches = len(words)//BATCH_SIZE</span><br><span class="line">  words = words[:n_batches*BATCH_SIZE]</span><br><span class="line">  <span class="keyword">for</span> idx <span class="keyword">in</span> range(<span class="number">0</span>, len(words), BATCH_SIZE):</span><br><span class="line">    batch_x, batch_y = [],[]</span><br><span class="line">    batch = words[idx:idx+BATCH_SIZE]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(batch)):</span><br><span class="line">      x = batch[i]</span><br><span class="line">      y = get_target(batch, i, WINDOW_SIZE)</span><br><span class="line">      batch_x.extend([x]*len(y))</span><br><span class="line">      batch_y.extend(y)</span><br><span class="line">    <span class="keyword">yield</span> batch_x, batch_y</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义模型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SkipGramNeg</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, n_vocab, n_embed, noise_dist)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self.n_vocab = n_vocab</span><br><span class="line">        self.n_embed = n_embed</span><br><span class="line">        self.noise_dist = noise_dist</span><br><span class="line">        <span class="comment">#定义词向量层</span></span><br><span class="line">        self.in_embed = nn.Embedding(n_vocab, n_embed)</span><br><span class="line">        self.out_embed = nn.Embedding(n_vocab, n_embed)</span><br><span class="line">        <span class="comment">#词向量层参数初始化</span></span><br><span class="line">        self.in_embed.weight.data.uniform_(<span class="number">-1</span>, <span class="number">1</span>)</span><br><span class="line">        self.out_embed.weight.data.uniform_(<span class="number">-1</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="comment">#输入词的前向过程</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward_input</span><span class="params">(self, input_words)</span>:</span></span><br><span class="line">        input_vectors = self.in_embed(input_words)</span><br><span class="line">        <span class="keyword">return</span> input_vectors</span><br><span class="line">    <span class="comment">#目标词的前向过程</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward_output</span><span class="params">(self, output_words)</span>:</span></span><br><span class="line">        output_vectors = self.out_embed(output_words)</span><br><span class="line">        <span class="keyword">return</span> output_vectors</span><br><span class="line">    <span class="comment">#负样本词的前向过程</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward_noise</span><span class="params">(self, size, N_SAMPLES)</span>:</span></span><br><span class="line">        noise_dist = self.noise_dist</span><br><span class="line">        <span class="comment">#从词汇分布中采样负样本</span></span><br><span class="line">        noise_words = torch.multinomial(noise_dist,</span><br><span class="line">                                        size * N_SAMPLES,</span><br><span class="line">                                        replacement=<span class="keyword">True</span>)</span><br><span class="line">        noise_vectors = self.out_embed(noise_words).view(size, N_SAMPLES, self.n_embed)</span><br><span class="line">        <span class="keyword">return</span> noise_vectors</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义损失函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NegativeSamplingLoss</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, input_vectors, output_vectors, noise_vectors)</span>:</span></span><br><span class="line">        BATCH_SIZE, embed_size = input_vectors.shape</span><br><span class="line">        <span class="comment">#将输入词向量与目标词向量作维度转化处理</span></span><br><span class="line">        input_vectors = input_vectors.view(BATCH_SIZE, embed_size, <span class="number">1</span>)</span><br><span class="line">        output_vectors = output_vectors.view(BATCH_SIZE, <span class="number">1</span>, embed_size)</span><br><span class="line">        <span class="comment">#目标词损失</span></span><br><span class="line">        test = torch.bmm(output_vectors, input_vectors)</span><br><span class="line">        out_loss = torch.bmm(output_vectors, input_vectors).sigmoid().log()</span><br><span class="line">        out_loss = out_loss.squeeze()</span><br><span class="line">        <span class="comment">#负样本损失</span></span><br><span class="line">        noise_loss = torch.bmm(noise_vectors.neg(), input_vectors).sigmoid().log()</span><br><span class="line">        noise_loss = noise_loss.squeeze().sum(<span class="number">1</span>)</span><br><span class="line">        <span class="comment">#综合计算两类损失</span></span><br><span class="line">        <span class="keyword">return</span> -(out_loss + noise_loss).mean()</span><br><span class="line"></span><br><span class="line"><span class="comment">#模型、损失函数及优化器初始化</span></span><br><span class="line">model = SkipGramNeg(len(vocab2int), EMBEDDING_DIM, noise_dist=noise_dist)</span><br><span class="line">criterion = NegativeSamplingLoss()</span><br><span class="line">optimizer = optim.Adam(model.parameters(), lr=<span class="number">0.003</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#训练</span></span><br><span class="line">steps = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> e <span class="keyword">in</span> range(EPOCHS):</span><br><span class="line">    <span class="comment">#获取输入词以及目标词</span></span><br><span class="line">    <span class="keyword">for</span> input_words, target_words <span class="keyword">in</span> get_batch(train_words, BATCH_SIZE, WINDOW_SIZE):</span><br><span class="line">        steps += <span class="number">1</span></span><br><span class="line">        inputs, targets = torch.LongTensor(input_words), torch.LongTensor(target_words)</span><br><span class="line">        <span class="comment">#输入、输出以及负样本向量</span></span><br><span class="line">        input_vectors = model.forward_input(inputs)</span><br><span class="line">        output_vectors = model.forward_output(targets)</span><br><span class="line">        size, _ = input_vectors.shape</span><br><span class="line">        noise_vectors = model.forward_noise(size, N_SAMPLES)</span><br><span class="line">        <span class="comment">#计算损失</span></span><br><span class="line">        loss = criterion(input_vectors, output_vectors, noise_vectors)</span><br><span class="line">        <span class="comment">#打印损失</span></span><br><span class="line">        <span class="keyword">if</span> steps%PRINT_EVERY == <span class="number">0</span>:</span><br><span class="line">            print(<span class="string">"loss："</span>,loss)</span><br><span class="line">        <span class="comment">#梯度回传</span></span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line"></span><br><span class="line"><span class="comment">#可视化词向量</span></span><br><span class="line"><span class="keyword">for</span> i, w <span class="keyword">in</span> int2vocab.items() :</span><br><span class="line">    vectors = model.state_dict()[<span class="string">"in_embed.weight"</span>]</span><br><span class="line">    x,y = float(vectors[i][<span class="number">0</span>]),float(vectors[i][<span class="number">1</span>])</span><br><span class="line">    plt.scatter(x,y)</span><br><span class="line">    plt.annotate(w, xy=(x, y), xytext=(<span class="number">5</span>, <span class="number">2</span>), textcoords=<span class="string">'offset points'</span>, ha=<span class="string">'right'</span>, va=<span class="string">'bottom'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></div></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="NLP" scheme="https://sunxin18.github.io/categories/NLP/"/>
    
    
  </entry>
  
  <entry>
    <title>leetcode_day</title>
    <link href="https://sunxin18.github.io/2020/03/02/leetcode-day/"/>
    <id>https://sunxin18.github.io/2020/03/02/leetcode-day/</id>
    <published>2020-03-02T08:39:36.000Z</published>
    <updated>2020-03-03T11:39:36.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="3-1"><a href="#3-1" class="headerlink" title="3.1"></a>3.1</h2><h2 id="3-2-链表，迭代，递归"><a href="#3-2-链表，迭代，递归" class="headerlink" title="3.2(链表，迭代，递归)"></a>3.2(链表，迭代，递归)</h2><p>类似于头插法<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(head==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        ListNode* pre=<span class="literal">NULL</span>;</span><br><span class="line">        ListNode* cur=head;</span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">             ListNode* p=cur-&gt;next;</span><br><span class="line">            cur-&gt;next= pre;</span><br><span class="line">            pre=cur;</span><br><span class="line">            cur=p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></p><p>递归：关键就是理解p是反转后链表的表头<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>) <span class="keyword">return</span> head;</span><br><span class="line">        <span class="comment">// 如果当前要反转的节点为 null 或者反转链表为 null</span></span><br><span class="line">    <span class="comment">// head.next 为 null，即反转链表的尾结点不存在，即反转链表不存在</span></span><br><span class="line">        ListNode *p = reverseList(head-&gt;next);<span class="comment">// 节点 p 其实就是反转链表的头节点 </span></span><br><span class="line">        head-&gt;next-&gt;next = head;</span><br><span class="line">        head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></p><h2 id="3-3-数组，双指针"><a href="#3-3-数组，双指针" class="headerlink" title="3.3(数组，双指针)"></a>3.3(数组，双指针)</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; B, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=m<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> j=n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> index=m+n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&gt;=<span class="number">0</span>&amp;&amp;j&gt;=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(B[j]&gt;=A[i])</span><br><span class="line">                A[index--]=B[j--];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                A[index--]=A[i--];</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="keyword">while</span>(j &gt;= <span class="number">0</span>) A[index--] = B[j--];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>nlp</title>
    <link href="https://sunxin18.github.io/2020/02/28/nlp/"/>
    <id>https://sunxin18.github.io/2020/02/28/nlp/</id>
    <published>2020-02-28T12:58:44.000Z</published>
    <updated>2020-02-28T13:31:58.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="RNN"><a href="#RNN" class="headerlink" title="RNN"></a>RNN</h1><p>如果用标准神经网络来处理序列的话，因为词向量用one hot表示会有很大的维数，这是很庞大的输入层，第一层权重矩阵就会有很多参数<br>RNN公式：<br><a href="/2020/02/28/nlp/1.png" data-fancybox="group" data-caption class="fancybox"><img src="/2020/02/28/nlp/1.png" alt title></a><br><a href="/2020/02/28/nlp/2.png" data-fancybox="group" data-caption class="fancybox"><img src="/2020/02/28/nlp/2.png" alt title></a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="深度学习" scheme="https://sunxin18.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>论文整理</title>
    <link href="https://sunxin18.github.io/2020/02/25/paper1/"/>
    <id>https://sunxin18.github.io/2020/02/25/paper1/</id>
    <published>2020-02-25T11:06:26.000Z</published>
    <updated>2020-02-28T10:31:22.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>论文整理：</p><h1 id="truss："><a href="#truss：" class="headerlink" title="truss："></a>truss：</h1><h2 id="Efficient-Truss-Maintenance-in-Evolving-Networks-2014"><a href="#Efficient-Truss-Maintenance-in-Evolving-Networks-2014" class="headerlink" title="Efficient Truss Maintenance in Evolving Networks(2014)"></a>Efficient Truss Maintenance in Evolving Networks(2014)</h2><p>1证明了每次插入边后，truss最多加1<br>2.插入边后，受影响truss的范围</p><h2 id="Streaming-and-Batch-Algorithms-for-Truss-2019"><a href="#Streaming-and-Batch-Algorithms-for-Truss-2019" class="headerlink" title="Streaming and Batch Algorithms for Truss(2019)"></a>Streaming and Batch Algorithms for Truss(2019)</h2><ol><li>插入一条边后对不同k值边的更新不会互相影响。<br>Decomposition</li></ol><h1 id="core"><a href="#core" class="headerlink" title="core"></a>core</h1><h2 id="K-core-Minimization-An-Edge-Manipulation-Approach-2018"><a href="#K-core-Minimization-An-Edge-Manipulation-Approach-2018" class="headerlink" title="K-core Minimization: An Edge Manipulation Approach(2018)"></a>K-core Minimization: An Edge Manipulation Approach(2018)</h2><p>因为m条里选出b个组合复杂度过高，提出了两个greedy算法，第一个就是对k-core里的每条边删除计算followers，选出b个最优解。第二个算法是对候选集和的优化，只选择k-core图中两个顶点分别为k和大于k的边。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="truss" scheme="https://sunxin18.github.io/tags/truss/"/>
    
      <category term="core" scheme="https://sunxin18.github.io/tags/core/"/>
    
  </entry>
  
  <entry>
    <title>新冠状病毒预测</title>
    <link href="https://sunxin18.github.io/2020/02/25/virus/"/>
    <id>https://sunxin18.github.io/2020/02/25/virus/</id>
    <published>2020-02-25T07:07:31.000Z</published>
    <updated>2020-02-26T02:42:42.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>闲来无事，做一个确诊人数的预测吧，希望拐点早日降临。<br>首先数据就是日期和总确诊人数，走势是平缓到爆发到平缓，所以用logistics函数。总治愈目前处于上升趋势，多项式拟合吧。大体思路就是自变量特征从1到总的天数，然后把数字映射到日期，制图。<br>附上代码</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> scipy.optimize <span class="keyword">import</span> curve_fit</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">date_encode</span><span class="params">(date)</span>:</span></span><br><span class="line">    <span class="comment"># '01.24' -&gt; 1 * 100 + 24 = 124</span></span><br><span class="line">    d = date.split(<span class="string">'/'</span>)</span><br><span class="line">    <span class="keyword">return</span> int(d[<span class="number">1</span>]),int(d[<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">date_decode</span><span class="params">(date)</span>:</span></span><br><span class="line">    <span class="comment"># 124 -&gt; '01.24'</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'&#123;&#125;.&#123;&#125;'</span>.format(str(date // <span class="number">100</span>), str(date % <span class="number">100</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">df = pd.read_csv(<span class="string">'data.csv'</span>)<span class="comment">#encoding='utf-8',header=None,sep = '\t'</span></span><br><span class="line">df.drop([<span class="number">33</span>],inplace=<span class="keyword">True</span>)</span><br><span class="line">X = np.array(df.iloc[:,<span class="number">0</span>])    <span class="comment">#日期太多显示会重叠，前十天数据很平缓故先忽略掉</span></span><br><span class="line">cur_month,cur_day=date_encode(X[<span class="number">0</span>])</span><br><span class="line">y = np.array(df[<span class="string">'total_confirmed'</span>])</span><br><span class="line">z= np.array(df[<span class="string">'new_recoveries'</span>])</span><br><span class="line">x = np.arange(len(y))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_date_list</span><span class="params">(cur_month,cur_day,days,prediction=<span class="number">7</span>)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    得到原始数据和预测的日期</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    month_day = [<span class="number">0</span>, <span class="number">31</span>, <span class="number">29</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>]</span><br><span class="line">    ans = []</span><br><span class="line">    n=days+prediction</span><br><span class="line">    <span class="keyword">while</span> n:</span><br><span class="line">        <span class="keyword">if</span> cur_day &lt;= month_day[cur_month]:</span><br><span class="line">            d = <span class="string">"0"</span> + str(cur_day) <span class="keyword">if</span> cur_day &lt; <span class="number">10</span> <span class="keyword">else</span> str(cur_day)</span><br><span class="line">            ans += [str(cur_month) + <span class="string">"/"</span> + d]</span><br><span class="line">            cur_day += <span class="number">1</span></span><br><span class="line">            n=n<span class="number">-1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cur_day = <span class="number">1</span></span><br><span class="line">            cur_month += <span class="number">1</span></span><br><span class="line">            n=n<span class="number">-1</span></span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ans = get_date_list(cur_month,cur_day,len(y),prediction=<span class="number">7</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">logistic_function</span><span class="params">(t, K, P0, r)</span>:</span></span><br><span class="line">    r=<span class="number">0.27</span></span><br><span class="line">    t0 = <span class="number">0</span></span><br><span class="line">    exp = np.exp(r * (t - t0))</span><br><span class="line">    <span class="keyword">return</span> (K * exp * P0) / (K + (exp - <span class="number">1</span>) * P0)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f_3</span><span class="params">(x, A, B, C, D)</span>:</span>  </span><br><span class="line">    <span class="keyword">return</span> A*x*x*x + B*x*x + C*x + D</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">popt, pcov = curve_fit(logistic_function, x, y)</span><br><span class="line">popt1, pcov1 = curve_fit(f_3, x, z)</span><br><span class="line">predict_x = list(x)+[x[<span class="number">-1</span>] + i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">8</span>)] <span class="comment">#数组合并不能直接相加</span></span><br><span class="line">predict_x = np.array(predict_x)</span><br><span class="line">predict_y = logistic_function(predict_x, popt[<span class="number">0</span>], popt[<span class="number">1</span>], popt[<span class="number">2</span>])</span><br><span class="line">predict_y = [int(i) <span class="keyword">for</span> i <span class="keyword">in</span> predict_y]</span><br><span class="line">predict_z = f_3(predict_x, popt1[<span class="number">0</span>], popt1[<span class="number">1</span>], popt1[<span class="number">2</span>],popt1[<span class="number">3</span>])</span><br><span class="line">predict_z = [int(i) <span class="keyword">for</span> i <span class="keyword">in</span> predict_z]</span><br><span class="line"><span class="comment">#print(ans[-7:],predict_y[-7:])</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#输出新增确诊</span></span><br><span class="line">new_infected = [predict_y[i]-predict_y[i<span class="number">-1</span>] <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">-7</span>,<span class="number">0</span>)] </span><br><span class="line">print(ans[<span class="number">-7</span>:],new_infected)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#plt.scatter(x,y,color='purple',label='real')</span></span><br><span class="line"><span class="comment">#plt.plot(x,y,color='gray')</span></span><br><span class="line"><span class="comment">#plt.scatter(predict_x,predict_y,marker='x',color='red',label='predicted data')</span></span><br><span class="line"><span class="comment">#plt.xticks(predict_x,ans,rotation=90)</span></span><br><span class="line"><span class="comment">#plt.suptitle("Logistic Fitting Curve for 2019-nCov total infected numbers", fontsize=16, fontweight="bold")</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#输出新增治愈</span></span><br><span class="line">new_cured = [predict_z[i]-predict_z[i<span class="number">-1</span>] <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">-7</span>,<span class="number">0</span>)] </span><br><span class="line">print(ans[<span class="number">-7</span>:],new_cured)</span><br><span class="line"></span><br><span class="line">plt.scatter(x,z,color=<span class="string">'purple'</span>,label=<span class="string">'real'</span>)</span><br><span class="line">plt.plot(x,z,color=<span class="string">'gray'</span>)</span><br><span class="line">plt.scatter(predict_x,predict_z,marker=<span class="string">'x'</span>,color=<span class="string">'red'</span>,label=<span class="string">'predicted data'</span>)</span><br><span class="line">plt.xticks(predict_x,ans,rotation=<span class="number">90</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">plt.suptitle(<span class="string">"polynomial regression Fitting Curve for 2019-nCov total cured numbers"</span>, fontsize=<span class="number">16</span>, fontweight=<span class="string">"bold"</span>)</span><br><span class="line">plt.xlabel(<span class="string">'date'</span>, fontsize=<span class="number">14</span>)</span><br><span class="line">plt.ylabel(<span class="string">'infected number'</span>, fontsize=<span class="number">14</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></div><p>预测走势<br><a href="/2020/02/25/virus/1.png" data-fancybox="group" data-caption class="fancybox"><img src="/2020/02/25/virus/1.png" alt title></a><br>新增确诊人数：<br><a href="/2020/02/25/virus/2.png" data-fancybox="group" data-caption class="fancybox"><img src="/2020/02/25/virus/2.png" alt title></a><br>新增治愈趋势：<br><a href="/2020/02/25/virus/3.png" data-fancybox="group" data-caption class="fancybox"><img src="/2020/02/25/virus/3.png" alt title></a><br>新增治愈人数：<br><a href="/2020/02/25/virus/4.png" data-fancybox="group" data-caption class="fancybox"><img src="/2020/02/25/virus/4.png" alt title></a></p><h1 id="导出csv文件"><a href="#导出csv文件" class="headerlink" title="导出csv文件"></a>导出csv文件</h1><h2 id="导出文件，list作为列的方法："><a href="#导出文件，list作为列的方法：" class="headerlink" title="导出文件，list作为列的方法："></a>导出文件，list作为列的方法：</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="string">'2020/2/24'</span>, <span class="string">'2020/2/25'</span>, <span class="string">'2020/2/26'</span>, <span class="string">'2020/2/27'</span>, <span class="string">'2020/2/28'</span>, <span class="string">'2020/2/29'</span>, <span class="string">'2020/3/01'</span>]</span><br><span class="line">b = [<span class="number">307</span>, <span class="number">236</span>, <span class="number">181</span>, <span class="number">139</span>, <span class="number">106</span>, <span class="number">81</span>, <span class="number">63</span>]</span><br><span class="line">c = [<span class="number">2818</span>, <span class="number">3019</span>, <span class="number">3229</span>, <span class="number">3447</span>, <span class="number">3673</span>, <span class="number">3909</span>, <span class="number">4153</span>]</span><br><span class="line">data = &#123;<span class="string">'date'</span>:a,<span class="string">'new_confirmed'</span>:b,<span class="string">'new_recoveries'</span>:c&#125;</span><br><span class="line">dataframe = pd.DataFrame(data)</span><br><span class="line">dataframe.to_csv(<span class="string">r'D:\python\test.csv'</span>)</span><br></pre></td></tr></table></figure></div><p>结果<br><a href="/2020/02/25/virus/5.png" data-fancybox="group" data-caption class="fancybox"><img src="/2020/02/25/virus/5.png" alt title></a></p><h2 id="用list导入dataframe是list-行-行"><a href="#用list导入dataframe是list-行-行" class="headerlink" title="用list导入dataframe是list[[行],[行]]"></a>用list导入dataframe是list[[行],[行]]</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">list=[new_infected[i] <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">-7</span>,<span class="number">0</span>)]</span><br><span class="line">list1=[predict_z[i] <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">-7</span>,<span class="number">0</span>)]</span><br><span class="line">list.extend(list1)</span><br><span class="line">list=[list]</span><br><span class="line">column=[<span class="string">'confirmed_day1'</span>,<span class="string">'confirmed_day2'</span>,<span class="string">'confirmed_day3'</span>,<span class="string">'confirmed_day4'</span>,<span class="string">'confirmed_day5'</span>,<span class="string">'confirmed_day6'</span>,<span class="string">'confirmed_day7'</span>,<span class="string">'recovery_day1'</span>,<span class="string">'recovery_day2'</span>,<span class="string">'recovery_day3'</span>,<span class="string">'recovery_day4'</span>,<span class="string">'recovery_day5'</span>,<span class="string">'recovery_day6'</span>,<span class="string">'recovery_day7'</span>]  </span><br><span class="line">test=pd.DataFrame(columns=column,data=list,index=[<span class="string">'total'</span>])</span><br><span class="line">test.to_csv(<span class="string">'D:/test1.csv'</span>)</span><br></pre></td></tr></table></figure></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="机器学习" scheme="https://sunxin18.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="多项式回归" scheme="https://sunxin18.github.io/tags/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%9B%9E%E5%BD%92/"/>
    
      <category term="logistics" scheme="https://sunxin18.github.io/tags/logistics/"/>
    
  </entry>
  
  <entry>
    <title>leetcode1326</title>
    <link href="https://sunxin18.github.io/2020/02/21/leetcode1326/"/>
    <id>https://sunxin18.github.io/2020/02/21/leetcode1326/</id>
    <published>2020-02-21T12:26:26.000Z</published>
    <updated>2020-03-15T03:32:18.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ol start="91"><li>解码方式<br>首先分析几个特殊的情况，之后开始dp<br>dp[j]对应s[0]到s[i-1]的译码总数<br>如果s[i]=0,前一位只能是1或2，dp[j]=dp[j-2];<br>如果s[i-1]==’1’或者s[i-1]==’2’&amp;&amp;s[i]&lt;=’6’，这两种情况后两位可以合并或者分开译码s[i-1]和s[i]分开译码就是dp[j-1]，合并译码就是dp[j-2]<br>其他情况就是只能分开译码了</li></ol><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(s[<span class="number">0</span>]==<span class="string">'0'</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(s.length()==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> dp[s.size()+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>]=dp[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,j=<span class="number">2</span>;i&lt;s.size();i++,j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">'0'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i<span class="number">-1</span>]==<span class="string">'1'</span>||s[i<span class="number">-1</span>]==<span class="string">'2'</span>) dp[j]=dp[j<span class="number">-2</span>];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i<span class="number">-1</span>]==<span class="string">'1'</span>||s[i<span class="number">-1</span>]==<span class="string">'2'</span>&amp;&amp;s[i]&lt;=<span class="string">'6'</span>)</span><br><span class="line">                dp[j]=dp[j<span class="number">-1</span>]+dp[j<span class="number">-2</span>];</span><br><span class="line">            <span class="keyword">else</span>  </span><br><span class="line">                 dp[j]=dp[j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[s.size()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><ol start="343"><li>整数拆分<br>给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int integerBreak(int n) &#123;</span><br><span class="line">        vector&lt;int&gt;dp(n+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        dp[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(int i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="keyword">for</span>(int j=i<span class="number">-1</span>;j&gt;=<span class="number">1</span>;j--)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i]=max(dp[i],dp[j]*(i-j));</span><br><span class="line">                dp[i]=max(dp[i],j*(i-j));</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></li></ol><p>357.计算各个位数不同的数字个数<br><a href="/2020/02/21/leetcode1326/1.png" data-fancybox="group" data-caption class="fancybox"><img src="/2020/02/21/leetcode1326/1.png" alt title></a><br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int countNumbersWithUniqueDigits(int n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>;   //n=<span class="number">0</span>时，数组长度为<span class="number">1</span>，运行到dp[<span class="number">1</span>]会指向空地址</span><br><span class="line">        vector&lt;int&gt;dp(n+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>]=<span class="number">10</span>;</span><br><span class="line">        <span class="keyword">for</span>(int i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i]=dp[i<span class="number">-1</span>]+(dp[i<span class="number">-1</span>]-dp[i<span class="number">-2</span>])*(<span class="number">10</span>-(i<span class="number">-1</span>));  之前的解加上新增的i位数情况，i位数是由i<span class="number">-1</span>位数加上一位数，再加的一位数只有<span class="number">10</span>-(i<span class="number">-1</span>)种情况。</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></p><p>以n=3为例，n=2已经计算了0-99之间不重复的数字了，我们需要判断的是100-999之间不重复的数字，那也就只能用10-99之间的不重复的数去组成三位数，而不能使用0-9之间的不重复的数，因为他们也组成不了3位数。而10-99之间不重复的数等于dp[2]-dp[1]。<br>当i=2时，说明之前选取的数字只有1位，那么我们只要与这一位不重复即可，所以其实有9(10-1)种情况（比如1，后面可以跟0,2,3,4,5,6,7,8,9）。当i=3时，说明之前选取的数字有2位，那么我们需要与2位不重复，所以剩余的有8（10-2）种（比如12，后面可以跟0,3,4,5,6,7,8,9）</p><p>1326.灌溉花园的最少水龙头数目</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> dp[<span class="number">10001</span>];</span><br><span class="line">    <span class="keyword">int</span> INF= <span class="number">0x3f3f3f3f</span>;    <span class="comment">//定义为无穷大，意味着无法灌溉</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minTaps</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; ranges)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(dp,INF,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ranges.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> L = max(<span class="number">0</span>,i-ranges[i]);</span><br><span class="line">            <span class="keyword">int</span> R = min(n,i+ranges[i]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = L; j &lt;= R; j++)&#123;</span><br><span class="line">                dp[j] = min(dp[j],dp[L]+<span class="number">1</span>); <span class="comment">//</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n] == INF ? <span class="number">-1</span> : dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="算法编程" scheme="https://sunxin18.github.io/categories/%E7%AE%97%E6%B3%95%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="动态规划" scheme="https://sunxin18.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>面部识别</title>
    <link href="https://sunxin18.github.io/2020/02/20/face/"/>
    <id>https://sunxin18.github.io/2020/02/20/face/</id>
    <published>2020-02-20T03:07:34.000Z</published>
    <updated>2020-03-06T02:10:08.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="one-shot"><a href="#one-shot" class="headerlink" title="one shot"></a>one shot</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="计算机视觉" scheme="https://sunxin18.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    
  </entry>
  
</feed>

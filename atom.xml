<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>lalala</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://sunxin18.github.io/"/>
  <updated>2020-10-19T12:55:08.416Z</updated>
  <id>https://sunxin18.github.io/</id>
  
  <author>
    <name>Sunxin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>字符串+栈</title>
    <link href="https://sunxin18.github.io/2020/10/19/string-stack/"/>
    <id>https://sunxin18.github.io/2020/10/19/string-stack/</id>
    <published>2020-10-19T10:20:53.000Z</published>
    <updated>2020-10-19T12:55:08.416Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ol start="394"><li>字符串解码<br>相信会有人疑惑为什么官方视频例子里，s = “3[a2[c]]” 存的是[[2, a]而不是[2,c]呢？请看下面解答：<br>看完此题很容易就联想到栈，因为涉及到优先级最能层的括号先计算，其实这道题类似于分配率。<br>第一步是如何设计栈，有一个是数字代表重复次数，一个字符串代表要重复的字符串，很容易联想到用两个栈来存，分别存数字和字符串，存储进入’[‘前的状态（这里存的数字代表[]运算完后内部的字符串需要重复的次数，字符代表进入’[‘前需要存的字符。<br>接下来是怎么存？首先先用一个int num存储当前遍历的数，string res存储当前遍历到的字符串，当遇到’[‘的时候代表我们要先计算’[‘后的内容，当前计算得部分需要先存起来，当遇到’]‘时，将当前的res重复num次与栈最上层的字符串拼接，也就是进入当前’[‘时的状态,直到遍历结束，每遇到一次’[‘一次入栈，一次’]'一次出栈正好对应。</li></ol><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">decodeString</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="built_in">string</span>&gt; strs;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] &gt;= <span class="string">'0'</span> &amp;&amp; s[i] &lt;= <span class="string">'9'</span>)</span><br><span class="line">                num = num * <span class="number">10</span> + s[i] - <span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>((s[i] &gt;= <span class="string">'a'</span> &amp;&amp; s[i] &lt;= <span class="string">'z'</span>) ||(s[i] &gt;= <span class="string">'A'</span> &amp;&amp; s[i] &lt;= <span class="string">'Z'</span>))</span><br><span class="line">                res =  res + s[i];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i] == <span class="string">'['</span>)&#123;</span><br><span class="line">                nums.push(num);</span><br><span class="line">                strs.push(res);</span><br><span class="line">                res = <span class="string">""</span>;</span><br><span class="line">                num = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> cur = nums.top();</span><br><span class="line">                nums.pop();</span><br><span class="line">                <span class="built_in">string</span> cur_str ;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cur; i++)&#123;</span><br><span class="line">                    cur_str += res;</span><br><span class="line">                &#125;</span><br><span class="line">                res = strs.top() + cur_str;</span><br><span class="line">                strs.pop();</span><br><span class="line">            &#125;     </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="算法编程" scheme="https://sunxin18.github.io/categories/%E7%AE%97%E6%B3%95%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="字符串" scheme="https://sunxin18.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="栈" scheme="https://sunxin18.github.io/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>Effective STL 笔记</title>
    <link href="https://sunxin18.github.io/2020/10/03/effective-stl/"/>
    <id>https://sunxin18.github.io/2020/10/03/effective-stl/</id>
    <published>2020-10-03T02:23:07.000Z</published>
    <updated>2020-10-12T03:03:43.599Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ol><li><p>慎重选择容器类型</p></li><li><p>确保容器中的对象拷贝正确而高效<br>当(通过如insert或push_back之类的操作)向容器中加入对象时，存入容器的是你所指定的对象的拷贝。当(通过如front或back之类的操作)从容器中取出一个对象时，你所得到的是容器中所保存的对象的拷贝。进去的是拷贝，出来的也是拷贝(copy in, copy out)。这就是STL的工作方式。</p></li><li><p>调用empty而不是检查size()是否为0<br>empty对所有的标准容器都是常数时间操作，而对一些list实现，size耗费线性时间。</p></li><li><p>慎重选择删除元素的方法<br>删除vector中值为x的元素</p></li></ol><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; c1;</span><br><span class="line">c1.erase(<span class="built_in">std</span>::remove(c1.begin(), c1.end(), <span class="number">1963</span>), c1.end()); <span class="comment">// 当c1是vector, string或deque时，erase-remove习惯用法是删除特定值的元素的最好办法</span></span><br><span class="line"><span class="comment">//这句的意思是，取得"1963"的位置（位于结尾），然后删除"be"到原vector结尾的所有元素</span></span><br></pre></td></tr></table></figure></div><p>对于list</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; c2;</span><br><span class="line">c2.remove(<span class="number">1963</span>); <span class="comment">// 当c2是list时，remove成员函数是删除特定值的元素的最好办法</span></span><br></pre></td></tr></table></figure></div><p>当c是标准关联容器，<strong>使用任何名为remove的操作都是完全错误的</strong>。这样的容器没有名为remove的函数<br>对于关联容器</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; c3;</span><br><span class="line">c3.erase(<span class="number">1963</span>); <span class="comment">// 当c3是标准关联容器时，erase成员函数是删除特定值元素的最好办法</span></span><br></pre></td></tr></table></figure></div><p>如果要在循环中操作，总结如下：</p><ol><li>如果容器是一个标准序列容器，则写一个循环来遍历容器中的元素，记住每次调用erase时，要用它的返回值更新迭代器；</li></ol><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::ofstream logFile;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator i = c1.begin(); i != c1.end();) &#123;</span><br><span class="line"><span class="keyword">if</span> (badValue(*i)) &#123;</span><br><span class="line">logFile &lt;&lt; <span class="string">"Erasing "</span> &lt;&lt; *i &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">i = c1.erase(i); <span class="comment">// 把erase的返回值赋给i，使i的值保持有效</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> ++i;</span><br></pre></td></tr></table></figure></div><p>因为对于这类容器，调用erase会使被删除元素和他之后的所有迭代器失效，而erase的返回值正是我们所需要的，一旦erase完成，它的返回值是指向被删除元素的下一个元素的有效迭代器。</p><ol start="2"><li>如果容器是一个标准关联容器，则写一个循环来遍历容器中的元素，记住当把迭代器传给erase时，要对迭代器做后缀递增。</li></ol><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::ofstream logFile;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator i = c3.begin(); i != c3.end();) &#123;</span><br><span class="line"><span class="keyword">if</span> (badValue(*i)) &#123;</span><br><span class="line">logFile &lt;&lt; <span class="string">"Erasing "</span> &lt;&lt; *i &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// 写日志文件</span></span><br><span class="line">c3.erase(i++); <span class="comment">// 对坏值，把当前的i传给erase，递增i是副作用</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> ++i;              <span class="comment">// 对好值，则简单第递增i</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>因为对于这类容器，调用erase会使被删除元素的所有迭代器失效，<s>而对于关联容器，erase的返回值是void</s>(c<ins>11也返回下一个位置的迭代器啦)。我们采用后缀递增的技术。我们要确保在调用erase之前，有一个迭代器指向容器中的下一个元素。我们采用了c3.erase(i</ins>)，这个过程可以分为三个部分(<a href="https://blog.csdn.net/yousss/article/details/80077758" target="_blank" rel="noopener">https://blog.csdn.net/yousss/article/details/80077758</a>)<br>1、先把i的值赋值给一个临时变量做为传递给erase的参数变量</p><p>2、因为参数处理优先于函数调用，所以接下来执行了i++操作，也就是i现在已经指向了下一个地址。</p><p>3、再调用erase函数，释放掉第一步中保存的要删除的it的值的临时变量所指的位置。</p><ol start="14"><li>使用reserve来避免不必要的重新分配</li></ol><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">v.reserve(<span class="number">1000</span>); <span class="comment">// 如果不使用reserve,下面的循环在进行过程中将导致2到10次重新分配;加上reserve，则在循环过程中,将不会再发生重新分配</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">1000</span>; ++i) </span><br><span class="line">v.push_back(i);</span><br></pre></td></tr></table></figure></div><ul><li><p>对于vector和string，增长过程是这样来实现的：每当需要更多空间时，就调用与realloc类似的操作。这一类似于realloc的操作分为四部分：(1).分配一块大小为当前容量的某个倍数的新内存。在大多数实现中，vector和string的容量每次以2的倍数增长，即，每当容器需要扩张时，它们的容量即加倍。<br>(2).把容器的所有元素从旧的内存拷贝到新的内存中。<br>(3).析构掉就内存中的对象。<br>(4).释放旧内存。</p></li><li><p>resize()函数（强迫容器改变到n个元素的状态）：<br>-如果 n &lt; size 容器末尾的元素被析构<br>-如果 n &gt; size 通过默认构造函数创建的新元素将被添加到容器的末尾<br>-如果 n &gt; capacity 则在添加元素前，将重新分配</p></li><li><p>reserve函数（强迫容器把它的容量至少变为n）：<br>如果 n &lt; capacity 忽略操作</p></li><li><p>reserve成员函数能使你把重新分配的次数减少到最低限度，从而避免了重新分配和指针/迭代器/引用失效带来的开销。避免重新分配的关键在于，尽早地使用reserve，把容器的容量设为足够大的值，最好是在容器刚被构造出来之后就使用reserve。</p></li><li><p>大小(size)和容量(capacity)的关系使我们能够预知什么时候插入操作会导致vector或string执行重新分配动作，进而使我们有可能预知一个插入操作什么时候会使容器中的迭代器、指针和引用失效。</p></li></ul><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s</span><br><span class="line"><span class="keyword">if</span>(s.size() &lt; s.capacity())&#123;</span><br><span class="line">s.push_back(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><ul><li>通常有两种方式来使用reserve以避免不必要的重新分配。第一种方式是，若能确切知道或大致预计容器中最终会有多少元素，则此时可以使用reserve。第二种方式是，先预留足够大的空间(根据你的需要而定)，然后，当把所有数据都加入以后，再去除多余的容量。</li></ul><ol start="15"><li><p>注意string实现的多样性<br>(1).string的值可能会被引用计数，也可能不会。很多实现在默认情况下会使用引用计数，但它们通常提供了关闭默认选择的方法，往往是通过预处理宏来做到这一点。<br>(2).string对象大小的范围可以是一个char* 指针大小的1倍到7倍。<br>(3).创建一个新的字符串值可能需要零次、一次或两次动态分配内存。<br>(4).string对象可能共享，也可能不共享其大小和容量信息。<br>(5).string可能支持，也可能不支持针对单个对象的分配子。<br>(6).不同的实现对字符内存的最小分配单位有不同的策略。</p></li><li><p>了解如何把vector和string数据传给旧的API</p></li></ol><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="keyword">if</span> (!v.empty()) &#123;</span><br><span class="line">doSomething(&amp;v[<span class="number">0</span>], v.size());</span><br><span class="line"><span class="comment">// doSomething(v.begin(), v.size()); // 错误的用法</span></span><br><span class="line">doSomething(&amp;*v.begin(), v.size()); <span class="comment">// 可以，但不易于理解</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>C++标准要求vector中的元素存储在连续的内存中，就像数组一样。string中的数据不一定存储在连续的内存中，而且string的内部表示不一定是以空字符结尾的。</p><ol start="17"><li>使用”swap技巧”除去多余的容量</li></ol><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Contestant&gt; contestants;</span><br><span class="line"><span class="comment">// ... // 让contestants变大，然后删除它的大部分元素</span></span><br><span class="line"><span class="comment">// vector&lt;Contestant&gt;(contestants)创建一个临时矢量，vector的拷贝构造函数只为所拷贝的元素分配所需要的内存</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Contestant&gt;(contestants).swap(contestants);</span><br><span class="line"> </span><br><span class="line">contestants.shrink_to_fit(); <span class="comment">// C++11</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> s;</span><br><span class="line"><span class="comment">// ... // 让s变大，然后删除它的大部分字符</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span>(s).swap(s);</span><br><span class="line"> </span><br><span class="line">s.shrink_to_fit(); <span class="comment">// C++11</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Contestant&gt;().swap(contestants); <span class="comment">// 清除contestants并把它的容量变为最小</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span>().swap(s); <span class="comment">// 清除s并把它的容量变为最小</span></span><br></pre></td></tr></table></figure></div><ol start="18"><li><p>避免使用vector<bool><br>作为一个STL容器，vector<bool>只有两点不对。首先，它不是一个STL容器；其次，它并不存储bool。除此以外，一切正常。</bool></bool></p></li><li><p>理解相等(equality)和等价(equivalence)的区别<br>相等的概念是基于operator==的。等价关系是以”在已排序的区间中对象值的相对顺序”为基础的。标准关联容器是基于等价而不是相等。</p></li></ol><p>标准关联容器总是保持排列顺序的，所以每个容器必须有一个比较函数(默认为less)来决定保持怎样的顺序。等价的定义正是通过该比较函数而确定的，因此，标准关联容器的使用者要为所使用的每个容器指定一个比较函数(用来决定如何排序)。如果该关联容器使用相等来决定两个对象是否有相同的值，那么每个关联容器除了用于排序的比较函数外，还需要另一个比较函数来决定两个值是否相等。(默认情况下，该比较函数应该是equal_to，但equal_to从来没有被用作STL的默认比较函数。当STL中需要相等判断时，一般的惯例是直接调用operator==)。</p><p>C++标准对于等价的值(对multiset)或键(对multimap)的相对顺序没有什么限制。</p><ol start="20"><li>为包含指针的关联容器指定比较类型<br>每当你要创建包含指针的关联容器时，一定要记住，容器将会按照指针的值进行排序。绝大多数情况下，这不会是你所希望的，所以你几乎肯定要创建自己的函数子类作为该容器的比较类型(comparison type)。<br>比如：</li></ol><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>*&gt;ssp;</span><br><span class="line">ssp.insert(<span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">"Anteater"</span>));</span><br><span class="line">ssp.insert(<span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">"Wombat"</span>));</span><br><span class="line">ssp.insert(<span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">"Lemur"</span>));</span><br><span class="line">ssp.insert(<span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">"Penguin"</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">set</span>&lt;<span class="built_in">string</span>*&gt;::const_iterator i = ssp.begin(); i != ssp.end(); ++i)</span><br><span class="line">&#123;</span><br><span class="line">count &lt;&lt; *i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>然而这个打印出来的不会是字符串，而是4个十六进制数—他们是指针的值。<br>即使我们改成</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">count &lt;&lt; **i &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></div><p>这个打印出来不是我们期待的首字母排序的那样,因为ssp会按指针的值排序。<br>为了解决这个问题，请记住</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span>&lt;<span class="built_in">string</span>*&gt; ssp;</span><br></pre></td></tr></table></figure></div><p>是如下代码的缩写</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span>&lt;<span class="built_in">string</span>*, less&lt;<span class="built_in">string</span>*&gt;, allpcator&lt;<span class="built_in">string</span>*&gt; ssp;</span><br></pre></td></tr></table></figure></div><p>分配子与当前问题无关，所以不考虑。</p><p><em>那么如何创建函数子类？</em><br>最直观的是写一个比较函数，比如：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">stringPtrLess</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>* ps1, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>* ps2)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> *ps1 &lt; *ps2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="built_in">string</span>, stringPtrLess&gt;</span><br></pre></td></tr></table></figure></div><p>但是这样无法通过编译，<strong>stringPtrLess不是一个类型</strong>，所以我们需要创建一个类，并在内部为它创建一个函数，如下就可以啦</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DereferenceLess</span> &#123;</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> PtrType&gt;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(PtrType pT1, PtrType pT2)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> *pT1 &lt; *pT2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>*, DereferenceLess&gt; ssp; <span class="comment">// 与std::set&lt;std::string*, StringPtrLess&gt; ssp;的行为相同</span></span><br></pre></td></tr></table></figure></div><p>如果你有一个包含智能指针或迭代器的容器，那么你也要考虑为它指定一个比较类型。对指针的解决方案同样也适用于那些类似指针的对象。就像DereferenceLess适合作为包含<code>T*</code>的关联容器的比较类型一样，对于容器中包含了指向T对象的迭代器或智能指针的情形，DereferenceLess也同样可用作比较类型。</p><ol start="21"><li><p>总是让比较函数在等值情况下返回false</p></li><li><p>切勿直接修改set或multiset中的键<br>对于map和multimap尤其简单，因为如果有程序试图改变这些容器中的键，它将不能通过编译。这是因为，对于一个map&lt;K, V&gt;或multimap&lt;K, V&gt;类型的对象，其中的元素类型是pair&lt;const K, V&gt;。因为键的类型是const K，所以它不能被修改。(如果利用const_cast，你或许可以修改它。)</p></li><li><p>考虑用排序的vector替代关联容器<br>对于许多应用，哈希容器可能提供常数时间的查找能力优于set、multiset、map和multimap的确定的对数时间查找能力。</p></li></ol><p>比如我们需要一个容器来存储Widget对象，如果我们用关联容器，则每个节点不仅包含了一个Widget，而且还包含了几个指针：一个指向左儿子，另一个指向右儿子，通常还有一个指向它的父节点，至少3个指针。</p><p>在排序的vector中可能在标准关联容器中存储同样的数据耗费更少的内存，考虑到页面错误的因素，通过二分搜索法查找一个排序的vector可能比查找一个标准关联容器更快一些。</p><p><strong>查找操作几乎从不跟插入和删除操作混在一起时，再考虑使用排序的vector而不是关联容器才是合理的</strong>。否则，使用排序的vector而不是标准关联容器几乎肯定是在浪费时间。</p><ol start="24"><li>当效率至关重要时，请在map::operator[]与map::insert之间谨慎做出选择<br>map的operator[]函数与众不同。它与vector、deque和string的operator[]函数无关，与用于数组的内置operator[]也没有关系。相反，map::operator[]的设计目的是为了提供”添加和更新”(add or update)的功能。map::operator[]返回一个引用。</li></ol><p><strong>对效率的考虑使我们得出结论：当向映射表中添加元素时，要优先选用insert，而不是operator[]；而从效率和美学的观点考虑，结论是：当更新已经在映射表中的元素的值时，要优先选择operator[]。</strong></p><ol start="25"><li></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://sunxin18.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="STL" scheme="https://sunxin18.github.io/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>DFS 困难问题合集</title>
    <link href="https://sunxin18.github.io/2020/09/19/DFS-hard/"/>
    <id>https://sunxin18.github.io/2020/09/19/DFS-hard/</id>
    <published>2020-09-19T10:53:00.000Z</published>
    <updated>2020-09-29T02:27:41.583Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ol start="37"><li>解数独<br>用col, row, block来分别表示每一列/行/块是否有数i，先对所以可填入的位置做一个登记，存入board容器，如果有一层dfs可以填满所以空位置就可以return<br>，valid这里也可以用来提前结束</li></ol><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">bool</span> col[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line">    <span class="keyword">bool</span> row[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line">    <span class="keyword">bool</span> block[<span class="number">3</span>][<span class="number">3</span>][<span class="number">9</span>];</span><br><span class="line">    <span class="keyword">bool</span> valid;</span><br><span class="line">    <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt;spaces;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pos == spaces.size())&#123;</span><br><span class="line">            valid = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i = spaces[pos].first;</span><br><span class="line">        <span class="keyword">int</span> j = spaces[pos].second;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> t = <span class="number">1</span>;t &lt;= <span class="number">9</span>; t++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!row[i][t - <span class="number">1</span>] &amp;&amp; !col[j][t - <span class="number">1</span>] &amp;&amp; !block[i/<span class="number">3</span>][j/<span class="number">3</span>][t<span class="number">-1</span>] &amp;&amp; !valid)&#123;</span><br><span class="line">                board[i][j] = t + <span class="string">'0'</span>;</span><br><span class="line">                row[i][t - <span class="number">1</span>] =  col[j][t - <span class="number">1</span>] = block[i/<span class="number">3</span>][j/<span class="number">3</span>][t<span class="number">-1</span>] = <span class="literal">true</span>;</span><br><span class="line">                dfs(board , pos + <span class="number">1</span>);</span><br><span class="line">                row[i][t - <span class="number">1</span>] =  col[j][t - <span class="number">1</span>] = block[i/<span class="number">3</span>][j/<span class="number">3</span>][t<span class="number">-1</span>] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solveSudoku</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(col, <span class="literal">false</span>, <span class="keyword">sizeof</span>(col));</span><br><span class="line">        <span class="built_in">memset</span>(col, <span class="literal">false</span>, <span class="keyword">sizeof</span>(row));</span><br><span class="line">        <span class="built_in">memset</span>(col, <span class="literal">false</span>, <span class="keyword">sizeof</span>(block));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] == <span class="string">'.'</span>)&#123;</span><br><span class="line">                    <span class="keyword">auto</span> p = make_pair(i, j);</span><br><span class="line">                    spaces.push_back(p);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    row[i][board[i][j] - <span class="string">'0'</span> - <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">                    col[j][board[i][j] - <span class="string">'0'</span> - <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">                    block[i/<span class="number">3</span>][j/<span class="number">3</span>][board[i][j] - <span class="string">'0'</span> - <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(board, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><ol start="47"><li>全排列 II<br>这道题是一道中等难度题，但这里也放到了困难，这道题对理解递归过程很好。<br>最简单的思想就是先排列出所有可能的组合，再进行去重，但这复杂度很高，很多递归分支是没有必要的。比如我们开始搜索到第i个位置，有两个重复的1，在这里选这两个1的效果是一样的就可以剪枝，所以对于重复的数我们只选择一次，这个通过先对数组排序再进行判断后一个和前面的相等就可以跳过即可.<br>我们还要标记一下使用过得元素防止重复使用</li></ol><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;res;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cur, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; used)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur.size() == nums.size())&#123;</span><br><span class="line">            res.push_back(cur);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; used[i - <span class="number">1</span>] == <span class="number">0</span>)&#123;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(used[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                used[i] = <span class="number">1</span>;</span><br><span class="line">                cur.push_back(nums[i]);</span><br><span class="line">                dfs(cur, nums, used);</span><br><span class="line">                cur.pop_back();</span><br><span class="line">                used[i] = <span class="number">0</span>;</span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; permuteUnique(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; used(n);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;cur;</span><br><span class="line">        dfs(cur, nums, used);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="DFS" scheme="https://sunxin18.github.io/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>二叉树专题</title>
    <link href="https://sunxin18.github.io/2020/07/29/binary-tree/"/>
    <id>https://sunxin18.github.io/2020/07/29/binary-tree/</id>
    <published>2020-07-29T12:43:30.000Z</published>
    <updated>2020-10-23T08:53:00.992Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ol start="236"><li>二叉树的最近公共祖先</li></ol><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TreeNode* ans;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">bool</span> lson = dfs(root-&gt;left, p, q);</span><br><span class="line">        <span class="keyword">bool</span> rson = dfs(root-&gt;right, p, q);</span><br><span class="line">        <span class="keyword">if</span> ((lson &amp;&amp; rson) || ((root-&gt;val == p-&gt;val || root-&gt;val == q-&gt;val) &amp;&amp; (lson || rson))) &#123;</span><br><span class="line">            ans = root;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> lson || rson || (root-&gt;val == p-&gt;val || root-&gt;val == q-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        dfs(root, p, q);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><ol start="114"><li><p>二叉树展开为链表</p></li><li><p>将左子树插入到右子树的地方</p></li><li><p>将原来的右子树接到左子树的最右边节点</p></li><li><p>考虑新的右子树的根节点，一直重复上边的过程，直到新的右子树为 null</p></li></ol><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        TreeNode* pre=root;</span><br><span class="line">        <span class="keyword">while</span>(root!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            pre=root-&gt;left;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;left!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(pre-&gt;right!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                pre=pre-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            pre-&gt;right=root-&gt;right;</span><br><span class="line">            root-&gt;right=root-&gt;left;</span><br><span class="line">            root-&gt;left=<span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        root=root-&gt;right;</span><br><span class="line">      &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><ol start="501"><li>二叉搜索树中的众数<br>第一种方法就是遍历一遍吧每个数出现的次数记录一下，然后换到vector来排序一下</li></ol><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">searchBST</span><span class="params">(TreeNode* cur, <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&amp; <span class="built_in">map</span>)</span> </span>&#123; <span class="comment">// 前序遍历</span></span><br><span class="line">    <span class="keyword">if</span> (cur == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">map</span>[cur-&gt;val]++; <span class="comment">// 统计元素频率</span></span><br><span class="line">    searchBST(cur-&gt;left, <span class="built_in">map</span>);</span><br><span class="line">    searchBST(cur-&gt;right, <span class="built_in">map</span>);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="keyword">static</span> <span class="title">cmp</span> <span class="params">(<span class="keyword">const</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&amp; a, <span class="keyword">const</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.second &gt; b.second;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findMode(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> result;</span><br><span class="line">        searchBST(root, <span class="built_in">map</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; vec(<span class="built_in">map</span>.begin(), <span class="built_in">map</span>.end());</span><br><span class="line">        sort(vec.begin(), vec.end(), cmp); <span class="comment">// 给频率排个序</span></span><br><span class="line">        result.push_back(vec[<span class="number">0</span>].first);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; vec.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (vec[i].second == vec[<span class="number">0</span>].second) result.push_back(vec[i].first);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><p>上面的代码可以优化，省掉闯创建vec和对vec排序的过程（上面这个主要是为了展示怎么对pair写排序），就是存储map的时候，同时记录最大值max，然后遍历map找到所有value为max的key就好了</p><p>再进一步优化空间就是采用递归充分利用二叉搜索树的性质，</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;res;</span><br><span class="line">    <span class="keyword">int</span> imax = <span class="number">0</span>,count = <span class="number">0</span>;</span><br><span class="line">    TreeNode* pre;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* cur)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="literal">NULL</span>)<span class="keyword">return</span>;</span><br><span class="line">        dfs(cur-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(pre == <span class="literal">NULL</span>)&#123; </span><br><span class="line">            count = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pre-&gt;val == cur-&gt;val)&#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            count = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(count == imax)</span><br><span class="line">                res.push_back(cur-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>(count &gt; imax)&#123;</span><br><span class="line">            res.clear();</span><br><span class="line">            res.push_back(cur-&gt;val);</span><br><span class="line">            imax = count;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = cur;</span><br><span class="line">        dfs(cur-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findMode(TreeNode* root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)<span class="keyword">return</span> res;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="二叉树" scheme="https://sunxin18.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>job</title>
    <link href="https://sunxin18.github.io/2020/07/29/job/"/>
    <id>https://sunxin18.github.io/2020/07/29/job/</id>
    <published>2020-07-29T10:28:28.000Z</published>
    <updated>2020-10-23T12:09:36.808Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ol><li>常数时间求栈的最大值:<a href="https://blog.csdn.net/taotaotheripper/article/details/8652665" target="_blank" rel="noopener">https://blog.csdn.net/taotaotheripper/article/details/8652665</a><br>一个存储所有最大值的栈Sm。<br>1.当push入栈的元素大于当前最大元素，将该元素压入最大值栈Sm；</li></ol><p>2.Sm栈顶始终保存栈中当前的最大元素；</p><p>3.当前最大元素被pop出栈时，将Sm栈顶的对应最大元素也弹出栈。</p><p>max操作即为获得Sm栈顶最大元素。</p><ol start="2"><li>请你说说C++如何处理返回值？<br>生成一个临时变量，把它的引用作为函数参数传入函数内。</li></ol><p>2、迭代器和指针的区别</p><p>迭代器不是指针，是类模板，表现的像指针。他只是模拟了指针的一些功能，通过重载了指针的一些操作符，-&gt;、、<ins>、–等。迭代器封装了指针，是一个“可遍历STL（ Standard Template Library）容器内全部或部分元素”的对象， 本质是封装了原生指针，是指针概念的一种提升（lift），提供了比指针更高级的行为，相当于一种智能指针，他可以根据不同类型的数据结构来实现不同的</ins>，–等操作。</p><ol start="3"><li><p>什么是多态？怎么实现的呢？(<a href="https://www.cnblogs.com/Duikerdd/p/11761124.html" target="_blank" rel="noopener">https://www.cnblogs.com/Duikerdd/p/11761124.html</a>)<br>在面向对象开发中，多态是一个很重要的特性。<br>什么是多态呢？就是程序运行时，父类指针可以根据具体指向的子类对象，来执行不同的函数，表现为多态。<br><strong>实现原理</strong><br>1、当类中存在虚函数时，编译器会在类中自动生成一个虚函数表<br>2、虚函数表是一个存储类成员函数指针的数据结构<br>3、虚函数表由编译器自动生成和维护<br>4、virtual 修饰的成员函数会被编译器放入虚函数表中<br>5、存在虚函数时，编译器会为对象自动生成一个指向虚函数表的指针（通常称之为 vptr 指针）</p></li><li><p>构造函数是不能为虚函数的，为什么呢？<br>我们知道，调用构造函数后，才能生成一个对象。 现在假设构造函数是虚函数，那么它存在于虚函数表中， 而去找虚函数表又需要虚函数指针， 而虚函数指针又存在于对象中，这样就矛盾了：现在都没有生成对象，哪有什么虚函数指针呢？</p></li><li><p>析构可以？<br>类对象已经初始化了；况且我们通常通过基类的指针来销毁对象，如果析构函数不为虚的话，就不能正确识别对象类型，从而不能正确销毁对象。</p></li><li><p>c++11新特性</p></li></ol><ul><li>auto自动类型推导</li><li>nullptr 对之前NULL的歧义问题</li></ul><ol start="7"><li>delete 和 delete []的真正区别<br>delete 释放new分配的单个对象指针指向的内存<br>delete[] 释放new分配的对象数组指针指向的内存<br>同：都能完整地删除一块内存空间<br>异：delete只执行一次析构函数；delete[]会对每个数组元素执行析构函数。<br>针对简单类型 使用new分配后的不管是数组还是非数组形式内存空间用两种方式均可 如：</li></ol>   <div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">delete</span> a;</span><br><span class="line"><span class="keyword">delete</span> [] a;</span><br></pre></td></tr></table></figure></div><p>此种情况中的释放效果相同，原因在于：分配简单类型内存时，内存大小已经确定，系统可以记忆并且进行管理，在析构时，系统并不会调用析构函数，<br>它直接通过指针可以获取实际分配的内存空间，哪怕是一个数组内存空间(在分配过程中 系统会记录分配内存的大小等信息，此信息保存在结构体_CrtMemBlockHeader中</p><ol start="8"><li>delete 删除数组为什么会造成内存泄露？只调用一次析构函数</li><li>delete[]怎么知道要调用多少次析构函数？（讲了object的内存格式）<br>A: 内存分布：单一对象和对象数组的内存分布</li></ol><p>正如上图所示，数组所用的内存往往还包括“数组大小”的记录，以便delete知道需要调用多少次析构函数。</p><ol start="10"><li><p>请问这个怎么做 -&gt; 18亿用户数据，设计一个系统根据唯一ID查找用户数据<br>这是开放题，设计合理应该都可以，我下面的回答你只做参考吧。<br>我当时答的主要是：根据hash进行数据分片做分布式存储（多台机器），DB上面可以加Cache（用户ID通过哈希算法取哈希值，然后对存储机器个数取模，就是应该存储的机器编号，这里的哈希可以选一致性哈希算法来支持机器数量的动态增加和减少）。😂大概是这些…还可以进一步扩展讲，Cache和DB数据一致性的一些知识点，这个也是当时面试官进一步问到的。</p></li><li><p>指针和引用的区别</p></li></ol><ul><li>指针保存的是所指对象的地址，引用是所指对象的别名，指针需要通过解引用间接访问，而引用是直接访问；</li><li>指针可以改变地址，从而改变所指的对象，而引用必须从一而终；</li><li>引用在定义的时候必须初始化，而指针则不需要；</li><li>指针有指向常量的指针和指针常量，而引用没有常量引用；</li><li>指针更灵活，用的好威力无比，用的不好处处是坑，而引用用起来则安全多了，但是比较死板。</li></ul><ol start="13"><li><p>C++四种类型转换：static_cast, dynamic_cast, const_cast, reinterpret_cast<br>const_cast用于将const变量转为非const<br>static_cast用的最多，对于各种隐式转换，非const转const，(void* 转指针等, static_cast能用于多态想上转化，如果向下转能成功但是不安全，结果未知；<br>dynamic_cast用于动态类型转换。只能用于含有虚函数的类，用于类层次间的向上和向下转化。只能转指针或引用。向下转化时，如果是非法的对于指针返回NULL，对于引用抛异常。要深入了解内部转换的原理。<br>reinterpret_cast几乎什么都可以转，比如将int转指针，可能会出问题，尽量少用；<br>为什么不使用C的强制转换？C的强制转换表面上看起来功能强大什么都能转，但是转化不够明确，不能进行错误检查，容易出错。</p></li><li><p>海量数据问题<br>十亿整数（随机生成，可重复）中前K最大的数<br>类似问题的解决方法思路：首先哈希将数据分成N个文件，然后对每个文件建立K个元素最小/大堆（根据要求来选择）。最后将文件中剩余的数插入堆中，并维持K个元素的堆。最后将N个堆中的元素合起来分析。可以采用归并的方式来合并。在归并的时候为了提高效率还需要建一个N个元素构成的最大堆，先用N个堆中的最大值填充这个堆，然后就是弹出最大值，指针后移的操作了。当然这种问题在现在的互联网技术中，一般就用map-reduce框架来做了。</p></li></ol><h1 id="计算机网络"><a class="markdownIt-Anchor" href="#计算机网络"></a> 计算机网络</h1><ol><li><p>浏览器输入URL的整个过程<br>1.根据域名到DNS中找到IP(浏览器，本地hosts，路由器，本地DNS缓存)<br>2.根据IP建立TCP连接(三次握手)<br>3.连接建立成功发起http请求<br>4.服务器响应http请求<br>5.浏览器解析HTML代码并请求html中的静态资源（js,css）<br>6.关闭TCP连接（四次挥手）<br>7.浏览器渲染页面</p></li><li><p>TCP/UDP<br><a href="https://blog.csdn.net/shanghairuoxiao/article/details/68927070" target="_blank" rel="noopener">介绍</a></p></li></ol><h1 id="linux"><a class="markdownIt-Anchor" href="#linux"></a> linux</h1><ol><li>查看进程打开了哪些文件<br>lsof</li><li>为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？</li></ol><p>答：虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。在Client发送出最后的ACK回复，但该ACK可能丢失。Server如果没有收到ACK，将不断重复发送FIN片段。所以Client不能立即关闭，它必须确认Server接收到了该ACK。Client会在发送出ACK之后进入到TIME_WAIT状态。Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。所谓的2MSL是两倍的MSL(Maximum Segment Lifetime)。MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="面试" scheme="https://sunxin18.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>指针专题</title>
    <link href="https://sunxin18.github.io/2020/07/22/double-pointer/"/>
    <id>https://sunxin18.github.io/2020/07/22/double-pointer/</id>
    <published>2020-07-22T04:54:55.000Z</published>
    <updated>2020-09-19T09:55:06.239Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ol start="15"><li>三数之和<br>首先固定一个数，然后另外两个数用两个指针去探索记录和为0的组合。<br>对于前后一样的数可以跳过</li></ol><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; threeSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> target;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">             target= nums[i];</span><br><span class="line">             <span class="keyword">if</span> (target &gt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">             <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> l = i + <span class="number">1</span>, r = nums.size() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[l] + nums[r] + target &lt; <span class="number">0</span>) ++l;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nums[l] + nums[r] + target &gt; <span class="number">0</span>) --r;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    ans.push_back(&#123;target, nums[l], nums[r]&#125;);</span><br><span class="line">                    ++l, --r;</span><br><span class="line">                    <span class="keyword">while</span> (l &lt; r &amp;&amp; nums[l] == nums[l - <span class="number">1</span>]) ++l;</span><br><span class="line">                    <span class="keyword">while</span> (l &lt; r &amp;&amp; nums[r] == nums[r + <span class="number">1</span>]) --r;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><p>二、滑动窗口<br>3. 无重复字符的最长子串<br>滑动窗口的本质也是双指针,两个指针分别代表某个子串的两端，用ss这个字典来表示某个字符最新出现的位置，当右指针遍历到一个新字符，就检查一下这个元素最新的位置c，这个新串的起始位置就是c+1，每一个窗口就比较一下获得最大值。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;ss;</span><br><span class="line">        <span class="keyword">int</span> max_len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; s.size(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ss.find(s[j]) != ss.end()) &#123;</span><br><span class="line">                left = max(left, ss[s[j]] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> cur_len = j - left + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (max_len &lt; cur_len)</span><br><span class="line">                max_len = cur_len;</span><br><span class="line">            <span class="keyword">if</span> (ss.find(s[j]) != ss.end())</span><br><span class="line">                ss.erase(s[j]);</span><br><span class="line">            ss[s[j]] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max_len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="双指针" scheme="https://sunxin18.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>树状数组(binary indexed tree)</title>
    <link href="https://sunxin18.github.io/2020/07/18/binary-indexed-tree/"/>
    <id>https://sunxin18.github.io/2020/07/18/binary-indexed-tree/</id>
    <published>2020-07-18T13:36:18.000Z</published>
    <updated>2020-09-29T02:27:41.581Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="lowbit运算"><a class="markdownIt-Anchor" href="#lowbit运算"></a> lowbit()运算</h2><p>非负整数n在二进制下<strong>最低位1以及后面的0</strong>构成的值<br>比如lowbit(44)=101100=100=4</p><p>求法：对原数按位取反再加一，得到的新数再与原数相与。<br>比如101100 求反 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span> 010011 再加1 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span> 010100(就是负的原数) 再与101100(44) <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span> 100<br>lowbit(n)=n&amp;(-n)</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;g;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; countSubTrees(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges, <span class="built_in">string</span> labels) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;ans(n);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;visit(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;edges.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(edges[i][<span class="number">1</span>]==<span class="number">0</span>)</span><br><span class="line">                g[edges[i][<span class="number">1</span>]].push_back(edges[i][<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(visit[edges[i][<span class="number">1</span>]]==<span class="number">1</span>)</span><br><span class="line">                g[edges[i][<span class="number">1</span>]].push_back(edges[i][<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                g[edges[i][<span class="number">0</span>]].push_back(edges[i][<span class="number">1</span>]);</span><br><span class="line">            visit[edges[i][<span class="number">0</span>]]=visit[edges[i][<span class="number">1</span>]]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">            dfs(i,i,res,labels);</span><br><span class="line">            ans[i]=res+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> v,<span class="keyword">int</span> t,<span class="keyword">int</span> &amp;res,<span class="built_in">string</span> labels)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(labels[v]==labels[t]&amp;&amp;v!=t)</span><br><span class="line">            res++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;g[t].size();j++)&#123;</span><br><span class="line">            dfs(v,g[t][j],res,labels);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="树状数组" scheme="https://sunxin18.github.io/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>NP-hard问题总结(reduce to MC problem)</title>
    <link href="https://sunxin18.github.io/2020/06/21/paper2/"/>
    <id>https://sunxin18.github.io/2020/06/21/paper2/</id>
    <published>2020-06-21T12:44:49.000Z</published>
    <updated>2020-06-30T14:08:37.019Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在这里对图论相关的np-hard问题做个总结</p><h1 id="triangle-minimization-in-large-networks"><a class="markdownIt-Anchor" href="#triangle-minimization-in-large-networks"></a> Triangle minimization in large networks</h1><p>本文从两个方向来最小化图中三角形数量，一个是删除点、一个是删除边<br>以删除边为例，有两个算法思路</p><ul><li>基于度的删除(每次删除度最大的边(a,b),这条边的度就是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo><mi>d</mi><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>d</mi><mo stretchy="false">(</mo><mi>b</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">min(d(a),d(b))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">b</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>)</li><li>基于三角形的删除，每次删除边所在的三角形数量最多的边</li></ul><p><strong>优化</strong><br>Lazy evaluation：<br>采用优先队列，再第i轮迭代时，若当前边的在上轮得到的三角形数量值小于当前的最大三角形数量，就不需要计算了</p><h1 id="k-core-minimization"><a class="markdownIt-Anchor" href="#k-core-minimization"></a> K-core Minimization</h1><p>for all given k</p><h1 id="preventing-unraveling-in-social-networks-the-anchored-k-core-problem"><a class="markdownIt-Anchor" href="#preventing-unraveling-in-social-networks-the-anchored-k-core-problem"></a> Preventing Unraveling in Social Networks: The Anchored <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>-Core Problem</h1><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">k=2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>:有多项式时间精确解法：<br>一、RemoveCore(G)<br>移除图中2-core节点之间的边(也可以想象是把2-core中的点浓缩(contract)成一个点，命名为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span>)，将图转化为森林，这个森林的树有两种类型一种有2-core节点叫<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span></span></span></span>，一种是没有2-core节点的叫<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span>。<br>这样就分成了两种情况：</p><ul><li>对于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span></span></span></span>,选取离<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span>最远的点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>v</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">v_{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li><li>对于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span>,选取最远路径的两个端点<br>比较这两种更好的收益做下一步的选择<br><a href="/2020/06/21/paper2/1.png" data-fancybox="group" data-caption class="fancybox"><img src="/2020/06/21/paper2/1.png" alt title></a></li></ul><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>≥</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">k\geq 3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83041em;vertical-align:-0.13597em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span><br>证明:<br><strong>构建</strong>:假设<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>s</mi><mn>2</mn></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">S_{1},s_{2}...</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span></span></span></span>是集合，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>e</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>e</mi><mn>2</mn></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">e_{1},e_{2}...</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span></span></span></span>是覆盖的元素，我们这样建立图，首先顶点集合<br><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo fence="true">{</mo><msub><mi>v</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>v</mi><mn>2</mn></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo fence="true">}</mo></mrow><annotation encoding="application/x-tex">\left \{v_{1},v_{2}...\right \}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">{</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mclose delimcenter" style="top:0em;">}</span></span></span></span></span>对应<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>s</mi><mn>2</mn></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">S_{1},s_{2}...</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>H</mi></mrow><annotation encoding="application/x-tex">H</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span></span></span></span>是一个随意的大图，除了顶点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">h</span></span></span></span>度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>,其他点都是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>，然后按照集合覆盖的连接方式连接对应的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">h</span></span></span></span>,这样选择了一个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span>，和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span>相连的图<br><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>H</mi></mrow><annotation encoding="application/x-tex">H</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span></span></span></span>中的顶点都可以保留了。</p><h1 id="k-core-maximization-an-edge-addition-approach"><a class="markdownIt-Anchor" href="#k-core-maximization-an-edge-addition-approach"></a> K-Core Maximization: An Edge Addition Approach</h1><p>总体思想是每次选取followers最多的侯选边，改进的算法并没有对followers有本质的提高，只是对侯选边精简和中间结果保留优化了时间空间复杂度。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="图论" scheme="https://sunxin18.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>图论经典问题</title>
    <link href="https://sunxin18.github.io/2020/06/17/gragh-th/"/>
    <id>https://sunxin18.github.io/2020/06/17/gragh-th/</id>
    <published>2020-06-17T02:16:09.000Z</published>
    <updated>2020-06-30T12:45:27.585Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本章节回顾一下图论里经典的算法</p><h1 id="dfs与bfs"><a class="markdownIt-Anchor" href="#dfs与bfs"></a> DFS与BFS</h1><p>DFS --stack–O(h)(根据树的高度)–不具最短路–恢复现场（恢复到之前的状态）–剪枝（可行性剪枝、最优性剪枝）<br>BFS --queue–O(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>h</mi></msup></mrow><annotation encoding="application/x-tex">2^{h}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">h</span></span></span></span></span></span></span></span></span></span></span></span>)(宽度)–最短路</p><p>DFS：经典题目：排练数字、N-皇后</p><h1 id="最短路径"><a class="markdownIt-Anchor" href="#最短路径"></a> 最短路径</h1><p>难点在于建图</p><h2 id="dijksra"><a class="markdownIt-Anchor" href="#dijksra"></a> dijksra</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> dist[<span class="number">1</span>]=<span class="number">0</span>,dist[other]=<span class="number">0x3f3f3f</span>,S(目前已确定点的集合)</span><br><span class="line"><span class="number">2.</span> <span class="keyword">for</span> i in n</span><br><span class="line">$t leftarrow S中不存在，距离S最近的点$</span><br><span class="line">$S \leftarrow  S \bigcup t$</span><br><span class="line">用t更新到其他点的距离</span><br></pre></td></tr></table></figure></div><p>完整代码：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">510</span>;</span><br><span class="line"><span class="keyword">int</span> m,n;</span><br><span class="line"><span class="keyword">int</span> dist[N];</span><br><span class="line"><span class="keyword">int</span> g[N][N];</span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dijkstra</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(dist));</span><br><span class="line">dist[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> t=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!st[j]&amp;&amp;(t==<span class="number">-1</span>||dist[j]&lt;dist[t]) </span><br><span class="line">t=j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j =<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">dist[j]=min(dist[j],dist[t]+g[t][j]);</span><br><span class="line">&#125;</span><br><span class="line">st[t]=<span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (dist[n] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> main()&#123;</span><br><span class="line"><span class="built_in">memset</span>(g,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(g));</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">while</span>(m--)&#123;</span><br><span class="line"><span class="keyword">int</span> a,b,c;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line"><span class="keyword">if</span>(a==b)<span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">g[a][b]=min(g[a][b],c);</span><br><span class="line">&#125;</span><br><span class="line">print(<span class="string">"%d\n"</span>,dijkstra();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h1 id="最小生成树"><a class="markdownIt-Anchor" href="#最小生成树"></a> 最小生成树</h1><h1 id="哈密顿图"><a class="markdownIt-Anchor" href="#哈密顿图"></a> 哈密顿图</h1><p>设G=&lt;V,E&gt;为一图(无向的或有向的).G中经过每个顶点一次且仅一次的通路称作哈密顿通路；G中经过每    个顶点一次且仅一次的回路称作哈密顿回路；若G中存在哈密顿回路，则称G为哈密顿图。</p><p><strong>任何一个哈密顿图可以看作是一个基本回路再加上连接回路上顶点对的其他若干边</strong><br>从一个基本回路上删除k个顶点，最多形成k个连通分支<br>向一个图种</p><h1 id="斯坦纳树steiner-tree"><a class="markdownIt-Anchor" href="#斯坦纳树steiner-tree"></a> 斯坦纳树（steiner tree)</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="算法编程" scheme="https://sunxin18.github.io/categories/%E7%AE%97%E6%B3%95%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="图论" scheme="https://sunxin18.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>动态规划困难问题合集</title>
    <link href="https://sunxin18.github.io/2020/06/14/dp-hard/"/>
    <id>https://sunxin18.github.io/2020/06/14/dp-hard/</id>
    <published>2020-06-14T11:19:59.000Z</published>
    <updated>2020-08-16T11:46:55.381Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>dp可以用来解决有限集合的最值问题(max,min,count…)<br>dp问题分为两个部分</p><ul><li>状态表示</li><li>状态计算</li></ul><p>初始化和边界符合定义就可以</p><ol start="1458"><li>两个子序列的最大点积(190周赛)<br>dp[i][j]的含义是到nums1[i]和nums2[j]为止的子序列的最大点积。<br>1.选择nums1[i]和nums2[j]</li></ol><ul><li>不选择前面的 dp[i][j]=nums1[i] <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>×</mo></mrow><annotation encoding="application/x-tex">\times</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">×</span></span></span></span> nums2[j]</li><li>也选择前面的 dp[i][j]=max(dp[i][j],nums1[i]<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>×</mo></mrow><annotation encoding="application/x-tex">\times</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">×</span></span></span></span>nums2[j]+dp[i-1][j-1])<br>因为dp[i][j]是截止到nums1[i]和nums2[j]中的最大点积，所以只需要dp[i-1][j-1]就可以了<br>事实上从这里可以看出想法一就是想法二的情况之一<br>2.选择nums1[i],不选择nums2[j]<br>这种情况很容易想到就用dp[i][j-1]来表示，但实际上dp[i][j-1]并不只表示这种情况，因为dp[i][j-1]表示的是到i和j-1为止的最大点击，nums[i]不一定就选，但是这个并不影响最终结果，因为我们是求最大值，当这个状态表示的集合多的时候，不会漏掉最大值的。<br>dp[i][j]=max(dp[i][j],dp[i][j-1])<br>3.不选择nums1[i],选择nums2[j]</li></ul><p>等价于dp[i-1][j]<br>dp[i][j]=max(dp[i][j],dp[i-1][j])</p><p>4.nums1[i]，nums2[i]都不选。<br>这种情况包括在第二三种情况了</p><p>这样会保证两个序列长度相等吗?<br>会的，因为每次我们选取的操作–nums1[i]<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>×</mo></mrow><annotation encoding="application/x-tex">\times</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">×</span></span></span></span>nums2[j]+dp[i-1][j-1]，都是同时选取每一个序列的一个元素.</p><p><a href="/2020/06/14/dp-hard/1.png" data-fancybox="group" data-caption class="fancybox"><img src="/2020/06/14/dp-hard/1.png" alt title></a></p><p><strong>时间复杂度</strong><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(mn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDotProduct</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=nums1.size();</span><br><span class="line">        <span class="keyword">int</span> m=nums2.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;dp(n+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(m+<span class="number">1</span>,<span class="number">-0x3f3f3f</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n+<span class="number">1</span>;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;m+<span class="number">1</span>;j++)&#123;</span><br><span class="line">                dp[i][j]=max(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>]);</span><br><span class="line">                dp[i][j]=max(dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+nums1[i<span class="number">-1</span>]*nums2[j<span class="number">-1</span>],dp[i][j]);</span><br><span class="line">                dp[i][j]=max(nums1[i<span class="number">-1</span>]*nums2[j<span class="number">-1</span>],dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><ol start="1143"><li>最长公共子序列</li></ol><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(<span class="built_in">string</span> text1, <span class="built_in">string</span> text2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p = text1.size();</span><br><span class="line">        <span class="keyword">int</span> q = text2.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(p+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(q+<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;p+<span class="number">1</span>;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j&lt;q+<span class="number">1</span>;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(text1[i<span class="number">-1</span>]==text2[j<span class="number">-1</span>])</span><br><span class="line">                    dp[i][j]=dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j]=max(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[p][q];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><ol start="1411"><li></li></ol><p>这道题到不算dp，也是用dp的一点思想来递归。<br>在第一层可以摆出6个ABA类型的和6个ABC类型的涂法。对于下面每一层，每一个ABA涂法可以拼接2个ABC涂法和3个ABA涂法，每一个ABC涂法可以拼接2个ABC涂法和2个ABA涂法。这样迭代可以算出第N层有几种ABA涂法和ABC涂法，相加就是答案。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numOfWays</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> aba = <span class="number">6</span>, abc = <span class="number">6</span>;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> m = <span class="built_in">pow</span>(<span class="number">10</span>,<span class="number">9</span>) + <span class="number">7</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> ABA,ABC;</span><br><span class="line">            ABA=(abc*<span class="number">2</span>+aba*<span class="number">3</span>)%m;</span><br><span class="line">            ABC=(abc*<span class="number">2</span>+aba*<span class="number">2</span>)%m;</span><br><span class="line">            abc=ABC,aba=ABA;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (abc+aba)%m;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="算法编程" scheme="https://sunxin18.github.io/categories/%E7%AE%97%E6%B3%95%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="动态规划" scheme="https://sunxin18.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>博客美化专题</title>
    <link href="https://sunxin18.github.io/2020/05/27/blog-bea/"/>
    <id>https://sunxin18.github.io/2020/05/27/blog-bea/</id>
    <published>2020-05-27T03:53:30.000Z</published>
    <updated>2020-07-15T10:25:35.051Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="加入爱心页面"><a class="markdownIt-Anchor" href="#加入爱心页面"></a> 加入爱心页面</h1><p>首先新建一个html的page</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page &quot;html&quot;</span><br></pre></td></tr></table></figure></div><p>修改主题的config，加入下面<br><a href="/2020/05/27/blog-bea/1.png" data-fancybox="group" data-caption class="fancybox"><img src="/2020/05/27/blog-bea/1.png" alt title></a><br>将下载好的love文件夹放到\blog\source\html<br>修改config，跳过渲染，因为已经是html文件了，渲染是吧md文件到html：<br><a href="/2020/05/27/blog-bea/2.png" data-fancybox="group" data-caption class="fancybox"><img src="/2020/05/27/blog-bea/2.png" alt title></a></p><p>之后的细节按照自己的需要修改爱心文件即可</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="博客" scheme="https://sunxin18.github.io/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="博客美化专题" scheme="https://sunxin18.github.io/tags/%E5%8D%9A%E5%AE%A2%E7%BE%8E%E5%8C%96%E4%B8%93%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>bug</title>
    <link href="https://sunxin18.github.io/2020/05/24/bug/"/>
    <id>https://sunxin18.github.io/2020/05/24/bug/</id>
    <published>2020-05-24T02:09:37.000Z</published>
    <updated>2020-07-31T01:48:43.248Z</updated>
    
    <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="哎呀你输错了！" data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">该文章已加密, 请输入密码查看。</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="b00607fc55429e352b11d582cc55d2f56b069ce1359415c4b8b2719dab3d5735">38cd76bef1cf79f27267863aa0f1e10aff0a55b3032fb665653565d974dcbbb6fb9e335fcb6f2cac947609853f0c56f0dbf7300ebc6e47358c153341a4c18fe59abedea6571c7603dd0c3ebeb08faededad4174f6c6eeda32fe389116f16e28f0210187cfa4a272439508fc90658c1b2309a116992d303d700f05971b0e4855d4f4ff589cfc7838359191bd9ee6077a648cc1789b19943078668c653d9694c0c484aaaa3e126d8a153c6e91c689217e9c1a3c94044ce8a2c75324091dd2b9507f971adb1fa080a90a1dcbab484be3b5c3ddafee8e02aac8682158bc35b66d84d3aa548a4c01c52d3482c8727cafa55f5793ab1eeaba23852b8679173024c1d6f6aa5e5fa4b793bdce312ecdb8ae54f91d7aff15ff9deca66782ea8fdf5e194780fbb49c60084fe17bc651bb4a28460bea328577199f18b81365e3c0c59786228c8c1e637266f44f453077ddc1b43cd6e2b252670ae75f4da5efc2db35683973d7a9d8321f26274e5aade8c984a77ce3b5a8f0036073db2433a25852fe4b6f97ec765d15a11b0c8c3cc847903c1b68fccf363c7aed27930deff82f4af0bf7217e7e6b42db2d402578c22619fa35a6fad85fac828e205d49fff3db64c733eb3804fa4985b7603e1aa26bcca3315caa72ab9210ea47fdef3802e2f962f5c7900bf0c6a4a51c48a7506ea0d4a63c4475e5dfb90df4af4022924a51b72c35b6b4edf8b217ba6fc91762adf7a601a1bf14d99e116e5f5f0a80a69fdd3905772ddd56e7f4ebab0db97b545f99240f5dd820e1e2b016cc8d39e2fc21cdcf0ce27bd3df27868b45539797acff30ad69ea71c3d6c109cc3bb62c4bdefc89efbc567a3e687ff80c187099962b352dc2502f4023eb1cf46580cda18a0ae16d8224150fd7e56c523e12b6fc67fc047dbf4ec8fe421975f0dd19b1addf537c6effed49cffcb3b04ba30633b31d258558b81a90d5fb76c9d2ece1bb617c07600702e8741b83ba884e12bec867a49ad9daa42a9662b7031dc0419835de953e148ce1e6876737bd9ca45f824f16e3f076bbf884fab592ee5ce1bdbb44c2643e7616c4fa64599de320ed8a4c5365967aefccb1acaa84005eeea5b9e241dfa5b17ef794f48444bcd9e18b8198b0f0d383108a7cd0e8d1e31068eaec3744d40b4ae5be9449f36589d3a35f6ffc04a2cc178edf276123d5439755e182f14970c937a0de5ce806c04e3d88fd6f064ed0af56c568eec1acdf683d76b93b44dbb3fef3f7221ddc0a52b689422260c60de93c6a8c8b777b0963cf2822aa9db5bf5f0205aabb2abde71805d0db92dd908818fd57a20c9848b7647b5b24b64da475023124d62772d76545f39cfc21ac688c909e318a3829adedc0e6d5b56433b632bcf23abf7ca8cae174e45d0a131c589827a3d57fd1479ee056a20b28d3185a57d1dbd8e114ecfc19d4ac117e96fd01dfc83b158b36a62fde5a84b96be6579df174077894f7d737ea68e58d0777048608e2c088ff6ae15c3bd042990a7e50dcbf4fc2cc71151f2385a61028faa5aa21cbc5dca2de47cddf3e8d3188a40e66e4e6d3f45cc3d460c1dd3c2749a71f8261e5279264a82140e2a481a864d1b4971cbd811acb4f3f481fb3c379e38cbaf7cb2de68a19c426646a809a31b4bb444d9916edd5f5b8e858860d1ca79c95ccc7fde8f750f92cd39d66f5a4a4179081a8734526ff96684c6303b8da586b1dcde6156123297a892d54b802c43075706da85a3e86bfd53c5201e0d8f6f7d1a6246efeac7810ef1431195514473eeeb69897c7ba93a3d019033913e90062de0b33c1cc8002457aa1fea3d696053cdeacc0e6928262ad5415c50f1b247fba5faf8feb3b9e9ace18bd20cd8f185b1f8474789eaa8c5b0f1b26f16f52349c264913baac2f1fee490188315d71cbed8ba823b881ec07fb3bb39d45ed9290266fa46a32c223fcd6217b53f97201e68c063dda1f96b9762eeae566b495023f33ee92ea07d7ed826f77ad93aee21da83c29a7baf6e25bd4146f27943bad1d236e4f0b3d85668fb2caefb34313ad7438656713976144aa7df1075b5f5aab72a8131e387b72a5976ff6b0bd48c4bb923f9a3c472e59b9e31291f95ffea412c8eabff0666cae1f596c45e37faef46574ea05ad8ba45796611d1795b7120c84615590aed36318d92ab15b34009c509467be9dbc5701</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      Here&#39;s something encrypted, password is required to continue reading.
    
    </summary>
    
    
      <category term="C++" scheme="https://sunxin18.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>seq2seq</title>
    <link href="https://sunxin18.github.io/2020/05/20/seq2/"/>
    <id>https://sunxin18.github.io/2020/05/20/seq2/</id>
    <published>2020-05-20T07:36:23.000Z</published>
    <updated>2020-05-31T10:24:14.285Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文将介绍seq2seq模型以及机器翻译的内容,需要明白RNN模型<br>RNN介绍的文章看这里：<a href="https://blog.csdn.net/zhaojc1995/article/details/80572098" target="_blank" rel="noopener">https://blog.csdn.net/zhaojc1995/article/details/80572098</a><br>为什么需要RNN?</p><ul><li>时序数据：语音、天气、股票、文本<br><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>h</mi><mi>t</mi></msub><mo>=</mo><mi>f</mi><mrow><mo fence="true">(</mo><msub><mi>w</mi><mrow><mi>h</mi><mi>h</mi></mrow></msub><mo>⋅</mo><msub><mi>h</mi><mrow><mi>h</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><msub><mi>w</mi><mrow><mi>x</mi><mi>h</mi></mrow></msub><mo>⋅</mo><msub><mi>x</mi><mi>t</mi></msub><mo>+</mo><msub><mi>b</mi><mn>1</mn></msub><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">h_{t}=f\left(w_{h h} \cdot h_{h-1}+w_{x h} \cdot x_{t}+b_{1}\right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">h</span><span class="mord mathdefault mtight">h</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">h</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="mord mathdefault mtight">h</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">)</span></span></span></span></span><br><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mover accent="true"><mi>y</mi><mo>^</mo></mover><mi>t</mi></msub><mo>=</mo><mi>g</mi><mrow><mo fence="true">(</mo><msub><mi>w</mi><mrow><mi>h</mi><mi>y</mi></mrow></msub><mo>⋅</mo><msub><mi>h</mi><mi>t</mi></msub><mo>+</mo><msub><mi>b</mi><mn>2</mn></msub><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">\hat{y}_{t}=g\left(w_{h y} \cdot h_{t}+b_{2}\right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.19444em;">^</span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">h</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">)</span></span></span></span></span></li><li>R’n’n</li></ul><h1 id="seq2seq"><a class="markdownIt-Anchor" href="#seq2seq"></a> seq2seq</h1><p>seq2seq(sequence to sequence)故名思意就是一种能够根据给定的序列，通过特定的方法生成另一个序列的方法，属于encoder-decoder结构的一种，这里看看常见的encoder-decoder结构，基本思想就是利用两个RNN，一个RNN作为encoder，另一个RNN作为decoder。encoder负责将输入序列压缩成指定长度的向量，这个向量就可以看成是这个序列的语义，这个过程称为编码，如下图，获取语义向量最简单的方式就是直接将最后一个输入的隐状态作为语义向量C。也可以对最后一个隐含状态做一个变换得到语义向量，还可以将输入序列的所有隐含状态做一个变换得到语义变量。<br>而decoder则负责根据语义向量生成指定的序列，这个过程也称为解码，如下图，最简单的方式是将encoder得到的语义变量作为初始状态输入到decoder的RNN中，得到输出序列。可以看到上一时刻的输出会作为当前时刻的输入，而且其中语义向量C只作为初始状态参与运算，后面的运算都与语义向量C无关。<br>seq2seq应用在机器翻译、对话机器人等领域，后续会补充一些项目实战，下面先介绍一下基础思路<br><a href="/2020/05/20/seq2/1.png" data-fancybox="group" data-caption class="fancybox"><img src="/2020/05/20/seq2/1.png" alt title></a><br><a href="/2020/05/20/seq2/2.png" data-fancybox="group" data-caption class="fancybox"><img src="/2020/05/20/seq2/2.png" alt title></a></p><h1 id="seq2seq训练"><a class="markdownIt-Anchor" href="#seq2seq训练"></a> seq2seq训练</h1><p>训练数据为&lt;中文，英文&gt;，然后我们将每个minibatch中语句的长度补成相同（与最大长度相同），不同的minibatch不要求相同长度，这样方便进行向量化矩阵化(matrix)操作，</p><h1 id="infereencedecoding"><a class="markdownIt-Anchor" href="#infereencedecoding"></a> infereence/Decoding</h1><p>如果我们已经训练好了模型参数，怎么生成语句序列呢呢？<br><a href="/2020/05/20/seq2/3.png" data-fancybox="group" data-caption class="fancybox"><img src="/2020/05/20/seq2/3.png" alt title></a><br>通过模型softmax，我们可以得到每个单词的概率分布，然后每次选取概率最大的作为生成词(greedy)，但如果我们只考虑每个单词(unigram)，即使生成的语句单词相同，但是如果顺序不同就会不通顺，即没有好的语法结构，所以可以用bgram。<br>如何改进只能考虑局部最优解的局限性呢？下面有两个改进想法，exhaustic search,beam search</p><h2 id="exhaustic-search"><a class="markdownIt-Anchor" href="#exhaustic-search"></a> exhaustic search</h2><p>就是每次都考虑所有单词的情况，而不是只选择概率最高的单词，这样肯定可以找到全局最优解，但是这样就会复杂度很高，为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mrow><mo fence="true">∣</mo><mi>v</mi><mo fence="true">∣</mo></mrow><mi>T</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\left | v\right |^{T})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.231231em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="minner"><span class="minner"><span class="mopen delimcenter" style="top:0em;">∣</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose delimcenter" style="top:0em;">∣</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.981231em;"><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p><h2 id="beam-search"><a class="markdownIt-Anchor" href="#beam-search"></a> beam search</h2><p>exhaustic search复杂度太高，我们考虑使用beam search，这种方法是既考虑了贪心算法的改进也对复杂度降低，如果我们设三种方法的最优解是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mi>o</mi></msub></mrow><annotation encoding="application/x-tex">T_{o}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">o</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mi>e</mi></msub></mrow><annotation encoding="application/x-tex">T_{e}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mi>b</mi></msub></mrow><annotation encoding="application/x-tex">T_{b}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">b</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,那么<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mi>o</mi></msub><mo>⊂</mo><msub><mi>T</mi><mi>e</mi></msub><mo>⊂</mo><msub><mi>T</mi><mi>b</mi></msub></mrow><annotation encoding="application/x-tex">T_{o} \subset T_{e} \subset T_{b}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">o</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊂</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊂</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">b</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><br>beam search的想法是每次只考虑最好的k个单词，接下来是对第一次最好的k个单词继续考虑第二个生成单词也是取概率最高的前k个,但如果这样继续下去又是指数级增长了，所以是取对目前的序列（目前也就是长度为2）的概率和(其实是概率的乘积，但因为取了log)最高的k个序列，最后直到序列预测到end时停止，这样考虑也是有局限的，因为可能有的序列到很短就停止了，这样他的值就很大，最优解会优先选他，所以这块我们对每个序列除以长度。<br>每一步最多考虑<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>k</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">k^{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span>个可能性，这个算法的复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>k</mi><mn>2</mn></msup><mi>T</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(k^{2}T)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mclose">)</span></span></span></span><br><a href="/2020/05/20/seq2/4.png" data-fancybox="group" data-caption class="fancybox"><img src="/2020/05/20/seq2/4.png" alt title></a></p><h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2><p>这里附上pytorch官方的实现：<a href="https://pytorch.org/tutorials/intermediate/seq2seq_translation_tutorial.html" target="_blank" rel="noopener">https://pytorch.org/tutorials/intermediate/seq2seq_translation_tutorial.html</a></p><h1 id="transformer"><a class="markdownIt-Anchor" href="#transformer"></a> transformer</h1><p>我们知道同一个单词可能在不同的语境中可能有不同的意思也就是需要不同的向量表达，这个表达依赖于上下文的意思，其他单词也影响着这个单词的意思，</p><h2 id="为什么需要self-attention"><a class="markdownIt-Anchor" href="#为什么需要self-attention"></a> 为什么需要self-attention？</h2><p>lstm的不足：</p><ul><li>long-term dependency</li><li>只能串行</li></ul><p>transformer：<br>两两个都能考虑到</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="自然语言处理" scheme="https://sunxin18.github.io/categories/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86/"/>
    
    
      <category term="seq2seq" scheme="https://sunxin18.github.io/tags/seq2seq/"/>
    
  </entry>
  
  <entry>
    <title>attention(注意力机制解析)</title>
    <link href="https://sunxin18.github.io/2020/05/20/attention/"/>
    <id>https://sunxin18.github.io/2020/05/20/attention/</id>
    <published>2020-05-20T00:50:58.000Z</published>
    <updated>2020-05-31T10:24:15.685Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文我们将讲解注意力机制在视觉和自然语言以及图挖掘领域的使用。<br>PyTorch：<a href="https://github.com/sgrvinod/a-PyTorch-Tutorial-to-Image-Captioning" target="_blank" rel="noopener">https://github.com/sgrvinod/a-PyTorch-Tutorial-to-Image-Captioning</a></p><h2 id="mutimodal-learning"><a class="markdownIt-Anchor" href="#mutimodal-learning"></a> mutimodal learning</h2><p>即将多个模型连接起来，每个模型完成相应的任务，一起完成比如看图说话、提取摘要等任务。<br><a href="/2020/05/20/attention/1.png" data-fancybox="group" data-caption class="fancybox"><img src="/2020/05/20/attention/1.png" alt title></a></p><h2 id="attention注意力机制"><a class="markdownIt-Anchor" href="#attention注意力机制"></a> attention(注意力机制)</h2><p>将注意力放到重要的地方，比较符合人类的思考，可以应用在文本、图像、自注意力(self-attention)</p><h3 id="看图说话"><a class="markdownIt-Anchor" href="#看图说话"></a> 看图说话</h3><p>先把图片提取出一个向量作为桥梁，我们取模型中倒数第二个向量v，wih是一个转移矩阵,输入到RNN中来生成语句序列<br>但这模型有些问题，</p><ol><li>识别不出来某些物体</li><li>我们把图片等价于一个向量，通过这个向量来生成，其实有时候我们只需要关注图片中的一直猫，不需要理解整张图片<br><a href="/2020/05/20/attention/2.png" data-fancybox="group" data-caption class="fancybox"><img src="/2020/05/20/attention/2.png" alt title></a></li></ol><h2 id="图像识别的注意力机制"><a class="markdownIt-Anchor" href="#图像识别的注意力机制"></a> 图像识别的注意力机制</h2><p>这里feature矩阵每个格子都是一个d维的向量，a1也是一个3×3的矩阵，每个格代表这个区域的权重，当我们生成第一个单词我们要将注意力放在概率最高的区域，然后将这个两个矩阵的信息进行汇集到向量<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Z</mi></mrow><annotation encoding="application/x-tex">Z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span></span></span></span>，较于之前的seq2seq模型，我们这里就多了一个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Z</mi></mrow><annotation encoding="application/x-tex">Z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span></span></span></span><br><a href="/2020/05/20/attention/3.png" data-fancybox="group" data-caption class="fancybox"><img src="/2020/05/20/attention/3.png" alt title></a><br>我们将<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>z</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">z1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mord">1</span></span></span></span>输入到rnn模型，这里的first word就是start ，通过h1输出第一个单词和第二个单词的注意力，然后再生成<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>z</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">z2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mord">2</span></span></span></span>,这里的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">y2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord">2</span></span></span></span>就是的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">d1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span><span class="mord">1</span></span></span></span><br><a href="/2020/05/20/attention/4.png" data-fancybox="group" data-caption class="fancybox"><img src="/2020/05/20/attention/4.png" alt title></a></p><p><a href="https://blog.csdn.net/shenxiaolu1984/article/details/51493673#fn:1" target="_blank" rel="noopener">https://blog.csdn.net/shenxiaolu1984/article/details/51493673#fn:1</a></p><h1 id="attention-in-seq2seq"><a class="markdownIt-Anchor" href="#attention-in-seq2seq"></a> attention in seq2seq</h1><h2 id="seq2seq的不足"><a class="markdownIt-Anchor" href="#seq2seq的不足"></a> seq2seq的不足：</h2><ol><li><strong>梯度问题</strong><br>首先我们的语义编码c，我们的目的是希望这个向量能包括所有输入的单词信息，但是因为LSTM梯度消失的问题，c可能只能捕获离他较近的几个单词的信息，前面的单词可能就考虑不到了(怎么改进？给前面的单词分配一个权重——–attention)</li><li><strong>应用角度</strong><br>现在的模型，我们生成下一个单词是依赖于上一个单词(pre)以及语义编码c,即<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi><mo>←</mo><mo stretchy="false">(</mo><mi>p</mi><mi>r</mi><mi>e</mi><mo separator="true">,</mo><mi>c</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">v \leftarrow (pre,c)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">←</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">c</span><span class="mclose">)</span></span></span></span>，然而往往我们在翻译的时候只会关注句子的一部分，并且这种模式太过于依赖语义编码c，如果c的效果不理想，那么最后的decoder也会不理想，这也是bottleneck problem。还有一个原因，c向量的维度已经固定，对不同长度的输入句子，都用一个固定维度的向量表达难免不足</li></ol><h2 id="seq2seq的attention"><a class="markdownIt-Anchor" href="#seq2seq的attention"></a> seq2seq的attention</h2><p>下面这幅图讲解了大致流程，首先看encoder部分这里的隐含向量g是什么，举个例子，按照图的描述，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span>就是transformation,f是激活函数，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>g</mi><mn>2</mn></msub><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><msub><mi>W</mi><mrow><mi>x</mi><mi>h</mi></mrow></msub><mo>⋅</mo><mi>e</mi><mi>m</mi><mi>b</mi><mi>e</mi><mi>d</mi><mi>i</mi><mi>n</mi><mi>g</mi><mo stretchy="false">(</mo><mi>w</mi><mi>e</mi><mi>a</mi><mi>t</mi><mi>h</mi><mi>e</mi><mi>r</mi><mo stretchy="false">)</mo><mo>+</mo><msub><mi>W</mi><mrow><mi>h</mi><mi>h</mi></mrow></msub><mo>⋅</mo><msub><mi>g</mi><mn>1</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">g_{2}=f(W_{xh} \cdot embeding(weather)+W_{hh}\cdot g_{1})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="mord mathdefault mtight">h</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">e</span><span class="mord mathdefault">m</span><span class="mord mathdefault">b</span><span class="mord mathdefault">e</span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">e</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">h</span><span class="mord mathdefault mtight">h</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。<br>我们要使用注意力，就要给每个词一个attention score，最简单的就是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">h</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi></mrow><annotation encoding="application/x-tex">g</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span></span></span></span>的内积，当然也可以设置别的函数，比如<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>g</mi><mi>T</mi></msup><mo>⋅</mo><mi>M</mi><mo>⋅</mo><mi>h</mi></mrow><annotation encoding="application/x-tex">g^{T} \cdot M \cdot  h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.035771em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">h</span></span></span></span>,这里的M就是要学习的一个参数矩阵。<br>我们以内积的方法为例，通过计算每个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>g</mi><mi>T</mi></msup><mo>⋅</mo><mi>h</mi></mrow><annotation encoding="application/x-tex">g^{T} \cdot h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.035771em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">h</span></span></span></span>我们得到了每个单词的一个权重，然后通过归一化(可以是简单的通分，也可以是softmax)。<br>现在我们如何生成单词呢？首先先通过attention scroe,来生成新的context vector <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>c</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">c_{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>c</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">c_{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>来生成翻译单词(之前我们用的是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span></span></span></span>),<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>c</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">c_{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>按图中的例子就是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>c</mi><mn>1</mn></msub><mo>=</mo><mn>0.6</mn><mo>⋅</mo><msub><mi>g</mi><mn>1</mn></msub><mo>+</mo><mn>0.2</mn><mo>⋅</mo><msub><mi>g</mi><mn>2</mn></msub><mo>+</mo><mn>0.1</mn><mo>⋅</mo><msub><mi>g</mi><mn>3</mn></msub><mo>+</mo><mn>0.1</mn><mo>⋅</mo><msub><mi>g</mi><mn>4</mn></msub></mrow><annotation encoding="application/x-tex">c_{1}=0.6\cdot g_{1}+0.2\cdot g_{2}+0.1\cdot g_{3}+0.1\cdot g_{4}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">6</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.7777700000000001em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.7777700000000001em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.7777700000000001em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，然后我们将<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>c</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">c_{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>h</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">h_{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>拼接起来，来得到输出的单词<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>y</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">y_{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>y</mi><mn>1</mn></msub><mo>=</mo><mi>s</mi><mi>o</mi><mi>f</mi><mi>t</mi><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><msub><mi>W</mi><mrow><mi>h</mi><mi>y</mi></mrow></msub><mo>⋅</mo><mo stretchy="false">(</mo><msub><mi>c</mi><mn>1</mn></msub><mi mathvariant="normal">∣</mi><msub><mi>h</mi><mn>1</mn></msub><mo>+</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">y_{1}=softmax(W_{hy} \cdot (c_{1}|h_{1}+b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">t</span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">h</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span></span></span></span>(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>y</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">y_{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>就是v维度的,选取概率最大的单词作为预测词),之后类似，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>y</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">y_{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>作为第二个预测单词的输入<br><a href="/2020/05/20/attention/5.png" data-fancybox="group" data-caption class="fancybox"><img src="/2020/05/20/attention/5.png" alt title></a></p><h2 id="attention的优点"><a class="markdownIt-Anchor" href="#attention的优点"></a> attention的优点：</h2><ol><li>解决了梯度问题</li><li><strong>可解释性</strong>(深度学习缺乏理论支持，大多参数的选择都是随机调，所以可解释学习也是当前的一个方向）.<br>没有attention，我们无法可视化，无法看到模型的不足点去修改，有了attention我们可以针对性的解决，比如拿一句话<strong>今天天气很好</strong>，我们的模型把今天翻译成了yesterday，那么我们可以看一下今天的attention score，如果很高说明方向是对的，可能是样本数据的问题，如果权重小也就是其他词的权重大了，那么这个模型就是有问题了</li></ol><h2 id="attention的不足"><a class="markdownIt-Anchor" href="#attention的不足"></a> attention的不足：</h2><p>attention in seq2seq的不足：<br>我们这种思路是给每个单词一个权重，我们更希望每个单词是独立的，然而RNN的特性，当前单词又会汇集之前的单词信息，这也是一个矛盾点，</p><ul><li>想法一：g2-g1?来去除冗余信息？当然这是不对的，因为向量的表达相当于是空间中的一个位置，向量的差值没有什么含义，有方向的，方向是不能减的。</li></ul><h1 id="self-attention"><a class="markdownIt-Anchor" href="#self-attention"></a> self-attention</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="自然语言处理" scheme="https://sunxin18.github.io/categories/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86/"/>
    
    
      <category term="attention" scheme="https://sunxin18.github.io/tags/attention/"/>
    
  </entry>
  
  <entry>
    <title>算法优化</title>
    <link href="https://sunxin18.github.io/2020/05/15/optimize/"/>
    <id>https://sunxin18.github.io/2020/05/15/optimize/</id>
    <published>2020-05-15T05:44:11.000Z</published>
    <updated>2020-05-31T10:24:17.169Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本系列将探讨算法的优化。</p><h1 id="时间复杂度对算法的选择"><a class="markdownIt-Anchor" href="#时间复杂度对算法的选择"></a> 时间复杂度对算法的选择</h1><p><a href="/2020/05/15/optimize/1.png" data-fancybox="group" data-caption class="fancybox"><img src="/2020/05/15/optimize/1.png" alt title></a></p><h1 id="时间优化"><a class="markdownIt-Anchor" href="#时间优化"></a> 时间优化</h1><h2 id="思维的改进"><a class="markdownIt-Anchor" href="#思维的改进"></a> 思维的改进</h2><p>LCP08.剧情触发时间<br>最开始的想法同时考虑三个属性，每到新的一天就遍历requirements数组，看能否有剧情出发，果不其然超时了，最后两个样例没通过<br>之后进行改进。<br>首先如果只考虑一种属性，显然我们只需要计算每一天的属性情况，最后对于所有的requirements 都在属性列表中进行二分查找（现在只有一种属性了)，就能知道他是在哪一天完成的了。<br>但这道题实际上，每一种属性的满足是互相独立的。<br>简单来说，对于一个剧情要求 (C, R, H) 来说，假设 C 要求是在第 x 天满足的，R要求是在第 y 天满足的，H 要求是在第 z 天满足的。那么该剧情的满足时间为：<br>t=max(x,y,z)</p><p>原始代码：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; getTriggerTime(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; increase, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; requirements) &#123;</span><br><span class="line">        <span class="keyword">int</span> res[<span class="number">3</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> day=increase.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;end(requirements.size(),<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;day;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">3</span>;j++)&#123;</span><br><span class="line">                res[j]+=increase[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> m=<span class="number">0</span>;m&lt;requirements.size();m++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(end[m]!=<span class="number">-1</span>)<span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">int</span> count1=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> n=<span class="number">0</span>;n&lt;<span class="number">3</span>;n++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(res[n]&gt;=requirements[m][n])</span><br><span class="line">                        count++;</span><br><span class="line">                    <span class="keyword">if</span>(requirements[m][n]==<span class="number">0</span>)</span><br><span class="line">                        count1++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(count1==<span class="number">3</span>)&#123;</span><br><span class="line">                    end[m]=<span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(count==<span class="number">3</span>)</span><br><span class="line">                    end[m]=i+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> end;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><p>改进代码：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; getTriggerTime(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; increase, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; requirements) &#123;</span><br><span class="line"><span class="comment">//将三个属性分开，并初始化为0</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; C(increase.size() + <span class="number">1</span>, <span class="number">0</span>);<span class="comment">//初始化</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; R(increase.size() + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; H(increase.size() + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; increase.size(); ++i)<span class="comment">//算和</span></span><br><span class="line">&#123;</span><br><span class="line">C[i + <span class="number">1</span>] = C[i] + increase[i][<span class="number">0</span>];</span><br><span class="line">R[i + <span class="number">1</span>] = R[i] + increase[i][<span class="number">1</span>];</span><br><span class="line">H[i + <span class="number">1</span>] = H[i] + increase[i][<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret;<span class="comment">//返回值</span></span><br><span class="line"><span class="keyword">int</span> maxlen = C.size();<span class="comment">//若lower_bound中没找到则返回last，此时求的差是数组长度</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; requirements.size(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//lower_bound 返回大于等于查找元素的位置</span></span><br><span class="line"><span class="keyword">int</span> lbc = lower_bound(C.begin(), C.end(), requirements[i][<span class="number">0</span>]) - C.begin();</span><br><span class="line"><span class="keyword">int</span> lbr = lower_bound(R.begin(), R.end(), requirements[i][<span class="number">1</span>]) - R.begin();</span><br><span class="line"><span class="keyword">int</span> lbh = lower_bound(H.begin(), H.end(), requirements[i][<span class="number">2</span>]) - H.begin();</span><br><span class="line"><span class="keyword">if</span> (lbc == maxlen || lbr == maxlen || lbh == maxlen)<span class="comment">//没触发</span></span><br><span class="line">&#123;</span><br><span class="line">ret.emplace_back(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">ret.emplace_back(max(max(lbc, lbr), lbh));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><h1 id="代码简洁优化"><a class="markdownIt-Anchor" href="#代码简洁优化"></a> 代码简洁优化</h1><ol start="1455"><li>检查单词是否为句中其他单词的前缀<br>使用字符串流</li></ol><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">```c++</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">isPrefixOfWord</span><span class="params">(<span class="built_in">string</span> sentence, <span class="built_in">string</span> searchWord)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">stringstream</span> <span class="title">ssin</span><span class="params">(sentence)</span></span>;</span><br><span class="line">        <span class="built_in">string</span> word;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">1</span>;ssin&gt;&gt;word;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(word.substr(<span class="number">0</span>,searchWord.size())==searchWord)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><p>判断是否包括元音字母？<br>最原始思路</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">de</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="string">'a'</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="string">'e'</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="string">'i'</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="string">'o'</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="string">'u'</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">de(c)</span><br></pre></td></tr></table></figure></div><p>哈希表:</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unordered_set</span>&lt;<span class="keyword">char</span>&gt;S(&#123;<span class="string">'a'</span>,<span class="string">'e'</span>,<span class="string">'i'</span>,<span class="string">'o'</span>,<span class="string">'u'</span>&#125;);</span><br><span class="line">S.count(c);</span><br><span class="line"><span class="comment">//0就是不包含，1就是包含</span></span><br></pre></td></tr></table></figure></div><p>参考资料：<br><a href="https://www.acwing.com/blog/content/32/" target="_blank" rel="noopener">https://www.acwing.com/blog/content/32/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="算法编程" scheme="https://sunxin18.github.io/categories/%E7%AE%97%E6%B3%95%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="优化" scheme="https://sunxin18.github.io/tags/%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>leetcode多函数编程</title>
    <link href="https://sunxin18.github.io/2020/05/15/function/"/>
    <id>https://sunxin18.github.io/2020/05/15/function/</id>
    <published>2020-05-15T02:07:30.000Z</published>
    <updated>2020-05-20T14:09:25.457Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ol start="1396"><li>设计地铁系统<br>这道题主要思考点在于容器设计，in容器来记录编号id的人的（上车站点和上车时间）–pair，然后不需要额外用out来记录下车，直接在checkout函数里计算一下id的人上下车时间差做好记录，最后直接求mean就可以啦</li></ol><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UndergroundSystem</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">using</span> pii = pair&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, pii&gt; in;</span><br><span class="line">    <span class="built_in">map</span>&lt;pair&lt;<span class="built_in">string</span>,<span class="built_in">string</span>&gt;, <span class="keyword">int</span>&gt; a, b;</span><br><span class="line">    </span><br><span class="line">    UndergroundSystem() &#123;</span><br><span class="line">        in.clear();</span><br><span class="line">        a.clear();</span><br><span class="line">        b.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">checkIn</span><span class="params">(<span class="keyword">int</span> id, <span class="built_in">string</span> stationName, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        in[id] = &#123;stationName, t&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">checkOut</span><span class="params">(<span class="keyword">int</span> id, <span class="built_in">string</span> stationName, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> [ss, tt] = in[id];</span><br><span class="line">        <span class="keyword">int</span> time = t-tt;</span><br><span class="line">        a[&#123;ss,stationName&#125;] ++;</span><br><span class="line">        b[&#123;ss,stationName&#125;] += time;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getAverageTime</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">double</span>)b[&#123;s,t&#125;]/a[&#123;s,t&#125;];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="算法编程" scheme="https://sunxin18.github.io/categories/%E7%AE%97%E6%B3%95%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="多函数编程" scheme="https://sunxin18.github.io/tags/%E5%A4%9A%E5%87%BD%E6%95%B0%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Binary Search</title>
    <link href="https://sunxin18.github.io/2020/05/09/Binary-Search/"/>
    <id>https://sunxin18.github.io/2020/05/09/Binary-Search/</id>
    <published>2020-05-09T12:10:33.000Z</published>
    <updated>2020-06-04T03:19:10.403Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>二分搜索核心思想：把<strong>待搜索区间</strong>分为<strong>有目标元素的区间</strong>和<strong>不包含目标元素的区间</strong>，排除掉<strong>不包含目标元素的区间</strong>的区间，剩下就是<strong>有目标元素的区间</strong>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>bert</title>
    <link href="https://sunxin18.github.io/2020/05/08/bert/"/>
    <id>https://sunxin18.github.io/2020/05/08/bert/</id>
    <published>2020-05-08T05:07:15.000Z</published>
    <updated>2020-06-29T01:35:48.793Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="pretrain-embedding"><a class="markdownIt-Anchor" href="#pretrain-embedding"></a> pretrain embedding</h1><ol><li>word2vec 不能表示单词在不同场景下不同意思，希望能得到上下文相关的表示法</li></ol><h1 id="learn-contextualized-embedding"><a class="markdownIt-Anchor" href="#learn-contextualized-embedding"></a> learn contextualized embedding</h1><ol><li>language model/lstm+unsupervised data</li></ol><p>自编码；回归任务</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>华为云口罩配送大赛经验分享</title>
    <link href="https://sunxin18.github.io/2020/05/08/huawei/"/>
    <id>https://sunxin18.github.io/2020/05/08/huawei/</id>
    <published>2020-05-08T01:06:27.000Z</published>
    <updated>2020-05-08T08:13:41.249Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>比赛链接：<a href="https://competition.huaweicloud.com/information/1000037176/introduction" target="_blank" rel="noopener">https://competition.huaweicloud.com/information/1000037176/introduction</a></p><h3 id="赛题分析"><a class="markdownIt-Anchor" href="#赛题分析"></a> 赛题分析：</h3><ol><li>地图大小为12×12，需求点固定为5个，配送目标是将所有需求点的需求进行满足，配送过程中会随机生成捐赠小区</li><li>纯命令行交互，使用标准I/O作为命令（S/R/G）和移动方向(E/W/S/N)的传递途径</li><li>在1000张地图上测试</li></ol><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><ol><li>我没有做太多的思考，思路也很容易理解，首先先到的就是greedy策略，每次都选择当前最好的选择，当然这只能考虑到局部最优，但最后结果还不错，能排进前二十。</li><li>每次配送的时候都优先选择离当前最近的需求点配送，取货的时候给每个捐赠小区一个ranking，就按照捐赠数量/距离来做，试了一下距离的平方结果不如绝对值。</li><li>配送有几种情况需要考虑：<ul><li>车上口罩为0，那么肯定要去取货，那么就按ranking来选择</li><li>车上口罩为100，那么肯定要去送货，就选择最近的，因为最远的周边可能后续会生成捐赠小区</li><li>接下的两种情况最难考虑，就是送完一个小区或者刚取完一些车上还剩，那么是去接着送别的小区，还是取货呢？我的想法就是也写一个ranking比较，送货和取货的价值比较，但要考虑一些特殊情况，如果此时的货够最近的需求小区a那么就去送，如果此时的货加上离aranking最高的取货点足够那么就直接去取货点取货，当然这考虑非常不够，很需要改进,可以学习依一下别的选手的思路。</li></ul></li></ol><h3 id="代码分析"><a class="markdownIt-Anchor" href="#代码分析"></a> 代码分析</h3><p>下面对我的代码进行讲解，用python写的.<br>load:当前装载量<br>target：目标地<br>R(字典)：对应坐标的货量，需求点就是负值，捐赠和仓库就是正值，<em>坐标要用元组，不是列表</em></p><h4 id="主函数"><a class="markdownIt-Anchor" href="#主函数"></a> 主函数</h4><h5 id="需求小区仓库初始化"><a class="markdownIt-Anchor" href="#需求小区仓库初始化"></a> 需求小区仓库初始化</h5><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    new_string=input()</span><br><span class="line">    s_list=new_string.split()</span><br><span class="line">    S=(int(s_list[<span class="number">1</span>]),int(s_list[<span class="number">2</span>]))</span><br><span class="line">    R=&#123;&#125;</span><br><span class="line">    R[(int(s_list[<span class="number">1</span>]),int(s_list[<span class="number">2</span>]))]=<span class="number">100</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">5</span>):</span><br><span class="line">        new_string=input()</span><br><span class="line">        r_list=new_string.split()</span><br><span class="line">        R[(int(r_list[<span class="number">1</span>]),int(r_list[<span class="number">2</span>]))]=int(r_list[<span class="number">3</span>])</span><br><span class="line">    p=list(S)</span><br><span class="line">    load=<span class="number">0</span>             <span class="comment">#初始化装载量为0</span></span><br><span class="line">    target=S</span><br></pre></td></tr></table></figure></div><h5 id="选择每次到达小区或者捐赠点就行下一步的选择"><a class="markdownIt-Anchor" href="#选择每次到达小区或者捐赠点就行下一步的选择"></a> 选择（每次到达小区或者捐赠点就行下一步的选择)</h5><p>这里我加入了一个配送时如果有顺路的捐赠小区，那就去取一下</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        P=tuple(p)</span><br><span class="line">        <span class="keyword">if</span> P == S:</span><br><span class="line">            load = <span class="number">100</span></span><br><span class="line">            target = choose_na_target(p)</span><br><span class="line">        <span class="keyword">elif</span> P <span class="keyword">in</span> R.keys():</span><br><span class="line">            sum=load+R[P]</span><br><span class="line">            <span class="keyword">if</span> R[P] &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> sum&lt;<span class="number">0</span>:</span><br><span class="line">                    load=<span class="number">0</span></span><br><span class="line">                    R[P]=sum</span><br><span class="line">                    <span class="keyword">if</span> R[closest(p)] &gt;= -R[P]:</span><br><span class="line">                        target = closest(p)</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        target= choose_target(p)        <span class="comment">#车空就去送取货</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">del</span> R[P]</span><br><span class="line">                    <span class="keyword">if</span> len(R)==<span class="number">0</span>:</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                    <span class="keyword">if</span> min(R.values())&gt;<span class="number">0</span>:</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                    load=sum</span><br><span class="line">                    target1 = choose_na_target(p)</span><br><span class="line">                    target2 = choose_target(p)</span><br><span class="line">                    target3 = choose_target(target1)</span><br><span class="line">                    <span class="keyword">if</span> load &gt;= -R[target1]: </span><br><span class="line">                        target = target1</span><br><span class="line">                    <span class="keyword">elif</span> load + R[target3] &gt;= -R[target1]:</span><br><span class="line">                        target = target3</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        target =  com_value(p ,target1,target2)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> sum &gt; <span class="number">100</span>:</span><br><span class="line">                    load=<span class="number">100</span></span><br><span class="line">                    R[P]=sum<span class="number">-100</span></span><br><span class="line">                    target = choose_na_target(p)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">del</span> R[P]</span><br><span class="line">                    load=sum</span><br><span class="line">                    target1 = choose_na_target(p)</span><br><span class="line">                    target2 = choose_target(p)</span><br><span class="line">                    <span class="keyword">if</span> load &gt;= -R[target1]: </span><br><span class="line">                        target = target1</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        target =  com_value(p ,target1,target2)</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> R.keys():<span class="comment">#顺路就去取</span></span><br><span class="line">                <span class="keyword">if</span> R[k] &gt; <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">if</span>(k[<span class="number">0</span>]&gt;=target[<span class="number">0</span>] <span class="keyword">and</span>  k[<span class="number">0</span>]&lt;=p[<span class="number">0</span>]) <span class="keyword">or</span> (k[<span class="number">0</span>]&lt;=target[<span class="number">0</span>] <span class="keyword">and</span>  k[<span class="number">0</span>]&gt;=p[<span class="number">0</span>]):</span><br><span class="line">                        <span class="keyword">if</span>(k[<span class="number">1</span>]&gt;=target[<span class="number">1</span>] <span class="keyword">and</span>  k[<span class="number">1</span>]&lt;=p[<span class="number">1</span>]) <span class="keyword">or</span> (k[<span class="number">1</span>]&lt;=target[<span class="number">1</span>] <span class="keyword">and</span>  k[<span class="number">1</span>]&gt;=p[<span class="number">1</span>]):</span><br><span class="line">                            target = k</span><br></pre></td></tr></table></figure></div><h5 id="读取命令行输入"><a class="markdownIt-Anchor" href="#读取命令行输入"></a> 读取命令行输入</h5><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">new_string=input()</span><br><span class="line">        <span class="keyword">if</span> new_string==<span class="string">'G'</span>:          <span class="comment">#读取到行动的命令，向target移动</span></span><br><span class="line">            p,next_step=step(p,target)</span><br><span class="line">            print(next_step)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            r_list=new_string.split()</span><br><span class="line">            <span class="keyword">if</span> p[<span class="number">0</span>] == int(r_list[<span class="number">1</span>]) <span class="keyword">and</span> p[<span class="number">1</span>] == int(r_list[<span class="number">2</span>]):                   <span class="comment">#空投贴脸hhh</span></span><br><span class="line">                <span class="keyword">if</span> load + int(r_list[<span class="number">3</span>]) &lt;= <span class="number">100</span>:</span><br><span class="line">                    load = load + int(r_list[<span class="number">3</span>])</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    R[(int(r_list[<span class="number">1</span>]),int(r_list[<span class="number">2</span>]))]=int(r_list[<span class="number">3</span>])<span class="number">-100</span>+load</span><br><span class="line">                    load = <span class="number">100</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                R[(int(r_list[<span class="number">1</span>]),int(r_list[<span class="number">2</span>]))]=int(r_list[<span class="number">3</span>])           <span class="comment">#更新一下选择</span></span><br><span class="line">                <span class="keyword">if</span>  R[target] &gt; <span class="number">0</span>:     <span class="comment">#注意R里没有S</span></span><br><span class="line">                    target = choose_target(p)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    cur_target = (int(r_list[<span class="number">1</span>]),int(r_list[<span class="number">2</span>]))</span><br><span class="line">                    target = com_value(p ,target,cur_target)</span><br></pre></td></tr></table></figure></div><h5 id="移动函数"><a class="markdownIt-Anchor" href="#移动函数"></a> 移动函数</h5><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">step</span><span class="params">(pos,to)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> pos[<span class="number">0</span>]&lt;to[<span class="number">0</span>]:</span><br><span class="line">        pos[<span class="number">0</span>]=pos[<span class="number">0</span>]+<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> pos,<span class="string">'S'</span></span><br><span class="line">    <span class="keyword">elif</span> pos[<span class="number">0</span>]&gt;to[<span class="number">0</span>]:</span><br><span class="line">        pos[<span class="number">0</span>]=pos[<span class="number">0</span>]<span class="number">-1</span></span><br><span class="line">        <span class="keyword">return</span> pos,<span class="string">'N'</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> pos[<span class="number">1</span>]&lt;to[<span class="number">1</span>]:</span><br><span class="line">            pos[<span class="number">1</span>]=pos[<span class="number">1</span>]+<span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> pos,<span class="string">'E'</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            pos[<span class="number">1</span>]=pos[<span class="number">1</span>]<span class="number">-1</span></span><br><span class="line">            <span class="keyword">return</span> pos,<span class="string">'W'</span></span><br></pre></td></tr></table></figure></div><h5 id="选择捐赠小区和需求小区"><a class="markdownIt-Anchor" href="#选择捐赠小区和需求小区"></a> 选择捐赠小区和需求小区</h5><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">choose_na_target</span><span class="params">(pos)</span>:</span></span><br><span class="line">    na_distance=<span class="number">0</span></span><br><span class="line">    <span class="keyword">global</span> load</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> R.keys():</span><br><span class="line">        <span class="keyword">if</span> R[k] &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> k[<span class="number">0</span>]==pos[<span class="number">0</span>] <span class="keyword">and</span> k[<span class="number">1</span>]==pos[<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            cur_dis2 = <span class="number">1</span>/ (abs(pos[<span class="number">0</span>]-k[<span class="number">0</span>])+abs(pos[<span class="number">1</span>]-k[<span class="number">1</span>])+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> cur_dis2 &gt; na_distance:</span><br><span class="line">                na_distance = cur_dis2</span><br><span class="line">                tar = k</span><br><span class="line">    <span class="keyword">return</span> tar</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">choose_target</span><span class="params">(pos)</span>:</span></span><br><span class="line">    po_distance=<span class="number">0</span></span><br><span class="line">    <span class="keyword">global</span> load</span><br><span class="line">    distance = (<span class="number">100</span>-load)/ (abs(pos[<span class="number">0</span>]-S[<span class="number">0</span>])+abs(pos[<span class="number">1</span>]-S[<span class="number">1</span>])+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> R.keys():</span><br><span class="line">        <span class="keyword">if</span> R[k] &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> k[<span class="number">0</span>]==pos[<span class="number">0</span>] <span class="keyword">and</span> k[<span class="number">1</span>]==pos[<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> R[k] + load &gt; <span class="number">100</span>:</span><br><span class="line">                cur_dis1 = (<span class="number">100</span>-load)/ (abs(pos[<span class="number">0</span>]-k[<span class="number">0</span>])+abs(pos[<span class="number">1</span>]-k[<span class="number">1</span>])+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur_dis1 = R[k] / (abs(pos[<span class="number">0</span>] - k[<span class="number">0</span>]) + abs(pos[<span class="number">1</span>] - k[<span class="number">1</span>])+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> cur_dis1 &gt; po_distance:</span><br><span class="line">                po_distance = cur_dis1</span><br><span class="line">                tar =k   </span><br><span class="line">    <span class="keyword">if</span>  po_distance&gt; distance:</span><br><span class="line">        <span class="keyword">return</span> tar </span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> S</span><br></pre></td></tr></table></figure></div><h5 id="捐赠小区和需求小区的比较ranking"><a class="markdownIt-Anchor" href="#捐赠小区和需求小区的比较ranking"></a> 捐赠小区和需求小区的比较ranking</h5><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">com_value</span><span class="params">(pos,target1,target2)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> target</span><br><span class="line">    <span class="keyword">if</span> load &lt; -R[target1]:</span><br><span class="line">        cur_value1 = load</span><br><span class="line">    <span class="keyword">else</span>: </span><br><span class="line">        cur_value1 = -R[target1]</span><br><span class="line">    value1 = cur_value1 / (abs(pos[<span class="number">0</span>]-target1[<span class="number">0</span>])+abs(pos[<span class="number">1</span>]-target1[<span class="number">1</span>])+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> load +R[target2] &gt; <span class="number">100</span>:</span><br><span class="line">        cur_value2 = <span class="number">100</span> -load</span><br><span class="line">    <span class="keyword">else</span>: </span><br><span class="line">        cur_value2 = R[target2]</span><br><span class="line">    value2 = cur_value2 / (abs(pos[<span class="number">0</span>]-target2[<span class="number">0</span>])+abs(pos[<span class="number">1</span>]-target2[<span class="number">1</span>])+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> value1 &gt;value2:</span><br><span class="line">        <span class="keyword">return</span> target1</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> target2</span><br></pre></td></tr></table></figure></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="比赛" scheme="https://sunxin18.github.io/tags/%E6%AF%94%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title>transformer</title>
    <link href="https://sunxin18.github.io/2020/05/01/transformer/"/>
    <id>https://sunxin18.github.io/2020/05/01/transformer/</id>
    <published>2020-05-01T01:51:27.000Z</published>
    <updated>2020-10-12T03:00:30.262Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>seq2seq主要有下面两个不足：</p><ul><li>long—term dependency 会出现梯度消失或者爆炸</li><li>只能串行 时序的模型，后面的运算必须依赖于前面的运算<br>我们知道同一个单词可能在不同的语境中可能有不同的意思也就是需要不同的向量表达，这个表达依赖于上下文的意思，其他单词也影响着这个单词的意思，<br>transformer就改进了这块的不足。</li></ul><h2 id="transformer的优点"><a class="markdownIt-Anchor" href="#transformer的优点"></a> transformer的优点</h2><p>RNN会将它已经处理过的前面的所有单词/向量的表示与它正在处理的当前单词/向量结合起来。而自注意力机制会将所有相关单词的理解融入到我们正在处理的单词中。</p><h2 id="encoder"><a class="markdownIt-Anchor" href="#encoder"></a> Encoder</h2><p><a href="/2020/05/01/transformer/8.png" data-fancybox="group" data-caption class="fancybox"><img src="/2020/05/01/transformer/8.png" alt title></a><br>encoder 主要有两部分部分，一个self-attention另一个就是全连接网络，self-attention进行不同单词之间信息的交互，具体下面来讲，而全连接网络就是对每个单词进行的转换，也就是乘上一个矩阵再加上偏置，然后再加上激活函数。<br>所以encoder主要再self-attention<br>首先输入就是每个单词的embedding，比如可以是glove训练出来的，然后有三个参数矩阵，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>W</mi><mi>o</mi></msup><mo separator="true">,</mo><msup><mi>W</mi><mi>k</mi></msup><mo separator="true">,</mo><msup><mi>W</mi><mi>v</mi></msup></mrow><annotation encoding="application/x-tex">W^{o},W^{k},W^{v}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.043548em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">o</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span></span></span></span></span></span></span></span></span></span></span></span>,这是共享的参数矩阵，然后输入向量分别与三个矩阵相乘，得到三个向量，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>q</mi><mn>1</mn><mo separator="true">,</mo><mi>k</mi><mn>1</mn><mo separator="true">,</mo><mi>v</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">q1,k1,v1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord">1</span></span></span></span>,这里的向量是一个比原始embedding向量更加低维的表达<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>q</mi><mn>1</mn><mo>⋅</mo><mi>k</mi><mn>1</mn><mo separator="true">,</mo><mi>q</mi><mn>1</mn><mo>⋅</mo><mi>k</mi><mn>2</mn><mo separator="true">,</mo><mi>q</mi><mn>1</mn><mo>⋅</mo><mi>k</mi><mn>3...</mn></mrow><annotation encoding="application/x-tex">q1 \cdot k1,q1 \cdot k2,q1 \cdot k3...</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">3</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span></span></span></span>,这就是两个单词的attention，比如其中两个值是112、96，如果我们直接用和的归一化<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mn>112</mn><mrow><mn>112</mn><mo>+</mo><mn>96</mn></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{112}{112+96}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2484389999999999em;vertical-align:-0.403331em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">1</span><span class="mord mtight">2</span><span class="mbin mtight">+</span><span class="mord mtight">9</span><span class="mord mtight">6</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">1</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.403331em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mn>96</mn><mrow><mn>112</mn><mo>+</mo><mn>96</mn></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{96}{112+96}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2484389999999999em;vertical-align:-0.403331em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">1</span><span class="mord mtight">2</span><span class="mbin mtight">+</span><span class="mord mtight">9</span><span class="mord mtight">6</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">9</span><span class="mord mtight">6</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.403331em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>则这两个值会比较接近，梯度更稳定，如果直接送到softmax，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><msup><mi>e</mi><mn>112</mn></msup><mrow><msup><mi>e</mi><mn>112</mn></msup><mo>+</mo><msup><mi>e</mi><mn>96</mn></msup></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{e^{112}}{e^{112}+e^{96}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.4212509999999998em;vertical-align:-0.403331em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01792em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7463142857142857em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">1</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mbin mtight">+</span><span class="mord mtight"><span class="mord mathdefault mtight">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7463142857142857em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">9</span><span class="mord mtight">6</span></span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913142857142857em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">1</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.403331em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><msup><mi>e</mi><mn>96</mn></msup><mrow><msup><mi>e</mi><mn>112</mn></msup><mo>+</mo><msup><mi>e</mi><mn>96</mn></msup></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{e^{96}}{e^{112}+e^{96}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.4212509999999998em;vertical-align:-0.403331em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01792em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7463142857142857em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">1</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mbin mtight">+</span><span class="mord mtight"><span class="mord mathdefault mtight">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7463142857142857em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">9</span><span class="mord mtight">6</span></span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913142857142857em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">9</span><span class="mord mtight">6</span></span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.403331em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>,这两个值就会分别接近0和1了，没有区分度，所以这里我们对他除以一个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msqrt><mi>d</mi></msqrt></mrow><annotation encoding="application/x-tex">\sqrt{d}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.04em;vertical-align:-0.10777999999999999em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.93222em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord mathdefault">d</span></span></span><span style="top:-2.89222em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width="400em" height="1.08em" viewbox="0 0 400000 1080" preserveaspectratio="xMinYMin slice"><path d="M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z M834 80H400000v40H845z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.10777999999999999em;"><span></span></span></span></span></span></span></span></span>,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span></span></span></span>就是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span></span></span></span>的维度（论文里是8，也就是64维度的求根值）再进行softmax，然后对每个atteention值(这些值也可以当作是一个score向量)分别与对应的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">v_{i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>相乘得到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>z</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">z1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mord">1</span></span></span></span>,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>z</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">z1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mord">1</span></span></span></span>,具体可见下图，<br><a href="/2020/05/01/transformer/9.png" data-fancybox="group" data-caption class="fancybox"><img src="/2020/05/01/transformer/9.png" alt title></a><br>这就相当于考虑了整个句子了，这个整体就是一层的encoder block.</p><h3 id="positional-encoding"><a class="markdownIt-Anchor" href="#positional-encoding"></a> positional encoding</h3><p>主要为了体现距离位置的信息，encoding向量之间点积越大代表距离越近<br><a href="/2020/05/01/transformer/11.png" data-fancybox="group" data-caption class="fancybox"><img src="/2020/05/01/transformer/11.png" alt title></a></p><h2 id="矩阵化操作"><a class="markdownIt-Anchor" href="#矩阵化操作"></a> 矩阵化操作</h2><p>首先是矩阵化求<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>q</mi><mo separator="true">,</mo><mi>k</mi><mo separator="true">,</mo><mi>v</mi></mrow><annotation encoding="application/x-tex">q,k,v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span>看下面图很容易理解<br><a href="/2020/05/01/transformer/2.png" data-fancybox="group" data-caption class="fancybox"><img src="/2020/05/01/transformer/2.png" alt title></a><br>每个attention我们是通过<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>q</mi><mn>1</mn><mo>⋅</mo><mi>k</mi><mn>1</mn><mo separator="true">,</mo><mi>q</mi><mn>1</mn><mo>⋅</mo><mi>k</mi><mn>2</mn><mo separator="true">,</mo><mi>q</mi><mn>1</mn><mo>⋅</mo><mi>k</mi><mn>3...</mn></mrow><annotation encoding="application/x-tex">q1 \cdot k1,q1 \cdot k2,q1 \cdot k3...</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">3</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span></span></span></span>，我们就可以个把<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mn>1</mn><mo separator="true">,</mo><mi>k</mi><mn>2..</mn></mrow><annotation encoding="application/x-tex">k1,k2..</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">2</span><span class="mord">.</span><span class="mord">.</span></span></span></span>堆积起来到一个矩阵和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>q</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">q1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mord">1</span></span></span></span>进行相乘得到attention向量<br><a href="/2020/05/01/transformer/3.png" data-fancybox="group" data-caption class="fancybox"><img src="/2020/05/01/transformer/3.png" alt title></a><br>可以再进一步矩阵化，我们把<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>q</mi><mn>1</mn><mo separator="true">,</mo><mi>q</mi><mn>2...</mn></mrow><annotation encoding="application/x-tex">q1,q2...</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mord">2</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span></span></span></span>也堆积起来到一个矩阵<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span></span></span></span><br><a href="/2020/05/01/transformer/4.png" data-fancybox="group" data-caption class="fancybox"><img src="/2020/05/01/transformer/4.png" alt title></a><br>然后得到了attention score矩阵，每一个值都是两两个单词得到的attention值，除以<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msqrt><mi>d</mi></msqrt></mrow><annotation encoding="application/x-tex">\sqrt{d}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.04em;vertical-align:-0.10777999999999999em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.93222em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord mathdefault">d</span></span></span><span style="top:-2.89222em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width="400em" height="1.08em" viewbox="0 0 400000 1080" preserveaspectratio="xMinYMin slice"><path d="M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z M834 80H400000v40H845z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.10777999999999999em;"><span></span></span></span></span></span></span></span></span>，再对每一列求softmax。<br>下面是对第一个单词的score向量分别与<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi><mn>1</mn><mo separator="true">,</mo><mi>v</mi><mn>2</mn><mo separator="true">,</mo><mi>v</mi><mn>3...</mn></mrow><annotation encoding="application/x-tex">v1,v2,v3...</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord">3</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span></span></span></span>相乘得到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>z</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">z1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mord">1</span></span></span></span>(图里是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">b1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span><span class="mord">1</span></span></span></span>),这里把<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span>堆积起来，最终得到整个self-attention layer输出O矩阵<br><a href="/2020/05/01/transformer/5.png" data-fancybox="group" data-caption class="fancybox"><img src="/2020/05/01/transformer/5.png" alt title></a><br>总结起来就是：<br><a href="/2020/05/01/transformer/6.png" data-fancybox="group" data-caption class="fancybox"><img src="/2020/05/01/transformer/6.png" alt title></a></p><h2 id="multi-head-attention"><a class="markdownIt-Anchor" href="#multi-head-attention"></a> multi-head attention</h2><p>Multi-Head Attention相当于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">h</span></span></span></span>个不同的self-attention的集成（ensemble）,然后将所有头得到的特征矩阵<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>Z</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">Z_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>拼接起来,经过一层全连接后得到输出最终的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Z</mi></mrow><annotation encoding="application/x-tex">Z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span></span></span></span>.</p><h2 id="优缺点"><a class="markdownIt-Anchor" href="#优缺点"></a> 优缺点</h2><p>优点：</p><ol><li>每一层计算复杂度比较低</li><li>比较利于并行计算</li><li>模型可解释性比较高</li></ol><p>缺点：</p><ol><li>有些RNN可以轻易解决的问题transformer没做到，比如复制string，或者推理时遇到的sequence长度比训练时更长(因为碰到了没见过的position embedding)</li><li>RNN图灵完备，而transformer不是</li></ol><h2 id="疑惑"><a class="markdownIt-Anchor" href="#疑惑"></a> 疑惑</h2><p>attention考虑到了所有两两单词，无论是邻居还是远在天涯，但这样没有考虑单词的顺序了？<br>原始文章：加上位置向量，这不是学出来的参数，是人工加上的<br><a href="/2020/05/01/transformer/7.png" data-fancybox="group" data-caption class="fancybox"><img src="/2020/05/01/transformer/7.png" alt title></a><br>transformer和lstm可以说是一个并列的模型，也就是一定意义上可以相互替代</p><p>原论文：<a href="https://arxiv.org/abs/1706.03762" target="_blank" rel="noopener">https://arxiv.org/abs/1706.03762</a><br>参考文献：<a href="https://jalammar.github.io/illustrated-transformer/" target="_blank" rel="noopener">https://jalammar.github.io/illustrated-transformer/</a> 翻译：<a href="https://blog.csdn.net/longxinchen_ml/article/details/86533005" target="_blank" rel="noopener">https://blog.csdn.net/longxinchen_ml/article/details/86533005</a><br>参考视频:<br>台大李宏毅老师-深度学习HLP</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="自然语言处理" scheme="https://sunxin18.github.io/categories/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86/"/>
    
    
      <category term="transformer" scheme="https://sunxin18.github.io/tags/transformer/"/>
    
  </entry>
  
</feed>

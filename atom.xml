<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>lalala</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://sunxin18.github.io/"/>
  <updated>2022-01-19T04:01:31.046Z</updated>
  <id>https://sunxin18.github.io/</id>
  
  <author>
    <name>Sunxin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>casapp</title>
    <link href="https://sunxin18.github.io/2022/01/18/casapp/"/>
    <id>https://sunxin18.github.io/2022/01/18/casapp/</id>
    <published>2022-01-18T06:12:28.000Z</published>
    <updated>2022-01-19T04:01:31.046Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="19"><a class="markdownIt-Anchor" href="#19"></a> 1.9</h3><p>超线程，有时称为同时多线程（simultaneous multi-threading），是一项允许一个 CPU 执行多个控制流的技术。它涉及 CPU 某些硬件有多个备份，比如程序计数器和寄存器文件，而其他的硬件部分只有一份，比如执行浮点算术运算的单元。常规的处理器需要大约 20000 个时钟周期做不同线程间的转换，而超线程的处理器可以在单个周期的基础上决定要执行哪一个线程。这使得 CPU 能够更好地利用它的处理资源。比如，假设一个线程必须等到某些数据被装载到高速缓存中，那 CPU 就可以继续去执行另一个线程。举例来说，Intel Core i7 处理器可以让每个核执行两个线程，所以一个 4 核的系统实际上可以并行地执行 8 个线程。</p><h3 id="710"><a class="markdownIt-Anchor" href="#710"></a> 7.10</h3><p>没有任何 <a href="http://libvector.so" target="_blank" rel="noopener">libvector.so</a> 的代码和数据节真的被复制到可执行文件 prog2l 中。反之，链接器复制了一些重定位和符号表信息，它们使得运行时可以解析对 <a href="http://libvector.so" target="_blank" rel="noopener">libvector.so</a> 中代码和数据的引用。</p><p>EOF</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>leetcode373、632 多路归并+堆</title>
    <link href="https://sunxin18.github.io/2022/01/17/heap/"/>
    <id>https://sunxin18.github.io/2022/01/17/heap/</id>
    <published>2022-01-17T12:20:39.000Z</published>
    <updated>2022-01-20T10:06:30.246Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="leetcode-373"><a class="markdownIt-Anchor" href="#leetcode-373"></a> leetcode 373</h2><p>这是一道top k问题，首先从最原始的思路想，可以用双指针暴力枚举所有情况然后取前k个，但这就没有利用好两个数组都是已排序的条件，假设我们已经得到了前n个最小的,那么下一个要考虑的就是这n个数中的每一个的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><msub><mi>a</mi><mi>i</mi></msub><mo separator="true">,</mo><mi>b</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(a_{i},b{i+1})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mord"><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span></span><span class="mclose">)</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><msub><mi>a</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo separator="true">,</mo><mi>b</mi><mi>i</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(a_{i+1},b{i})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mord"><span class="mord mathdefault">i</span></span><span class="mclose">)</span></span></span></span>中最小的那一个，可以用堆来动态的维护当前的最小值并完成多路归并，这里的多路可能还比较缥缈，先考虑一个可能会重复的问题，很明显a[0]+b[0]是最小的，之后有两条路都可以走到a[1]+b[1]这里导致了重复，所以我们可以先把第一列放入堆里，然后进行按每一路动态的游走，所有路的步数和为k次就停止，可见下图<br><a href="/2022/01/17/heap/1.png" data-fancybox="group" data-caption class="fancybox"><img src="/2022/01/17/heap/1.png" alt title></a></p><p>另一个要考虑的问题是，我们堆里存的是索引对，但是是根据数组和来确实排序的，所以要把这些信息都要放进堆里，设计为pair&lt;int, pair&lt;int, int&gt;，即&lt;和，&lt;索引，索引&gt;。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; kSmallestPairs(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        priority_queue&lt;pair&lt;<span class="keyword">int</span>, pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;, <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&gt;, greater&lt;pair&lt;<span class="keyword">int</span>, pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&gt;&gt; heap;</span><br><span class="line">        <span class="keyword">int</span> m = nums1.size();</span><br><span class="line">        <span class="keyword">int</span> n = nums2.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; min(m, k); i++) &#123;</span><br><span class="line">            heap.push(&#123;nums1[i] + nums2[<span class="number">0</span>], &#123;i, <span class="number">0</span>&#125;&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">while</span> (k-- &amp;&amp; !heap.empty()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> p = heap.top();</span><br><span class="line">            heap.pop();</span><br><span class="line">            <span class="keyword">int</span> a  = p.second.first, b = p.second.second;</span><br><span class="line">            <span class="keyword">if</span> (b + <span class="number">1</span> &lt; n) &#123;</span><br><span class="line">                heap.push(&#123;nums1[a]+ nums2[b + <span class="number">1</span>], &#123;a, b + <span class="number">1</span>&#125;&#125;); </span><br><span class="line">            &#125;</span><br><span class="line">            res.emplace_back(<span class="built_in">initializer_list</span>&lt;<span class="keyword">int</span>&gt;&#123;nums1[a], nums2[b]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><p>还有一种官方题解的方法是用lambda表达式来捕获数组直接完成建堆</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> cmp = [&amp;nums1, &amp;nums2](<span class="keyword">const</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &amp; a, <span class="keyword">const</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &amp; b) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums1[a.first] + nums2[a.second] &gt; nums1[b.first] + nums2[b.second];</span><br><span class="line">        &#125;;</span><br><span class="line">priority_queue&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;, <span class="keyword">decltype</span>(cmp)&gt; pq(cmp);</span><br></pre></td></tr></table></figure></div><p>下面解释一下这个优先队列的用法，<br>1.为什么用decltype?<br>优先队列的第三个参是需要指定一个实现了 operator&lt; 操作符的类或者结构体，而lambda是一个值，<br>2.为什么最后还有吧cmp传入构造函数？<br>因为lambda没有默认构造函数的（构造函数和赋值运算符删除，拷贝构造和析构隐试定义</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line"><span class="keyword">int</span> i, j;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node &amp;other) &#123;</span><br><span class="line"><span class="keyword">return</span> x + y &gt; other.x + other.y;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>参考：<a href="https://ask.csdn.net/questions/7399659" target="_blank" rel="noopener">https://ask.csdn.net/questions/7399659</a><br><a href="https://stackoverflow.com/questions/5807735/c-priority-queue-with-lambda-comparator-error" target="_blank" rel="noopener">https://stackoverflow.com/questions/5807735/c-priority-queue-with-lambda-comparator-error</a><br><a href="https://stackoverflow.com/questions/41053232/c-stdpriority-queue-uses-the-lambda-expression" target="_blank" rel="noopener">https://stackoverflow.com/questions/41053232/c-stdpriority-queue-uses-the-lambda-expression</a></p><h2 id="leetcode-632"><a class="markdownIt-Anchor" href="#leetcode-632"></a> leetcode 632</h2><p>这道题可以理解为是从k个列表中分别取一个数，使得这k个数中的最大值与最小值的差最小。同样利用好每个列表都是非递减排的条件，可以基于贪心的思想，首先给每个列表分配一个指针，起始都指向表头，然后用最小堆维护当前k个数的最小值同时维护当前的最大值，<strong>每次移动最小值也就是左边界</strong>，直到有某个列表遍历完成<br>同样采样类似上题的数据结构</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; smallestRange(vector&lt;vector&lt;int&gt;&gt;&amp; nums) &#123; </span><br><span class="line">        priority_queue&lt;pair&lt;int, pair&lt;int, int&gt;&gt;, vector&lt;pair&lt;int, pair&lt;int, int&gt;&gt;&gt;, greater&lt;pair&lt;int, pair&lt;int, int&gt;&gt;&gt;&gt; heap;</span><br><span class="line">        int res =  INT_MAX;</span><br><span class="line">        vector&lt;int&gt; ans(2);</span><br><span class="line">        ans[0] = -1;</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        vector&lt;int&gt; index(n);</span><br><span class="line">        int max_value = 0;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            heap.push(&#123;nums[i][0], &#123;i, 0&#125;&#125;);</span><br><span class="line">            max_value = max(max_value, nums[i][0]);</span><br><span class="line">        &#125;</span><br><span class="line">        while (!heap.empty()) &#123;</span><br><span class="line">            auto top_value = heap.top();</span><br><span class="line">            heap.pop();</span><br><span class="line">            int dis = max_value - top_value.first;</span><br><span class="line">            if (dis &lt; res || (dis == res &amp;&amp; res != INT_MAX &amp;&amp; top_value.first &lt; ans[0])) &#123;</span><br><span class="line">                res = dis;</span><br><span class="line">                ans[0] = top_value.first;</span><br><span class="line">                ans[1] = max_value;</span><br><span class="line">            &#125;</span><br><span class="line">            int a = top_value.second.first;</span><br><span class="line">            int b = top_value.second.second;</span><br><span class="line">            if (b + 1 &gt;= nums[a].size()) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            if (nums[a][b + 1] &gt; max_value) &#123;</span><br><span class="line">                max_value = nums[a][b + 1];</span><br><span class="line">            &#125;</span><br><span class="line">            heap.push(&#123;nums[a][b + 1], &#123;a, b + 1&#125;&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="算法编程" scheme="https://sunxin18.github.io/categories/%E7%AE%97%E6%B3%95%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="多路归并" scheme="https://sunxin18.github.io/tags/%E5%A4%9A%E8%B7%AF%E5%BD%92%E5%B9%B6/"/>
    
      <category term="堆" scheme="https://sunxin18.github.io/tags/%E5%A0%86/"/>
    
  </entry>
  
  <entry>
    <title>双向BFS</title>
    <link href="https://sunxin18.github.io/2021/09/09/two-direction-bfs/"/>
    <id>https://sunxin18.github.io/2021/09/09/two-direction-bfs/</id>
    <published>2021-09-09T12:09:57.000Z</published>
    <updated>2021-09-09T13:09:22.166Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="190字串变换"><a class="markdownIt-Anchor" href="#190字串变换"></a> 190.字串变换</h2><p>概述：如何用最少的次数根据现有规则，将字符串A变为字符串B<br>题目连接：<a href="https://www.acwing.com/problem/content/description/192/" target="_blank" rel="noopener">https://www.acwing.com/problem/content/description/192/</a><br>一个朴素的思想就是，把A字符串的所有能转变规则的地方都转变一次，就相当于从A字符串拓展出几条不同的通路来到达一个新的节点，然后依次类推，最后与B字符串连接，这样的问题其实还是一个最短路的问题，可以用DFS也可以BFS，以BFS为例，假设每次决策数量是 K，那么如果直接BFS，最坏情况下的搜索空间是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>K</mi><mn>10</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(K^{10})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">0</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，如果我们用双向BFS，复杂度可以降到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>2</mn><msup><mi>K</mi><mn>5</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(2K^{5})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">2</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span><br>思路：从初始字符串和结果字符串同时进行bfs，一层的一层的进行，通过判断bfs树的大小来决定下一次bfs拓展哪个方向，用一个map来记录各种枚举的字符串需要几次转换，然后直到两端相遇</p><p>题外话：扩展要一层一层的扩展，只扩展一层中的一部分可能结果不对</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; a;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; b;</span><br><span class="line"><span class="built_in">string</span> A, B;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">extend</span><span class="params">(<span class="built_in">queue</span>&lt;<span class="built_in">string</span>&gt;&amp; q, <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;&amp;da, <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;&amp; db, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;a, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> d = da[q.front()];</span><br><span class="line">    <span class="keyword">while</span> (q.size() &amp;&amp; da[q.front()] == d)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; t.size(); j ++ )</span><br><span class="line">                <span class="keyword">if</span> (t.substr(j, a[i].size()) == a[i])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">string</span> r = t.substr(<span class="number">0</span>, j) + b[i] + t.substr(j + a[i].size());</span><br><span class="line">                    <span class="comment">//string r = t.replace(j, a[i].size(), b[i]);</span></span><br><span class="line">                    <span class="keyword">if</span> (db.count(r)) <span class="keyword">return</span> da[t] + db[r] + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span> (da.count(r)) <span class="keyword">continue</span>;</span><br><span class="line">                    da[r] = da[t] + <span class="number">1</span>;</span><br><span class="line">                    q.push(r);</span><br><span class="line">                &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">11</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (A == B) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="built_in">string</span>&gt; qa, qb;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; da, db;</span><br><span class="line">    qa.push(A);</span><br><span class="line">    qb.push(B);</span><br><span class="line">    da[A] = <span class="number">0</span>, db[B] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!qa.empty() &amp;&amp; !qb.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> t;</span><br><span class="line">        <span class="keyword">if</span> (qa.size() &lt; qb.size()) &#123;</span><br><span class="line">            t = extend(qa, da, db, a, b);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            t = extend(qb, db, da, b, a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (t &lt;= <span class="number">10</span>) <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s1, s2;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; A &gt;&gt; B;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; s1 &gt;&gt; s2) &#123;</span><br><span class="line">        n++;</span><br><span class="line">        a.push_back(s1);</span><br><span class="line">        b.push_back(s2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> t = bfs();</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="number">-1</span>) <span class="built_in">puts</span>(<span class="string">"NO ANSWER!"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; t &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="双向BFS" scheme="https://sunxin18.github.io/tags/%E5%8F%8C%E5%90%91BFS/"/>
    
  </entry>
  
  <entry>
    <title>实现一个简单的智能指针</title>
    <link href="https://sunxin18.github.io/2021/08/09/realizze-shared-ptr/"/>
    <id>https://sunxin18.github.io/2021/08/09/realizze-shared-ptr/</id>
    <published>2021-08-09T01:29:12.000Z</published>
    <updated>2021-08-09T01:50:49.021Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>智能指针主要是做了两件事情：</p><ol><li>申请内存，我们用模板指针 T* ptr</li><li>另一个进行计数并销毁清理对象<br>注意多个智能指针里的ptr可能会指向同一快内存，所以计数的变量也是要同步的，在这里我们用一个指针int* count来计数，每次新建一个共享指针就对count进行浅拷贝，这样多个指针指针就能同步进行更新计数了</li></ol><p>当我们重载operator=的时候，要注意如果原来的共享指针已经有对象，需要将原来的引用计数减一并判断是否需要释放内存</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">S_ptr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    S_ptr();</span><br><span class="line">    S_ptr(T *p);</span><br><span class="line">    ~S_ptr();</span><br><span class="line">    S_ptr(<span class="keyword">const</span> S_ptr&lt;T&gt; &amp;org);</span><br><span class="line">    S_ptr&lt;T&gt;&amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> S_ptr&lt;T&gt; &amp;org);</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_count</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> *use_count;</span><br><span class="line">    T *ptr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">S_ptr</span>&lt;T&gt;:</span>:S_ptr() : ptr(), use_count(<span class="keyword">new</span> <span class="keyword">int</span> (<span class="number">1</span>)) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Allocation11"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">S_ptr</span>&lt;T&gt;:</span>:S_ptr(T *p) : ptr(p) &#123;</span><br><span class="line">    use_count = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Allocation22"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">if</span> (use_count == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        p = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Allocation Error"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">S_ptr</span>&lt;T&gt;:</span>:~S_ptr() &#123;</span><br><span class="line">    <span class="keyword">if</span> (--*use_count == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">delete</span> ptr;</span><br><span class="line">        ptr = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">delete</span> use_count;</span><br><span class="line">        use_count = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">S_ptr</span>&lt;T&gt;:</span>:S_ptr(<span class="keyword">const</span> S_ptr&lt;T&gt; &amp;org) &#123;</span><br><span class="line">    ptr = org.ptr;</span><br><span class="line">    use_count = org.use_count;</span><br><span class="line">    (*use_count)++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">S_ptr</span>&lt;T&gt;&amp; <span class="title">S_ptr</span>&lt;T&gt;:</span>:<span class="keyword">operator</span> = (<span class="keyword">const</span> S_ptr &amp;org) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;ptr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (--<span class="keyword">this</span>-&gt;use_count == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">delete</span> <span class="keyword">this</span>-&gt;ptr;</span><br><span class="line">            <span class="keyword">delete</span> <span class="keyword">this</span>-&gt;count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>-&gt;ptr = org.ptr;</span><br><span class="line">        <span class="keyword">this</span>-&gt;use_count = org.use_count;</span><br><span class="line">        (*use_count)++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;   </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">S_ptr</span>&lt;T&gt;:</span>:get_count() &#123;</span><br><span class="line">    <span class="keyword">return</span> *use_count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//S_ptr&lt;string&gt; p1 = new string("hello");</span></span><br><span class="line">    S_ptr&lt;<span class="built_in">string</span>&gt; p1(<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">"hello"</span>));</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; p(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">2</span>));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; p1.get_count() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    S_ptr&lt;<span class="built_in">string</span>&gt; p2(p1);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; p1.get_count() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        S_ptr&lt;<span class="built_in">string</span>&gt; p3(p1);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; p1.get_count() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; p1.get_count() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="C++" scheme="https://sunxin18.github.io/categories/C/"/>
    
    
      <category term="智能指针" scheme="https://sunxin18.github.io/tags/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>static变量的存储与初始化时间</title>
    <link href="https://sunxin18.github.io/2021/08/03/static/"/>
    <id>https://sunxin18.github.io/2021/08/03/static/</id>
    <published>2021-08-03T13:28:28.000Z</published>
    <updated>2021-09-09T12:10:42.884Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="数据段探究"><a class="markdownIt-Anchor" href="#数据段探究"></a> 数据段探究</h2><p>数据段主要分为.bss(Block Started by Symbol)和.data(data segment)段，前者指用来存放程序中未初始化的全局变量的一块内存区域，后者是指用来存放程序中已初始化的全局变量的一块内存区域。<br><strong>text和data段都在可执行文件中（在嵌入式系统里一般是固化在镜像文件中），由系统从可执行文件中加载</strong> ，我们用段代码来确定<br>程序1：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ar[<span class="number">30000</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>程序二：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ar[<span class="number">30000</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>程序一的大小：<br>程序二的大小：</p><h3 id="全局静态变量"><a class="markdownIt-Anchor" href="#全局静态变量"></a> 全局静态变量</h3><p>我们先来看全局的静态变量，我们考虑初始化和未初始化两种情况，很明显他们存在.data段，并且是在程序加载进入main函数之前就初始化了，比如单例模式里的恶汉模式，所以就不必担心多线程问题</p><ul><li>初始化：</li></ul><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> test = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sunxin@sunxin-KLVC-WXX9:~/static$ g++ test.cpp -g</span><br><span class="line">sunxin@sunxin-KLVC-WXX9:~/static$ gdb a.out </span><br><span class="line"></span><br><span class="line">(gdb) info addr test</span><br><span class="line">Symbol &quot;test&quot; is static storage at address 0x201010.</span><br><span class="line">(gdb) info symbol 0x201010</span><br><span class="line">test in section .data</span><br></pre></td></tr></table></figure></div><p>可以看到初始化的静态变量存在.data段，所以是在程序加载进入main函数之前就初始化了，由此也可以联想到单例模式里的恶汉模式，所以就不必担心多线程问题</p><p>如果没有赋值的全局静态变量是初始化在.bss里的：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> test;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(gdb)  info addr test</span><br><span class="line">Symbol &quot;test&quot; is static storage at address 0x201018.</span><br><span class="line">(gdb) info symbol 0x201018</span><br><span class="line">test in section .bss</span><br></pre></td></tr></table></figure></div><p>接下来看一种在函数中初始化的全局静态变量,发现也是存在.bss区。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> test = foo();</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(gdb) info addr test</span><br><span class="line">Symbol &quot;test&quot; is static storage at address 0x201138.</span><br><span class="line">(gdb) info symbol 0x201138</span><br><span class="line">test in section .bss</span><br></pre></td></tr></table></figure></div><p>对于以上代码，通过调试，我发现进入main函数前，test的值已经初始化为0了，进入main函数后test为1，说明 <strong>.bbs存储的是全局未初始化的变量，系统初始化为0当做一个占位符，而.data存的是初始化为自定义的变量</strong></p><h2 id="局部静态变量"><a class="markdownIt-Anchor" href="#局部静态变量"></a> 局部静态变量</h2><p>关于局部静态变量的初始化就有些疑惑了，在c里静态变量都是在编译期间初始化完成，但是c++里就不太清楚了，网上很多答复是对象首次用到的时候构造初始化，接下来的代码我们来探究一下：<br>首先写个简单的局部静态变量</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> test = <span class="number">1</span>;  <span class="comment">//存在.data</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> no_test;     <span class="comment">//存在.bss</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> no_test_2 = <span class="number">0</span>；<span class="comment">//存在.bss</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disas main</span><br><span class="line">Dump of assembler code for function main():</span><br><span class="line">   0x000000000000073a &lt;+0&gt;:push   %rbp</span><br><span class="line">   0x000000000000073b &lt;+1&gt;:mov    %rsp,%rbp</span><br><span class="line">   0x000000000000073e &lt;+4&gt;:mov    $0x0,%eax</span><br><span class="line">   0x0000000000000743 &lt;+9&gt;:pop    %rbp</span><br><span class="line">   0x0000000000000744 &lt;+10&gt;:retq   </span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure></div><p>通过汇编看不到main函数里对static变量初始化的语句，但进main函数前是查不到test的值的，说明局部静态变量是程序第一次碰到他的定义的时候，之后通过类似上面的办法，得出了静态变量的存储位置详见注释</p><h2 id="类中静态变量"><a class="markdownIt-Anchor" href="#类中静态变量"></a> 类中静态变量</h2><p>不多废话，直接通过代码分析：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    test(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span><br><span class="line">        : _name(name) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; _name &lt;&lt; <span class="string">" created"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~test()&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; _name &lt;&lt; <span class="string">" destroyed"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">string</span> _name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">test <span class="title">t</span><span class="params">(<span class="string">"global variable"</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> test <span class="title">t</span><span class="params">(<span class="string">"static variable"</span>)</span></span>;</span><br><span class="line">    <span class="function">test <span class="title">t2</span><span class="params">(<span class="string">"Local variable"</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Function executed"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">test <span class="title">t</span><span class="params">(<span class="string">"local to main"</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Program start"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    f();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Program end"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">global variable created</span><br><span class="line">local to main created</span><br><span class="line">Program start</span><br><span class="line">static variable created</span><br><span class="line">Local variable created</span><br><span class="line">Function executed</span><br><span class="line">Local variable destroyed</span><br><span class="line">Program end</span><br><span class="line">local to main destroyed</span><br><span class="line">static variable destroyed</span><br><span class="line">global variable destroyed</span><br></pre></td></tr></table></figure></div><p>参考文献：<a href="https://www.cnblogs.com/mylinux/p/5611225.html" target="_blank" rel="noopener">https://www.cnblogs.com/mylinux/p/5611225.html</a><br><a href="https://stackoverflow.com/questions/55510/when-do-function-level-static-variables-get-allocated-initialized" target="_blank" rel="noopener">https://stackoverflow.com/questions/55510/when-do-function-level-static-variables-get-allocated-initialized</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="static" scheme="https://sunxin18.github.io/tags/static/"/>
    
  </entry>
  
  <entry>
    <title>时间统计特性开发</title>
    <link href="https://sunxin18.github.io/2021/06/07/record-time/"/>
    <id>https://sunxin18.github.io/2021/06/07/record-time/</id>
    <published>2021-06-07T03:25:30.000Z</published>
    <updated>2021-08-09T01:52:07.664Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="设计思路"><a class="markdownIt-Anchor" href="#设计思路"></a> 设计思路</h1><p>总体思路：首先设计一个类 SingleConvertTime， 利用这个类的构造和析构进行单次 convert 的时间的计算，将这个类的实例化加入到 convert 模板中，之后设计一个单例 SingleConvertTime 进行管理，统计各个消息实时转化的最值。</p><p>计算采用纳秒级别的精准度，最后文件输出统一以微妙精度。</p><p>由于消息存在嵌套，并且同一种消息类型可能会有不同的父消息类型，所以如果只按照 message type 为单位区分统计时间，会导致下层消息混乱统计（同名的消息都会被统一计算，他们可能来自于不同的父消息），结果容易造成误导，而最外层的消息类型统计是不存在这种情况，所以暂时提供最外层消息 convert 时间统计。</p><h1 id="准备"><a class="markdownIt-Anchor" href="#准备"></a> 准备</h1><p>单例模式：使用懒汉式单例(magic static )——局部静态变量</p><h1 id="详细思路"><a class="markdownIt-Anchor" href="#详细思路"></a> 详细思路</h1><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TimeTrace</span> &#123;</span></span><br><span class="line">  <span class="keyword">uint64_t</span> max_time = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">uint64_t</span> min_time = LONG_MAX;</span><br><span class="line">  <span class="keyword">uint64_t</span> sum_time = <span class="number">0</span>;  </span><br><span class="line">  <span class="keyword">uint64_t</span> convert_times = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ConvertTimeSettings</span> &#123;</span>                        <span class="comment">//可提供用户外部自定义</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> path = <span class="string">"/home/ros/convert_time"</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> file_name = <span class="string">"time_record"</span>;</span><br><span class="line">  <span class="keyword">int</span> time_interval = <span class="number">5000</span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConvertTimeTrace</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  ConvertTimeTrace(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;str) : message_type_(str) &#123;</span><br><span class="line">    <span class="comment">//记录当前消息初始时间</span></span><br><span class="line">  &#125;</span><br><span class="line">  ~ConvertTimeTrace() &#123;</span><br><span class="line">    ConvertTimeRecorder&amp; instance = ConvertTimeRecorder::get_instance();</span><br><span class="line">    <span class="comment">//记录当前消息结束时间，计算时间差，调用单例update 接口更新</span></span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConvertTimeRecorder</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> ConvertTimeRecorder&amp; <span class="title">get_instance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">static</span> ConvertTimeRecorder instance;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    ConvertTimeRecorder(ConvertTimeRecorder&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    ConvertTimeRecorder&amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> ConvertTimeRecorder&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;message_type, <span class="keyword">const</span> <span class="keyword">uint64_t</span> &amp;time)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//更新最大值，最小值，sum, convert次数 这里写容器上锁，同时这里触发时判断是否和上次写文件达到5000ms，达到就调用写文件</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print_time</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//求平均值，进行输出文件，以 txt 格式输出，文件名加进行id进行区分不同模块</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update_layer</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::thread::id &amp;thread_id, <span class="keyword">const</span> <span class="keyword">int</span> &amp;number)</span> </span>&#123; layer_count_[thread_id] += number;&#125;   <span class="comment">//这个和下面的函数用于实现只统计最外层消息</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_layer_number</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::thread::id &amp;thread_id )</span> </span>&#123; <span class="keyword">return</span> layer_count_[thread_id];&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_settings</span><span class="params">(ConvertTimeSettings settings)</span> </span>&#123; settings_ = settings; &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function">ConvertTimeSettings&amp; <span class="title">get_settings</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> settings_; &#125;</span><br><span class="line"> </span><br><span class="line">    ~ConvertTimeRecorder() &#123;</span><br><span class="line">        print_time()</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ConvertTimeRecorder()</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    <span class="built_in">std</span>::chrono::steady_clock::time_point print_start_time_;   <span class="comment">//用于记录打印的时间</span></span><br><span class="line">    <span class="built_in">std</span>::mutex mutex_;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, TimeTrace&gt; record_time_;</span><br><span class="line">    ConvertTimeSettings settings_;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::thread::id, <span class="keyword">int</span>&gt; layer_count_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="单例模式" scheme="https://sunxin18.github.io/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>shared_ptr用法与线程安全性</title>
    <link href="https://sunxin18.github.io/2021/05/14/shared-ptr/"/>
    <id>https://sunxin18.github.io/2021/05/14/shared-ptr/</id>
    <published>2021-05-14T06:09:15.000Z</published>
    <updated>2021-08-09T05:43:42.965Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="概念"><a class="markdownIt-Anchor" href="#概念"></a> 概念</h2><p>共享指针，即多个指针指向同一个内存；具体实现方式是采用的引用计数，即这块地址上每多一个指针指向他，计数加一；<br>引用计数可以跟踪对象所有权，并能够自动销毁对象。可以说引用计数是个简单的垃圾回收体系。</p><p><strong>智能指针是模板类而不是指针</strong>。创建一个智能指针时，必须指针可以指向的类型,<int>,<string> ……等。<br>智能指针实质就是重载了-&gt;和\操作符的类，由类来实现对内存的管理，确保即使有异常产生，也可以通过智能指针类的析构函数完成内存的释放。</string></int></p><p>可以认为每个shared_ptr都有一个关联的计数器，通常称其为引用计数(reference count)。无论何时拷贝一个shared_ptr，计数器都会递增。例如，当用一个shared_ptr初始化另一个shared_ptr，或将它作为参数传递给一个函数以及作为函数的返回值时，它所关联的计数器就会递增。当给shared_ptr赋予一个新值或是shared_ptr被销毁(例如一个局部的shared_ptr离开其作用域)时，计数器就会递减。一旦一个shared_ptr的计数器变为0，它就会自动释放自己所管理的对象。</p><p>当指向一个对象的最后一个shared_ptr被销毁时，shared_ptr类会自动销毁此对象。它是通过另一个特殊的成员函数析构函数(destructor)来完成销毁工作的。类似于构造函数，每个类都有一个析构函数。就像构造函数控制初始化一样，析构函数控制此类型的对象销毁时做什么操作。shared_ptr的析构函数会递减它所指向的对象的引用计数。如果引用计数变为0，shared_ptr的析构函数就会销毁对象，并释放它占用的内存。</p><h2 id="完整的例子"><a class="markdownIt-Anchor" href="#完整的例子"></a> 完整的例子</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BigObj</span> &#123;</span></span><br><span class="line">    BigObj() &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"big object has been constructed"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~BigObj() &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"big object has been destructed"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_ref1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;BigObj&gt; sp1 = <span class="built_in">std</span>::make_shared&lt;BigObj&gt;();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; sp1.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;BigObj&gt; sp2 = sp1;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; sp1.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; sp1.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    BigObj* ptr = sp1.get();</span><br><span class="line"></span><br><span class="line">    sp1 = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; sp1.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//构建 2 个智能指针</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; p1(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>));  <span class="comment">//shared_ptr&lt;T&gt; 类模板中，提供了多种实用的构造函数</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; p3 = <span class="built_in">std</span>::make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">10</span>); <span class="comment">//</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; p2(p1);</span><br><span class="line">    <span class="comment">//输出 p2 指向的数据 使用方法例子：可以当作一个指针使用</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"p2:"</span> &lt;&lt; *p2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">int</span> *p = p3.get(); <span class="comment">//shared_ptr 关联的原始指针 </span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"p3:"</span> &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    p1.reset();<span class="comment">//引用计数减 1,p1为空指针</span></span><br><span class="line">    <span class="keyword">if</span> (p1) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"p1 不为空"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"p1 为空"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//以上操作，并不会影响 p2</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *p2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//判断当前和 p2 同指向的智能指针有多少个</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; p2.use_count() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    test_ref1();</span><br><span class="line">    <span class="comment">//我们可以清晰地看到引用计数增加和减少的情况，当减少为 0 的时候就会释放指针对象。把 shared_ptr 设置为 nullptr 就可以让 shared_ptr 去释放所管理的裸指针。 通过 shared_ptr 的 get 方法可以获取它所管理的裸指针。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><a href="/2021/05/14/shared-ptr/1.png" data-fancybox="group" data-caption class="fancybox"><img src="/2021/05/14/shared-ptr/1.png" alt title></a></p><h2 id="析构"><a class="markdownIt-Anchor" href="#析构"></a> 析构</h2><p>析构函数中删除内部原始指针，默认调用的是delete()函数。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete point;</span><br></pre></td></tr></table></figure></div><p>像这样申请的数组，应该调用delete []释放内存，而shared_ptr析构函数中默认delete并不能满足需求。</p><p>给shared_ptr添加自定义删除器:</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BigObj</span> &#123;</span></span><br><span class="line">    BigObj() &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"big object has been constructed"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~BigObj() &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"big object has been destructed"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleter</span><span class="params">(BigObj *p)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Custom Deleter\n"</span>;</span><br><span class="line">  <span class="keyword">delete</span>[] p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;BigObj&gt; p(<span class="keyword">new</span> BigObj[<span class="number">2</span>], deleter);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;BigObj&gt; p2(<span class="keyword">new</span> BigObj[<span class="number">4</span>], [](BigObj *p) &#123;  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Custom Deleter\n"</span>;</span><br><span class="line">    <span class="keyword">delete</span>[] p;&#125;);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><a href="/2021/05/14/shared-ptr/2.png" data-fancybox="group" data-caption class="fancybox"><img src="/2021/05/14/shared-ptr/2.png" alt title></a></p><h2 id="误区"><a class="markdownIt-Anchor" href="#误区"></a> 误区：</h2><h3 id="不从-new-的返回值直接构造共享指针"><a class="markdownIt-Anchor" href="#不从-new-的返回值直接构造共享指针"></a> 不从 new 的返回值直接构造共享指针</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">T *a = <span class="keyword">new</span> T();</span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;T&gt; ptr1(a);</span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;T&gt; ptr2(a);</span><br></pre></td></tr></table></figure></div><p>这样的话，ptr1 和 ptr2 的引用计数是单独算的，它们任意一个对象在析构的时候，都会销毁 a 所指的对象，a就为悬空指针，所以，这个对象会被“销毁两次”。因此报错。（make_shared类模板可以避免）<br><a href="http://c.biancheng.net/view/7898.html" target="_blank" rel="noopener">http://c.biancheng.net/view/7898.html</a><br><a href="https://www.cnblogs.com/bandaoyu/p/14625038.html" target="_blank" rel="noopener">https://www.cnblogs.com/bandaoyu/p/14625038.html</a></p><h2 id="线程安全探究"><a class="markdownIt-Anchor" href="#线程安全探究"></a> 线程安全探究</h2><h2 id="共享指针的线程安全问题"><a class="markdownIt-Anchor" href="#共享指针的线程安全问题"></a> 共享指针的线程安全问题</h2><p>All member functions (including copy constructor and copy assignment) can be called by multiple threads on different instances of shared_ptr without additional synchronization even if these instances are copies and share ownership of the same object. If multiple threads of execution access the same shared_ptr without synchronization and any of those accesses uses a non-const member function of shared_ptr then a data race will occur; the shared_ptr overloads of atomic functions can be used to prevent the data race.</p><p>&quot;Multiple threads can simultaneously read and write <strong>different</strong> shared_ptr objects, even when the objects are copies that share ownership<br>解释一下以上的说话，比如我们建立一个共享指针管理的对象：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; ptr1 = make_shared&lt;<span class="keyword">int</span>&gt;();</span><br></pre></td></tr></table></figure></div><p>此时有两个逻辑块，不应该对待同样的处理。 一个是存储实际值的int，另一个是控制块，它存储使其工作的所有Shared_ptr &lt;&gt;工作原理。<br><strong>只有控制块本身是线程安全的</strong>，也就是共享指针实体可以在不同的线程建立和销毁，共享指针的计数原则都是原子操作，但是如果对指向对象有写操作，那么就需要加锁了，看如下代码</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; global_instance = make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_fcn</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">thread1</span><span class="params">(thread_fcn)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">thread2</span><span class="params">(thread_fcn)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function">thread <span class="title">thread10</span><span class="params">(thread_fcn)</span></span>;</span><br><span class="line"></span><br><span class="line">    chrono::<span class="function">milliseconds <span class="title">duration</span><span class="params">(<span class="number">10000</span>)</span></span>;</span><br><span class="line">    this_thread::sleep_for(duration);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_fcn</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// This is thread-safe and will work fine, though it's useless.  Many</span></span><br><span class="line">    <span class="comment">// short-lived pointers will be created and destroyed.</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; temp = global_instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This is not thread-safe.  While all the threads are the same, the</span></span><br><span class="line">    <span class="comment">// "final" value of this is almost certainly NOT going to be</span></span><br><span class="line">    <span class="comment">// number_of_threads*10000 = 100,000.  It'll be something else.</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        *global_instance = *global_instance + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>综上，共享指针的机制并不能保证多线程可以准确地访问资源，我们还是需要用同步机制比如st::mutex来使其线程安全。使用时我们要明确多个副本访问同一块内存有没有同步的问题</p><p>参考文献：<br><a href="https://ofstack.com/C++/8983/full-analysis-of-shared_ptr-thread-safety.html" target="_blank" rel="noopener">https://ofstack.com/C++/8983/full-analysis-of-shared_ptr-thread-safety.html</a><br><a href="https://stackoverflow.com/questions/14482830/stdshared-ptr-thread-safety" target="_blank" rel="noopener">https://stackoverflow.com/questions/14482830/stdshared-ptr-thread-safety</a><br><a href="https://en.cppreference.com/w/cpp/memory/shared_ptr" target="_blank" rel="noopener">https://en.cppreference.com/w/cpp/memory/shared_ptr</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="C++" scheme="https://sunxin18.github.io/categories/C/"/>
    
    
      <category term="共享指针" scheme="https://sunxin18.github.io/tags/%E5%85%B1%E4%BA%AB%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>优雅的写一个文件读取</title>
    <link href="https://sunxin18.github.io/2021/05/14/read-file/"/>
    <id>https://sunxin18.github.io/2021/05/14/read-file/</id>
    <published>2021-05-14T06:09:05.000Z</published>
    <updated>2021-05-14T06:12:30.201Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="用到的函数"><a class="markdownIt-Anchor" href="#用到的函数"></a> 用到的函数</h2><p>fseek 函数原型：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fseek</span><span class="params">(FILE * stream, <span class="keyword">long</span> offset, <span class="keyword">int</span> whence)</span></span>;</span><br></pre></td></tr></table></figure></div><p>SEEK_SET：文件开头<br>SEEK_CUR:文件当前位置<br>SEEK_END：文件末尾<br>该函数用于实现以任意顺序访问文件的不同位置</p><p>ftell：函数原型:</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">ftell</span><span class="params">(FILE *fp)</span></span>;</span><br></pre></td></tr></table></figure></div><p>该函数用于得到文件位置指针当前位置相对于文件首的偏移字节数。</p><p>data():返回内置vecotr所指的数组内存的第一个元素的指针</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> fread(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> nmemb, FILE *stream)</span><br></pre></td></tr></table></figure></div><p>C 库函数 从给定流 stream 读取数据到 ptr 所指向的数组中。<br>ptr – 这是指向带有最小尺寸 size*nmemb 字节的内存块的指针。<br>size – 这是要读取的每个元素的大小，以字节为单位。<br>nmemb – 这是元素的个数，每个元素的大小为 size 字节。<br>stream – 这是指向 FILE 对象的指针，该 FILE 对象指定了一个输入流。</p><h2 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">read_file</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;path)</span> </span>&#123;</span><br><span class="line">  FILE *file = fopen(path.c_str(), <span class="string">"r"</span>);</span><br><span class="line">  <span class="keyword">if</span> (file == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Fail to open file '%s'"</span>, path.c_str());</span><br><span class="line">    <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;FILE&gt; fp(file, [](FILE *file) &#123; fclose(file); &#125;);</span><br><span class="line">  fseek(fp.get(), <span class="number">0</span>, SEEK_END);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; content(ftell(fp.get()));</span><br><span class="line">  fseek(fp.get(), <span class="number">0</span>, SEEK_SET);</span><br><span class="line">  <span class="keyword">int</span> n = fread(content.data(), <span class="number">1</span>, content.size(), fp.get()); </span><br><span class="line">  <span class="keyword">return</span> n &gt; <span class="number">0</span> ? <span class="built_in">std</span>::<span class="built_in">string</span>(content.begin(), content.end()) : <span class="built_in">std</span>::<span class="built_in">string</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"[usage]:"</span> &lt;&lt; argv[<span class="number">0</span>] &lt;&lt; <span class="string">" output_path"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">auto</span> file_path = <span class="built_in">std</span>::<span class="built_in">string</span>(argv[<span class="number">1</span>]) + <span class="string">"/test.txt"</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> result = read_file(file_path);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; result &lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>参考内容：<a href="https://www.runoob.com/cprogramming/c-function-fread.html" target="_blank" rel="noopener">https://www.runoob.com/cprogramming/c-function-fread.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="文件读取" scheme="https://sunxin18.github.io/tags/%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96/"/>
    
  </entry>
  
  <entry>
    <title>418</title>
    <link href="https://sunxin18.github.io/2021/04/18/418/"/>
    <id>https://sunxin18.github.io/2021/04/18/418/</id>
    <published>2021-04-18T14:03:39.000Z</published>
    <updated>2021-04-18T14:51:25.764Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目地址：<a href="https://leetcode-cn.com/problems/contains-duplicate-iii/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/contains-duplicate-iii/</a><br>由于要判断的两个数的下标的距离小于k，很容易想到使用滑动窗口，对每个窗口内的数进行判断，然后移动窗口，复杂度就是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>k</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(kn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，这会超出时间限制</p><p>因此降低复杂度就要从滑动窗口入手，使用一种数据结构可以满足一下几点</p><ul><li>能够用更短的时间判断</li><li>还可以动态维护，即进行插入删除</li></ul><p>想到使用 set 来维护，set可以自动对滑动窗口内的数进行排序，总体复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mi>k</mi></msub><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(log_{k}n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span><br>设窗口又端点的数为x，使用lower_bound 函数找到窗口内最小的一个大于等于x-t的数，如果这个数也小于等于x+t，那么就找到了这一对数。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">containsNearbyAlmostDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">long</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">auto</span> iter = st.lower_bound((<span class="keyword">long</span>)nums[i] - t);</span><br><span class="line">            <span class="keyword">if</span> (iter != st.end() &amp;&amp; *iter &lt;= (<span class="keyword">long</span>)nums[i] + t)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            st.insert(nums[i]);</span><br><span class="line">            <span class="keyword">if</span> (st.size() &gt; k)</span><br><span class="line">                st.erase(nums[i - k]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><p>使用set仍然无法达到线性时间，我们可以使用桶排序在O(1)的时候进行类似窗口内判断的操作。<br>我们将桶的大小设为t+1(因为判断的两个数的差小于等于t，那么桶里放t+1个数就一个都不会漏了)。如果两个元素同属一个桶，那么这两个元素必然符合条件。如果两个元素属于相邻桶，那么我们需要校验这两个元素是否差值不超过 t。如果两个元素既不属于同一个桶，也不属于相邻桶，那么这两个元素必然不符合条件。<br>难点在于怎么给桶编号，如果是非负数，那么id就是x/t+1,<br>可以看下这个题解：<a href="https://leetcode-cn.com/problems/contains-duplicate-iii/solution/c-li-yong-tong-fen-zu-xiang-xi-jie-shi-b-ofj6/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/contains-duplicate-iii/solution/c-li-yong-tong-fen-zu-xiang-xi-jie-shi-b-ofj6/</a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getID</span> <span class="params">(<span class="keyword">long</span> x, <span class="keyword">long</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x &gt;= <span class="number">0</span> ? x / (t + <span class="number">1</span>) : (x + <span class="number">1</span>) / (t + <span class="number">1</span>) - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">containsNearbyAlmostDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span> &lt;<span class="keyword">long</span>, <span class="keyword">long</span>&gt; <span class="built_in">map</span>;<span class="comment">//由于桶如果有两个相同的就满足返回true了，所以每个桶里最多放一个元素，使用map就合适</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> id = getID(nums[i], t);</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">map</span>.find(id) != <span class="built_in">map</span>.end()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">int</span> l = id - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> r = id + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">map</span>.find(l) != <span class="built_in">map</span>.end() &amp;&amp; nums[i] - <span class="built_in">map</span>[l] &lt;= t) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">map</span>.find(r) != <span class="built_in">map</span>.end() &amp;&amp; <span class="built_in">map</span>[r] - nums[i] &lt;= t) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">map</span>[id] = nums[i];</span><br><span class="line">            <span class="keyword">if</span>(i - k &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">map</span>.erase(getID(nums[i - k], t));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="算法编程" scheme="https://sunxin18.github.io/categories/%E7%AE%97%E6%B3%95%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="桶排序" scheme="https://sunxin18.github.io/tags/%E6%A1%B6%E6%8E%92%E5%BA%8F/"/>
    
      <category term="滑动窗口" scheme="https://sunxin18.github.io/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
      <category term="复杂度优化" scheme="https://sunxin18.github.io/tags/%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>杀掉指定进程名的进程</title>
    <link href="https://sunxin18.github.io/2021/01/30/kill/"/>
    <id>https://sunxin18.github.io/2021/01/30/kill/</id>
    <published>2021-01-29T19:19:00.000Z</published>
    <updated>2021-01-29T19:33:19.332Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>场景是要杀掉服务器上的一个进程并且不知道进程号，所以我们现在本地查一下进程名，在服务器和本地进程名都是一样的</p><h2 id="首先在本地查一下进程号"><a class="markdownIt-Anchor" href="#首先在本地查一下进程号"></a> 首先在本地查一下进程号：</h2><p><a href="/2021/01/30/kill/2.png" data-fancybox="group" data-caption class="fancybox"><img src="/2021/01/30/kill/2.png" alt title></a></p><h2 id="查进程名"><a class="markdownIt-Anchor" href="#查进程名"></a> 查进程名：</h2><p>命令：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -aux |grep -v grep|grep ID</span><br></pre></td></tr></table></figure></div><p><a href="/2021/01/30/kill/1.png" data-fancybox="group" data-caption class="fancybox"><img src="/2021/01/30/kill/1.png" alt title></a><br>看到进程名字是&quot;lidarperception_ros2mfr_adaptor&quot;</p><h2 id="杀掉进程"><a class="markdownIt-Anchor" href="#杀掉进程"></a> 杀掉进程</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pkill -f &quot;lidarperception_ros2mfr_adaptor&quot;</span><br></pre></td></tr></table></figure></div><p><a href="/2021/01/30/kill/3.png" data-fancybox="group" data-caption class="fancybox"><img src="/2021/01/30/kill/3.png" alt title></a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Linux" scheme="https://sunxin18.github.io/categories/Linux/"/>
    
    
      <category term="linux命令" scheme="https://sunxin18.github.io/tags/linux%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>Linux下不同使用者使用不同版本gcc的方法</title>
    <link href="https://sunxin18.github.io/2021/01/11/g/"/>
    <id>https://sunxin18.github.io/2021/01/11/g/</id>
    <published>2021-01-11T10:11:11.000Z</published>
    <updated>2021-01-29T19:24:06.556Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>最近论文实验比对其他paper的代码时发现了报错，很明显问题出现在gcc版本的不一致。服务器的gcc版本是9.3，而paper三年前的版本肯定不是了，所以下载了4.8版本，然后下面是切换版本的方法：<br>sudo apt-get install gcc-6</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cd ~</span><br><span class="line">mkdir bin</span><br><span class="line">cd bin</span><br><span class="line">ln -s /usr/bin/gcc-4.8 gcc</span><br><span class="line">ln -s /usr/bin/g++-4.8 g++</span><br><span class="line">PATH=~/bin:$PATH</span><br></pre></td></tr></table></figure></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Linux" scheme="https://sunxin18.github.io/categories/Linux/"/>
    
    
      <category term="安装" scheme="https://sunxin18.github.io/tags/%E5%AE%89%E8%A3%85/"/>
    
  </entry>
  
  <entry>
    <title>gdb来检查播bag测试的崩溃</title>
    <link href="https://sunxin18.github.io/2020/12/20/gdb/"/>
    <id>https://sunxin18.github.io/2020/12/20/gdb/</id>
    <published>2020-12-20T03:10:28.000Z</published>
    <updated>2020-12-30T08:01:09.797Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本地播bag测试时，出现了崩溃，如下<br><a href="/2020/12/20/gdb/1.png" data-fancybox="group" data-caption class="fancybox"><img src="/2020/12/20/gdb/1.png" alt title></a><br>首先我们先找到coredump文件，在Downloads/coredump目录下，然后我们根据时间找到对应的文件core.xxxx记住这个名字,发现是我负责的lidar模块的错误<br>进入到catkin_ws/devel/lib/lidar_perception目录,此目录下有个lidar_perception_mfr_node,此时我们通过gdb来看一下报错原因</p> <div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb lidar_perception_mfr_node ~/Downloads/coredump/core.xxx</span><br></pre></td></tr></table></figure></div><p>然后输入bt看一下堆栈信息<br><a href="/2020/12/20/gdb/2.png" data-fancybox="group" data-caption class="fancybox"><img src="/2020/12/20/gdb/2.png" alt title></a><br>可以发现问题是说有个地方的protobuf的版本不匹配。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="调试" scheme="https://sunxin18.github.io/tags/%E8%B0%83%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>git操作指令</title>
    <link href="https://sunxin18.github.io/2020/12/05/git/"/>
    <id>https://sunxin18.github.io/2020/12/05/git/</id>
    <published>2020-12-05T09:06:10.000Z</published>
    <updated>2020-12-31T10:25:34.881Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="git是什么"><a class="markdownIt-Anchor" href="#git是什么"></a> git是什么？</h1><p>Git 更像是把数据看作是对小型文件系统的一系列快照。 在 Git 中，每当你提交更新或保存项目状态时，它基本上就会对当时的全部文件创建一个快照并保存这个快照的索引。 为了效率，如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。 Git 对待数据更像是一个 快照流。</p><h2 id="获取-git-仓库"><a class="markdownIt-Anchor" href="#获取-git-仓库"></a> 获取 Git 仓库</h2><p>Git 克隆的是该 Git 仓库服务器上的几乎所有数据，而不是仅仅复制完成你的工作所需要文件。 当你执行 git clone 命令的时候，默认配置下远程 Git 仓库中的每一个文件的每一个版本都将被拉取下来。事实上，如果你的服务器的磁盘坏掉了，你通常可以使用任何一个克隆下来的用户端来重建服务器上的仓库 （虽然可能会丢失某些服务器端的钩子（hook）设置，但是所有版本的数据仍在，</p><h2 id="记录每次更新到仓库"><a class="markdownIt-Anchor" href="#记录每次更新到仓库"></a> 记录每次更新到仓库</h2><p>你工作目录下的每一个文件都不外乎这两种状态：××已跟踪：×× 或 ××未跟踪××<br>已跟踪：是指那些被纳入了版本控制的文件，在上一次快照中有它们的记录，在工作一段时间后， 它们的状态可能是未修改，已修改或已放入暂存区。简而言之，已跟踪的文件就是 Git 已经知道的文件。<br>为跟踪</p><p>为跟踪:工作目录中除已跟踪文件外的其它所有文件都属于未跟踪文件，它们既不存在于上次快照的记录中，也没有被放入暂存区。 初次克隆某个仓库的时候，工作目录中的所有文件都属于已跟踪文件，并处于未修改状态，因为 Git 刚刚检出了它们， 而你尚未编辑过它们。</p><h1 id="git操作"><a class="markdownIt-Anchor" href="#git操作"></a> git操作</h1><h2 id="下拉仓库"><a class="markdownIt-Anchor" href="#下拉仓库"></a> 下拉仓库</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone xxx --recursive</span><br></pre></td></tr></table></figure></div><p>submodule更新：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git submodule update --init --</span><br></pre></td></tr></table></figure></div><h2 id="创建分支"><a class="markdownIt-Anchor" href="#创建分支"></a> 创建分支</h2><p>###查看分支信息</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -a</span><br></pre></td></tr></table></figure></div><h3 id="切换到-dev-分支"><a class="markdownIt-Anchor" href="#切换到-dev-分支"></a> 切换到 dev 分支</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout dev</span><br></pre></td></tr></table></figure></div><h3 id="更新-dev-分支到最新"><a class="markdownIt-Anchor" href="#更新-dev-分支到最新"></a> 更新 dev 分支到最新</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git fetch</span><br><span class="line">git rebase</span><br></pre></td></tr></table></figure></div><h3 id="创建自己的分支分支名的命名规范是namebranch_summary"><a class="markdownIt-Anchor" href="#创建自己的分支分支名的命名规范是namebranch_summary"></a> 创建自己的分支，分支名的命名规范是：[NAME]/[BRANCH_SUMMARY]</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b zhangsan/add_new_feature</span><br></pre></td></tr></table></figure></div><h3 id="将自己的分支推到远端"><a class="markdownIt-Anchor" href="#将自己的分支推到远端"></a> 将自己的分支推到远端</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin zhangsan/add_new_feature</span><br></pre></td></tr></table></figure></div><h3 id="设置自己本地分支追踪的远程分支"><a class="markdownIt-Anchor" href="#设置自己本地分支追踪的远程分支"></a> 设置自己本地分支追踪的远程分支</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -u origin/zhangsan/add_new_feature</span><br></pre></td></tr></table></figure></div><h2 id="提交的流程"><a class="markdownIt-Anchor" href="#提交的流程"></a> 提交的流程</h2><h3 id="首先先看当前的状态通常是status命令diff可以看具体修改了什么地方"><a class="markdownIt-Anchor" href="#首先先看当前的状态通常是status命令diff可以看具体修改了什么地方"></a> 首先先看当前的状态，通常是status命令，diff可以看具体修改了什么地方</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status/git status -s/git diff</span><br></pre></td></tr></table></figure></div><h3 id="之后跟踪新文件或修改-通常使用git-add-来跟踪当前目录下的所有修改"><a class="markdownIt-Anchor" href="#之后跟踪新文件或修改-通常使用git-add-来跟踪当前目录下的所有修改"></a> 之后跟踪新文件或修改， 通常使用git add .来跟踪当前目录下的所有修改</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add xxx/git add .</span><br></pre></td></tr></table></figure></div><h3 id="提交更新"><a class="markdownIt-Anchor" href="#提交更新"></a> 提交更新</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;xxx&quot;</span><br><span class="line">比如：git commit -m &quot;add_new_file&quot;</span><br></pre></td></tr></table></figure></div><p>提交后它会告诉你，当前是在哪个分支（master）提交的，本次提交的完整 SHA-1 校验和是什么，以及在本次提交中，有多少文件修订过，多少行添加和删改过。</p><h3 id="推送到远端"><a class="markdownIt-Anchor" href="#推送到远端"></a> 推送到远端</h3><p>git push origin “branch name”</p><h2 id="远程库覆盖本地代码"><a class="markdownIt-Anchor" href="#远程库覆盖本地代码"></a> 远程库覆盖本地代码</h2><p>git fetch --all<br>git reset --hard origin/develop<br>git pull</p><h2 id="撤销本地操作"><a class="markdownIt-Anchor" href="#撤销本地操作"></a> 撤销本地操作</h2><p>git checkout .</p><h2 id="删除远程分支"><a class="markdownIt-Anchor" href="#删除远程分支"></a> 删除远程分支</h2><p>git push origin --delete branch</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ros通信实现</title>
    <link href="https://sunxin18.github.io/2020/11/18/ros/"/>
    <id>https://sunxin18.github.io/2020/11/18/ros/</id>
    <published>2020-11-18T14:15:07.000Z</published>
    <updated>2021-01-29T19:23:48.347Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>ROS是基于topic发布和订阅来实现通信，底层是TCP来发送消息，具体原理本文不在详细介绍。本文将手动实现两个ros节点的通信。</p><h1 id="首先进入ros并进入catkin_wssrc目录"><a class="markdownIt-Anchor" href="#首先进入ros并进入catkin_wssrc目录"></a> 首先进入ROS，并进入/catkin_ws/src目录</h1><h1 id="创建新的package"><a class="markdownIt-Anchor" href="#创建新的package"></a> 创建新的package</h1><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">catkin_create_pkg basic_topic roscpp std_msgs</span><br></pre></td></tr></table></figure></div><p>#向功能包添加自定义消息文件(.msg)</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">roscd custom_msg_topic</span><br><span class="line">mkdir msg &amp;&amp; cd msg</span><br><span class="line">gedit custom_msg.msg</span><br></pre></td></tr></table></figure></div><p>在custom_msg.msg文件中输入如下的内容：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string first_name</span><br><span class="line">string last_name</span><br><span class="line">uint8 age</span><br><span class="line">string character</span><br></pre></td></tr></table></figure></div><p>修改CMakeLists.txt文件的内容为：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 2.8.3)</span><br><span class="line">project(custom_msg_topic)</span><br><span class="line">find_package(catkin REQUIRED COMPONENTS</span><br><span class="line">  roscpp</span><br><span class="line">  std_msgs</span><br><span class="line">  message_generation</span><br><span class="line">)</span><br><span class="line">add_message_files(</span><br><span class="line">  FILES</span><br><span class="line">  custom_msg.msg</span><br><span class="line">)</span><br><span class="line">generate_messages(</span><br><span class="line">  DEPENDENCIES</span><br><span class="line">  std_msgs</span><br><span class="line">)</span><br><span class="line">catkin_package(</span><br><span class="line">  LIBRARIES custom_msg_topic</span><br><span class="line">  CATKIN_DEPENDS roscpp message_runtime</span><br><span class="line">)</span><br><span class="line">include_directories(</span><br><span class="line">  $&#123;catkin_INCLUDE_DIRS&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></div><p>回到功能包所在的工作空间，构建功能包:</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ~/catkin_ws</span><br><span class="line">catkin_make</span><br></pre></td></tr></table></figure></div><p><strong>编译之后会在include文件夹下生成对应的custom_msg.h文件</strong><br>可以来检测一下</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ros@sunxin-ThinkPad-T480s.master&gt; rosmsg show custom_msg_topic/custom_msg</span><br><span class="line">string first_name</span><br><span class="line">string last_name</span><br><span class="line">uint8 age</span><br><span class="line">string character</span><br></pre></td></tr></table></figure></div><p>生成了自定义的消息头文件之后，我们就可以利用自定义的消息格式来编写节点了.</p><h1 id="建立publisher节点"><a class="markdownIt-Anchor" href="#建立publisher节点"></a> 建立publisher节点</h1><p>一般包含如下要素:<br>ROS节点初始化<br>创建节点句柄<br>穿件publisher<br>设置循环频率</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">roscd custom_msg_topic/src</span><br><span class="line">gedit custom_msg_publisher.cpp</span><br></pre></td></tr></table></figure></div><p>并编辑cpp文件加入以下代码（代码具体讲解参考文下参考文献）</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ros/ros.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"custom_msg_topic/custom_msg.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ros::init(argc, argv, <span class="string">"custom_msg_publisher"</span>);</span><br><span class="line">  ros::NodeHandle nh;</span><br><span class="line">  ros::Publisher custom_msg_pub = nh.advertise&lt;custom_msg_topic::custom_msg&gt;(<span class="string">"test"</span>, <span class="number">100</span>);</span><br><span class="line">  ros::<span class="function">Rate <span class="title">loop_rate</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">  <span class="keyword">while</span> (ros::ok())</span><br><span class="line">  &#123;</span><br><span class="line">    custom_msg_topic::custom_msg msg;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">stringstream</span> ss;</span><br><span class="line">    ss&lt;&lt;<span class="string">"Xiao Xin"</span>;</span><br><span class="line">    ss&gt;&gt;msg.last_name; </span><br><span class="line">    ss&gt;&gt;msg.first_name; </span><br><span class="line">    msg.age = <span class="number">18</span>;</span><br><span class="line">    msg.character = <span class="string">"lovely"</span>;</span><br><span class="line"></span><br><span class="line">    custom_msg_pub.publish(msg);</span><br><span class="line">    loop_rate.sleep();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>#建立subsriber节点<br>一般包含如下要素:</p><p>回调函数<br>ROS节点初始化<br>创建节点句柄<br>穿件publisher<br>循环等待回调函数</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">roscd custom_msg_topic/src</span><br><span class="line">gedit custom_msg_subscriber.cpp</span><br></pre></td></tr></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ros/ros.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"custom_msg_topic/custom_msg.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_infoCallback</span><span class="params">(<span class="keyword">const</span> custom_msg_topic::custom_msgConstPtr &amp;msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ROS_INFO(<span class="string">"I heard: [%s %s]"</span>, msg-&gt;last_name.c_str(), msg-&gt;first_name.c_str());</span><br><span class="line">  ROS_INFO(<span class="string">"his age is: [%d]; and he is [%s]"</span>, msg-&gt;age, msg-&gt;character.c_str());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ros::init(argc, argv, <span class="string">"custom_msg_subscriber"</span>);</span><br><span class="line">  ros::NodeHandle nh;</span><br><span class="line">  ros::Subscriber sub = nh.subscribe(<span class="string">"test"</span>, <span class="number">1000</span>, test_infoCallback);</span><br><span class="line"></span><br><span class="line">  ros::spin();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h1 id="修改功能包的cmakeliststxt文件"><a class="markdownIt-Anchor" href="#修改功能包的cmakeliststxt文件"></a> 修改功能包的CMakeLists.txt文件</h1><p>打开终端</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">roscd custom_msg_topic</span><br><span class="line">gedit CMakeLists.txt</span><br></pre></td></tr></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 2.8.3)</span><br><span class="line">project(custom_msg_topic)</span><br><span class="line">find_package(catkin REQUIRED COMPONENTS</span><br><span class="line">  roscpp</span><br><span class="line">  std_msgs</span><br><span class="line">  message_generation</span><br><span class="line">)</span><br><span class="line">add_message_files(</span><br><span class="line">  FILES</span><br><span class="line">  custom_msg.msg</span><br><span class="line">)</span><br><span class="line">generate_messages(</span><br><span class="line">  DEPENDENCIES</span><br><span class="line">  std_msgs</span><br><span class="line">)</span><br><span class="line">catkin_package(</span><br><span class="line">  LIBRARIES custom_msg_topic</span><br><span class="line">  CATKIN_DEPENDS roscpp message_runtime</span><br><span class="line">)</span><br><span class="line">include_directories(</span><br><span class="line">  $&#123;catkin_INCLUDE_DIRS&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># 下面是需要添加的内容</span><br><span class="line">add_executable(custom_msg_publisher src/custom_msg_publisher.cpp)</span><br><span class="line">add_executable(custom_msg_subscriber src/custom_msg_subscriber.cpp)</span><br><span class="line">add_dependencies(custom_msg_publisher $&#123;$&#123;PROJECT_NAME&#125;_EXPORTED_TARGETS&#125; $&#123;catkin_EXPORTED_TARGETS&#125;)</span><br><span class="line">add_dependencies(custom_msg_subscriber $&#123;$&#123;PROJECT_NAME&#125;_EXPORTED_TARGETS&#125; $&#123;catkin_EXPORTED_TARGETS&#125;)</span><br><span class="line">target_link_libraries(custom_msg_publisher $&#123;catkin_LIBRARIES&#125;)</span><br><span class="line">target_link_libraries(custom_msg_subscriber $&#123;catkin_LIBRARIES&#125;)</span><br></pre></td></tr></table></figure></div><h1 id="运行"><a class="markdownIt-Anchor" href="#运行"></a> 运行</h1><p>然后再次编译一下</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ~/catkin_ws</span><br><span class="line">catkin_make</span><br></pre></td></tr></table></figure></div><p>开始运行～</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">roscore</span><br><span class="line">rosrun custom_msg_topic custom_msg_publisher</span><br></pre></td></tr></table></figure></div><p><a href="/2020/11/18/ros/1.jpg" data-fancybox="group" data-caption class="fancybox"><img src="/2020/11/18/ros/1.jpg" alt title></a><br>接着可以查看一些详情</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rosnode info rosrun custom_msg_topic custom_msg_subscriber</span><br><span class="line">rostopic hz test</span><br></pre></td></tr></table></figure></div><p><a href="/2020/11/18/ros/2.jpg" data-fancybox="group" data-caption class="fancybox"><img src="/2020/11/18/ros/2.jpg" alt title></a></p><p>参考文献：<br><a href="http://wiki.ros.org/ROS/Tutorials/WritingPublisherSubscriber%28c++%29" target="_blank" rel="noopener">http://wiki.ros.org/ROS/Tutorials/WritingPublisherSubscriber(c++)</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="ROS" scheme="https://sunxin18.github.io/categories/ROS/"/>
    
    
  </entry>
  
  <entry>
    <title>排序专题</title>
    <link href="https://sunxin18.github.io/2020/11/05/quick-sort/"/>
    <id>https://sunxin18.github.io/2020/11/05/quick-sort/</id>
    <published>2020-11-05T04:56:36.000Z</published>
    <updated>2021-08-20T09:02:45.980Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本专题我们将回顾经典的排序算法，这节先看</p><h2 id="冒泡排序"><a class="markdownIt-Anchor" href="#冒泡排序"></a> 冒泡排序</h2><p>每一次遍历会将一个元素“浮”到数列的末尾<br>快速排序<br>排序的基本思想是：</p><p>1．先从数列中取出一个数作为基准数。</p><p>2．分区过程，将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边。</p><p>3．再对左右区间重复第二步，直到各区间只有一个数。</p><p>代码模板</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> q[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span></span><br><span class="line"><span class="keyword">int</span> i = l - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> r = r + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> x = q[l + r &gt;&gt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">while</span> (i &lt; j)&#123;</span><br><span class="line"><span class="keyword">do</span> i++; <span class="keyword">while</span>(q[i] &lt; x);</span><br><span class="line"><span class="keyword">do</span> j--; <span class="keyword">while</span>(q[j] &gt; x);</span><br><span class="line"><span class="keyword">if</span>(i &lt; j)</span><br><span class="line">swap(q[i], q[j]);</span><br><span class="line">&#125;</span><br><span class="line">quick_sort(q, l, j);</span><br><span class="line">quick_sort(q, j + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>while循环结束后，q[l…j] &lt;= x,q[j+1…r] &gt;= x<br>注:q[l…j] &lt;= x意为q[l],q[l+1]…q[j-1],q[j]的所有元素都&lt;= x<br>最小k个数</p><p><strong>注意x不一定在位置j上<br>比如q=[4,7,2]，第一轮x为7，第一轮完事是[4,2,7]，j是1，x在位置2上</strong></p><p>还有一个点，一定要多多留意<strong>两个指针l，r重合的情况</strong>，在有些题会对这个做文章，比如返回最小的k个数</p><h2 id="leetcode面试题-1714-最小k个数"><a class="markdownIt-Anchor" href="#leetcode面试题-1714-最小k个数"></a> leetcode面试题 17.14. 最小K个数</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> i = l - <span class="number">1</span>, j = r + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> x = arr[l + r &gt;&gt; <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">do</span> i++; <span class="keyword">while</span> (arr[i] &lt; x);</span><br><span class="line">            <span class="keyword">do</span> j--; <span class="keyword">while</span> (arr[j] &gt; x);</span><br><span class="line">            <span class="keyword">if</span> (i &lt; j) swap(arr[i], arr[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = j - l + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (n &gt; k)</span><br><span class="line">            quick_sort(arr, l, j, k);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (n == k) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">0</span>; m &lt; k; m++) &#123;</span><br><span class="line">                res.push_back(arr[l + m]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">0</span>; m &lt; n; m++) &#123;</span><br><span class="line">                res.push_back(arr[l + m]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j + <span class="number">1</span> == r)     <span class="comment">//注意这个情况</span></span><br><span class="line">                res.push_back(arr[r]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                quick_sort(arr, j + <span class="number">1</span>, r, k - n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; smallestK(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        quick_sort(arr, <span class="number">0</span>, arr.size() - <span class="number">1</span>, k);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><p>最开始我的写法发现有些情况最终的结果数组res元素小于k，也就是有些情况没有考虑到，其实就是当n &lt; k的时候，也就是后半段还要进行递归去找剩下n-k个，当就剩下一个的时候，也就是j + 1 == r，进入下层递归在开头(l &gt;= r)就退出了，所以这种情况要单独考虑的。</p><p>这道题还有很多解法，下面给出冒泡和堆得写法，冒泡会在最后一个用例超时</p><p>冒泡：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; smallestK(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = arr.size() - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[i] &lt; arr[i - <span class="number">1</span>])</span><br><span class="line">                    swap(arr[i], arr[i - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)&#123;</span><br><span class="line">            res.push_back(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><p>堆：</p><p>不正经版本：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; smallestK(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        sort(arr.begin(),arr.end());</span><br><span class="line">        arr.resize(k);</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><h2 id="归并排序"><a class="markdownIt-Anchor" href="#归并排序"></a> 归并排序</h2><p>对[l, r]这个区间的数，我们递归的先去排序[l, mid],[mid + 1, r]两个区间，然后对这两个排序好的区间进行合并：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;vec, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    merge_sort(vec, l, mid - <span class="number">1</span>);</span><br><span class="line">    merge_sort(vec, mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="keyword">int</span> i = l, j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp(r - l + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= r) &#123;</span><br><span class="line">        <span class="keyword">if</span> (vec[i] &lt; vec[j]) &#123;</span><br><span class="line">            temp[k++] = vec[i++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            temp[k++] = vec[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) temp[k++] = vec[i++];</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= r) temp[k++] = vec[j++];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l, j = <span class="number">0</span>; i &lt;= r; i++, j++) &#123;</span><br><span class="line">        vec[i] = temp[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="算法" scheme="https://sunxin18.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="排序" scheme="https://sunxin18.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title> cbug</title>
    <link href="https://sunxin18.github.io/2020/10/30/cbug/"/>
    <id>https://sunxin18.github.io/2020/10/30/cbug/</id>
    <published>2020-10-30T02:15:17.000Z</published>
    <updated>2020-11-01T09:11:37.956Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="越界问题"><a class="markdownIt-Anchor" href="#越界问题"></a> 越界问题</h1><ul><li>对于二叉树要多多注意p-&gt;left, p-&gt;right 是否存在</li><li>数组当取下标的时候一定要提前判断好是否会越界，特别主要二维数组判断空时, 对纵向可能会用到q[0].size(), 这个要先判断q.size()</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>字符串+栈</title>
    <link href="https://sunxin18.github.io/2020/10/19/string-stack/"/>
    <id>https://sunxin18.github.io/2020/10/19/string-stack/</id>
    <published>2020-10-19T10:20:53.000Z</published>
    <updated>2020-10-19T12:55:08.416Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ol start="394"><li>字符串解码<br>相信会有人疑惑为什么官方视频例子里，s = “3[a2[c]]” 存的是[[2, a]而不是[2,c]呢？请看下面解答：<br>看完此题很容易就联想到栈，因为涉及到优先级最能层的括号先计算，其实这道题类似于分配率。<br>第一步是如何设计栈，有一个是数字代表重复次数，一个字符串代表要重复的字符串，很容易联想到用两个栈来存，分别存数字和字符串，存储进入’[‘前的状态（这里存的数字代表[]运算完后内部的字符串需要重复的次数，字符代表进入’[‘前需要存的字符。<br>接下来是怎么存？首先先用一个int num存储当前遍历的数，string res存储当前遍历到的字符串，当遇到’[‘的时候代表我们要先计算’[‘后的内容，当前计算得部分需要先存起来，当遇到’]‘时，将当前的res重复num次与栈最上层的字符串拼接，也就是进入当前’[‘时的状态,直到遍历结束，每遇到一次’[‘一次入栈，一次’]'一次出栈正好对应。</li></ol><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">decodeString</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="built_in">string</span>&gt; strs;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] &gt;= <span class="string">'0'</span> &amp;&amp; s[i] &lt;= <span class="string">'9'</span>)</span><br><span class="line">                num = num * <span class="number">10</span> + s[i] - <span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>((s[i] &gt;= <span class="string">'a'</span> &amp;&amp; s[i] &lt;= <span class="string">'z'</span>) ||(s[i] &gt;= <span class="string">'A'</span> &amp;&amp; s[i] &lt;= <span class="string">'Z'</span>))</span><br><span class="line">                res =  res + s[i];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i] == <span class="string">'['</span>)&#123;</span><br><span class="line">                nums.push(num);</span><br><span class="line">                strs.push(res);</span><br><span class="line">                res = <span class="string">""</span>;</span><br><span class="line">                num = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> cur = nums.top();</span><br><span class="line">                nums.pop();</span><br><span class="line">                <span class="built_in">string</span> cur_str ;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cur; i++)&#123;</span><br><span class="line">                    cur_str += res;</span><br><span class="line">                &#125;</span><br><span class="line">                res = strs.top() + cur_str;</span><br><span class="line">                strs.pop();</span><br><span class="line">            &#125;     </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="算法编程" scheme="https://sunxin18.github.io/categories/%E7%AE%97%E6%B3%95%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="字符串" scheme="https://sunxin18.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="栈" scheme="https://sunxin18.github.io/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>Effective STL 笔记</title>
    <link href="https://sunxin18.github.io/2020/10/03/effective-stl/"/>
    <id>https://sunxin18.github.io/2020/10/03/effective-stl/</id>
    <published>2020-10-03T02:23:07.000Z</published>
    <updated>2020-10-12T03:03:43.599Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ol><li><p>慎重选择容器类型</p></li><li><p>确保容器中的对象拷贝正确而高效<br>当(通过如insert或push_back之类的操作)向容器中加入对象时，存入容器的是你所指定的对象的拷贝。当(通过如front或back之类的操作)从容器中取出一个对象时，你所得到的是容器中所保存的对象的拷贝。进去的是拷贝，出来的也是拷贝(copy in, copy out)。这就是STL的工作方式。</p></li><li><p>调用empty而不是检查size()是否为0<br>empty对所有的标准容器都是常数时间操作，而对一些list实现，size耗费线性时间。</p></li><li><p>慎重选择删除元素的方法<br>删除vector中值为x的元素</p></li></ol><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; c1;</span><br><span class="line">c1.erase(<span class="built_in">std</span>::remove(c1.begin(), c1.end(), <span class="number">1963</span>), c1.end()); <span class="comment">// 当c1是vector, string或deque时，erase-remove习惯用法是删除特定值的元素的最好办法</span></span><br><span class="line"><span class="comment">//这句的意思是，取得"1963"的位置（位于结尾），然后删除"be"到原vector结尾的所有元素</span></span><br></pre></td></tr></table></figure></div><p>对于list</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; c2;</span><br><span class="line">c2.remove(<span class="number">1963</span>); <span class="comment">// 当c2是list时，remove成员函数是删除特定值的元素的最好办法</span></span><br></pre></td></tr></table></figure></div><p>当c是标准关联容器，<strong>使用任何名为remove的操作都是完全错误的</strong>。这样的容器没有名为remove的函数<br>对于关联容器</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; c3;</span><br><span class="line">c3.erase(<span class="number">1963</span>); <span class="comment">// 当c3是标准关联容器时，erase成员函数是删除特定值元素的最好办法</span></span><br></pre></td></tr></table></figure></div><p>如果要在循环中操作，总结如下：</p><ol><li>如果容器是一个标准序列容器，则写一个循环来遍历容器中的元素，记住每次调用erase时，要用它的返回值更新迭代器；</li></ol><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::ofstream logFile;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator i = c1.begin(); i != c1.end();) &#123;</span><br><span class="line"><span class="keyword">if</span> (badValue(*i)) &#123;</span><br><span class="line">logFile &lt;&lt; <span class="string">"Erasing "</span> &lt;&lt; *i &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">i = c1.erase(i); <span class="comment">// 把erase的返回值赋给i，使i的值保持有效</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> ++i;</span><br></pre></td></tr></table></figure></div><p>因为对于这类容器，调用erase会使被删除元素和他之后的所有迭代器失效，而erase的返回值正是我们所需要的，一旦erase完成，它的返回值是指向被删除元素的下一个元素的有效迭代器。</p><ol start="2"><li>如果容器是一个标准关联容器，则写一个循环来遍历容器中的元素，记住当把迭代器传给erase时，要对迭代器做后缀递增。</li></ol><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::ofstream logFile;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator i = c3.begin(); i != c3.end();) &#123;</span><br><span class="line"><span class="keyword">if</span> (badValue(*i)) &#123;</span><br><span class="line">logFile &lt;&lt; <span class="string">"Erasing "</span> &lt;&lt; *i &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// 写日志文件</span></span><br><span class="line">c3.erase(i++); <span class="comment">// 对坏值，把当前的i传给erase，递增i是副作用</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> ++i;              <span class="comment">// 对好值，则简单第递增i</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>因为对于这类容器，调用erase会使被删除元素的所有迭代器失效，<s>而对于关联容器，erase的返回值是void</s>(c<ins>11也返回下一个位置的迭代器啦)。我们采用后缀递增的技术。我们要确保在调用erase之前，有一个迭代器指向容器中的下一个元素。我们采用了c3.erase(i</ins>)，这个过程可以分为三个部分(<a href="https://blog.csdn.net/yousss/article/details/80077758" target="_blank" rel="noopener">https://blog.csdn.net/yousss/article/details/80077758</a>)<br>1、先把i的值赋值给一个临时变量做为传递给erase的参数变量</p><p>2、因为参数处理优先于函数调用，所以接下来执行了i++操作，也就是i现在已经指向了下一个地址。</p><p>3、再调用erase函数，释放掉第一步中保存的要删除的it的值的临时变量所指的位置。</p><ol start="14"><li>使用reserve来避免不必要的重新分配</li></ol><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">v.reserve(<span class="number">1000</span>); <span class="comment">// 如果不使用reserve,下面的循环在进行过程中将导致2到10次重新分配;加上reserve，则在循环过程中,将不会再发生重新分配</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">1000</span>; ++i) </span><br><span class="line">v.push_back(i);</span><br></pre></td></tr></table></figure></div><ul><li><p>对于vector和string，增长过程是这样来实现的：每当需要更多空间时，就调用与realloc类似的操作。这一类似于realloc的操作分为四部分：(1).分配一块大小为当前容量的某个倍数的新内存。在大多数实现中，vector和string的容量每次以2的倍数增长，即，每当容器需要扩张时，它们的容量即加倍。<br>(2).把容器的所有元素从旧的内存拷贝到新的内存中。<br>(3).析构掉就内存中的对象。<br>(4).释放旧内存。</p></li><li><p>resize()函数（强迫容器改变到n个元素的状态）：<br>-如果 n &lt; size 容器末尾的元素被析构<br>-如果 n &gt; size 通过默认构造函数创建的新元素将被添加到容器的末尾<br>-如果 n &gt; capacity 则在添加元素前，将重新分配</p></li><li><p>reserve函数（强迫容器把它的容量至少变为n）：<br>如果 n &lt; capacity 忽略操作</p></li><li><p>reserve成员函数能使你把重新分配的次数减少到最低限度，从而避免了重新分配和指针/迭代器/引用失效带来的开销。避免重新分配的关键在于，尽早地使用reserve，把容器的容量设为足够大的值，最好是在容器刚被构造出来之后就使用reserve。</p></li><li><p>大小(size)和容量(capacity)的关系使我们能够预知什么时候插入操作会导致vector或string执行重新分配动作，进而使我们有可能预知一个插入操作什么时候会使容器中的迭代器、指针和引用失效。</p></li></ul><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s</span><br><span class="line"><span class="keyword">if</span>(s.size() &lt; s.capacity())&#123;</span><br><span class="line">s.push_back(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><ul><li>通常有两种方式来使用reserve以避免不必要的重新分配。第一种方式是，若能确切知道或大致预计容器中最终会有多少元素，则此时可以使用reserve。第二种方式是，先预留足够大的空间(根据你的需要而定)，然后，当把所有数据都加入以后，再去除多余的容量。</li></ul><ol start="15"><li><p>注意string实现的多样性<br>(1).string的值可能会被引用计数，也可能不会。很多实现在默认情况下会使用引用计数，但它们通常提供了关闭默认选择的方法，往往是通过预处理宏来做到这一点。<br>(2).string对象大小的范围可以是一个char* 指针大小的1倍到7倍。<br>(3).创建一个新的字符串值可能需要零次、一次或两次动态分配内存。<br>(4).string对象可能共享，也可能不共享其大小和容量信息。<br>(5).string可能支持，也可能不支持针对单个对象的分配子。<br>(6).不同的实现对字符内存的最小分配单位有不同的策略。</p></li><li><p>了解如何把vector和string数据传给旧的API</p></li></ol><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="keyword">if</span> (!v.empty()) &#123;</span><br><span class="line">doSomething(&amp;v[<span class="number">0</span>], v.size());</span><br><span class="line"><span class="comment">// doSomething(v.begin(), v.size()); // 错误的用法</span></span><br><span class="line">doSomething(&amp;*v.begin(), v.size()); <span class="comment">// 可以，但不易于理解</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>C++标准要求vector中的元素存储在连续的内存中，就像数组一样。string中的数据不一定存储在连续的内存中，而且string的内部表示不一定是以空字符结尾的。</p><ol start="17"><li>使用”swap技巧”除去多余的容量</li></ol><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Contestant&gt; contestants;</span><br><span class="line"><span class="comment">// ... // 让contestants变大，然后删除它的大部分元素</span></span><br><span class="line"><span class="comment">// vector&lt;Contestant&gt;(contestants)创建一个临时矢量，vector的拷贝构造函数只为所拷贝的元素分配所需要的内存</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Contestant&gt;(contestants).swap(contestants);</span><br><span class="line"> </span><br><span class="line">contestants.shrink_to_fit(); <span class="comment">// C++11</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> s;</span><br><span class="line"><span class="comment">// ... // 让s变大，然后删除它的大部分字符</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span>(s).swap(s);</span><br><span class="line"> </span><br><span class="line">s.shrink_to_fit(); <span class="comment">// C++11</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Contestant&gt;().swap(contestants); <span class="comment">// 清除contestants并把它的容量变为最小</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span>().swap(s); <span class="comment">// 清除s并把它的容量变为最小</span></span><br></pre></td></tr></table></figure></div><ol start="18"><li><p>避免使用vector<bool><br>作为一个STL容器，vector<bool>只有两点不对。首先，它不是一个STL容器；其次，它并不存储bool。除此以外，一切正常。</bool></bool></p></li><li><p>理解相等(equality)和等价(equivalence)的区别<br>相等的概念是基于operator==的。等价关系是以”在已排序的区间中对象值的相对顺序”为基础的。标准关联容器是基于等价而不是相等。</p></li></ol><p>标准关联容器总是保持排列顺序的，所以每个容器必须有一个比较函数(默认为less)来决定保持怎样的顺序。等价的定义正是通过该比较函数而确定的，因此，标准关联容器的使用者要为所使用的每个容器指定一个比较函数(用来决定如何排序)。如果该关联容器使用相等来决定两个对象是否有相同的值，那么每个关联容器除了用于排序的比较函数外，还需要另一个比较函数来决定两个值是否相等。(默认情况下，该比较函数应该是equal_to，但equal_to从来没有被用作STL的默认比较函数。当STL中需要相等判断时，一般的惯例是直接调用operator==)。</p><p>C++标准对于等价的值(对multiset)或键(对multimap)的相对顺序没有什么限制。</p><ol start="20"><li>为包含指针的关联容器指定比较类型<br>每当你要创建包含指针的关联容器时，一定要记住，容器将会按照指针的值进行排序。绝大多数情况下，这不会是你所希望的，所以你几乎肯定要创建自己的函数子类作为该容器的比较类型(comparison type)。<br>比如：</li></ol><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>*&gt;ssp;</span><br><span class="line">ssp.insert(<span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">"Anteater"</span>));</span><br><span class="line">ssp.insert(<span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">"Wombat"</span>));</span><br><span class="line">ssp.insert(<span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">"Lemur"</span>));</span><br><span class="line">ssp.insert(<span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">"Penguin"</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">set</span>&lt;<span class="built_in">string</span>*&gt;::const_iterator i = ssp.begin(); i != ssp.end(); ++i)</span><br><span class="line">&#123;</span><br><span class="line">count &lt;&lt; *i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>然而这个打印出来的不会是字符串，而是4个十六进制数—他们是指针的值。<br>即使我们改成</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">count &lt;&lt; **i &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></div><p>这个打印出来不是我们期待的首字母排序的那样,因为ssp会按指针的值排序。<br>为了解决这个问题，请记住</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span>&lt;<span class="built_in">string</span>*&gt; ssp;</span><br></pre></td></tr></table></figure></div><p>是如下代码的缩写</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span>&lt;<span class="built_in">string</span>*, less&lt;<span class="built_in">string</span>*&gt;, allpcator&lt;<span class="built_in">string</span>*&gt; ssp;</span><br></pre></td></tr></table></figure></div><p>分配子与当前问题无关，所以不考虑。</p><p><em>那么如何创建函数子类？</em><br>最直观的是写一个比较函数，比如：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">stringPtrLess</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>* ps1, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>* ps2)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> *ps1 &lt; *ps2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="built_in">string</span>, stringPtrLess&gt;</span><br></pre></td></tr></table></figure></div><p>但是这样无法通过编译，<strong>stringPtrLess不是一个类型</strong>，所以我们需要创建一个类，并在内部为它创建一个函数，如下就可以啦</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DereferenceLess</span> &#123;</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> PtrType&gt;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(PtrType pT1, PtrType pT2)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> *pT1 &lt; *pT2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>*, DereferenceLess&gt; ssp; <span class="comment">// 与std::set&lt;std::string*, StringPtrLess&gt; ssp;的行为相同</span></span><br></pre></td></tr></table></figure></div><p>如果你有一个包含智能指针或迭代器的容器，那么你也要考虑为它指定一个比较类型。对指针的解决方案同样也适用于那些类似指针的对象。就像DereferenceLess适合作为包含<code>T*</code>的关联容器的比较类型一样，对于容器中包含了指向T对象的迭代器或智能指针的情形，DereferenceLess也同样可用作比较类型。</p><ol start="21"><li><p>总是让比较函数在等值情况下返回false</p></li><li><p>切勿直接修改set或multiset中的键<br>对于map和multimap尤其简单，因为如果有程序试图改变这些容器中的键，它将不能通过编译。这是因为，对于一个map&lt;K, V&gt;或multimap&lt;K, V&gt;类型的对象，其中的元素类型是pair&lt;const K, V&gt;。因为键的类型是const K，所以它不能被修改。(如果利用const_cast，你或许可以修改它。)</p></li><li><p>考虑用排序的vector替代关联容器<br>对于许多应用，哈希容器可能提供常数时间的查找能力优于set、multiset、map和multimap的确定的对数时间查找能力。</p></li></ol><p>比如我们需要一个容器来存储Widget对象，如果我们用关联容器，则每个节点不仅包含了一个Widget，而且还包含了几个指针：一个指向左儿子，另一个指向右儿子，通常还有一个指向它的父节点，至少3个指针。</p><p>在排序的vector中可能在标准关联容器中存储同样的数据耗费更少的内存，考虑到页面错误的因素，通过二分搜索法查找一个排序的vector可能比查找一个标准关联容器更快一些。</p><p><strong>查找操作几乎从不跟插入和删除操作混在一起时，再考虑使用排序的vector而不是关联容器才是合理的</strong>。否则，使用排序的vector而不是标准关联容器几乎肯定是在浪费时间。</p><ol start="24"><li>当效率至关重要时，请在map::operator[]与map::insert之间谨慎做出选择<br>map的operator[]函数与众不同。它与vector、deque和string的operator[]函数无关，与用于数组的内置operator[]也没有关系。相反，map::operator[]的设计目的是为了提供”添加和更新”(add or update)的功能。map::operator[]返回一个引用。</li></ol><p><strong>对效率的考虑使我们得出结论：当向映射表中添加元素时，要优先选用insert，而不是operator[]；而从效率和美学的观点考虑，结论是：当更新已经在映射表中的元素的值时，要优先选择operator[]。</strong></p><ol start="25"><li></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://sunxin18.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="STL" scheme="https://sunxin18.github.io/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>DFS 困难问题合集</title>
    <link href="https://sunxin18.github.io/2020/09/19/DFS-hard/"/>
    <id>https://sunxin18.github.io/2020/09/19/DFS-hard/</id>
    <published>2020-09-19T10:53:00.000Z</published>
    <updated>2020-09-29T02:27:41.583Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ol start="37"><li>解数独<br>用col, row, block来分别表示每一列/行/块是否有数i，先对所以可填入的位置做一个登记，存入board容器，如果有一层dfs可以填满所以空位置就可以return<br>，valid这里也可以用来提前结束</li></ol><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">bool</span> col[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line">    <span class="keyword">bool</span> row[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line">    <span class="keyword">bool</span> block[<span class="number">3</span>][<span class="number">3</span>][<span class="number">9</span>];</span><br><span class="line">    <span class="keyword">bool</span> valid;</span><br><span class="line">    <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt;spaces;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pos == spaces.size())&#123;</span><br><span class="line">            valid = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i = spaces[pos].first;</span><br><span class="line">        <span class="keyword">int</span> j = spaces[pos].second;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> t = <span class="number">1</span>;t &lt;= <span class="number">9</span>; t++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!row[i][t - <span class="number">1</span>] &amp;&amp; !col[j][t - <span class="number">1</span>] &amp;&amp; !block[i/<span class="number">3</span>][j/<span class="number">3</span>][t<span class="number">-1</span>] &amp;&amp; !valid)&#123;</span><br><span class="line">                board[i][j] = t + <span class="string">'0'</span>;</span><br><span class="line">                row[i][t - <span class="number">1</span>] =  col[j][t - <span class="number">1</span>] = block[i/<span class="number">3</span>][j/<span class="number">3</span>][t<span class="number">-1</span>] = <span class="literal">true</span>;</span><br><span class="line">                dfs(board , pos + <span class="number">1</span>);</span><br><span class="line">                row[i][t - <span class="number">1</span>] =  col[j][t - <span class="number">1</span>] = block[i/<span class="number">3</span>][j/<span class="number">3</span>][t<span class="number">-1</span>] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solveSudoku</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(col, <span class="literal">false</span>, <span class="keyword">sizeof</span>(col));</span><br><span class="line">        <span class="built_in">memset</span>(col, <span class="literal">false</span>, <span class="keyword">sizeof</span>(row));</span><br><span class="line">        <span class="built_in">memset</span>(col, <span class="literal">false</span>, <span class="keyword">sizeof</span>(block));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] == <span class="string">'.'</span>)&#123;</span><br><span class="line">                    <span class="keyword">auto</span> p = make_pair(i, j);</span><br><span class="line">                    spaces.push_back(p);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    row[i][board[i][j] - <span class="string">'0'</span> - <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">                    col[j][board[i][j] - <span class="string">'0'</span> - <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">                    block[i/<span class="number">3</span>][j/<span class="number">3</span>][board[i][j] - <span class="string">'0'</span> - <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(board, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><ol start="47"><li>全排列 II<br>这道题是一道中等难度题，但这里也放到了困难，这道题对理解递归过程很好。<br>最简单的思想就是先排列出所有可能的组合，再进行去重，但这复杂度很高，很多递归分支是没有必要的。比如我们开始搜索到第i个位置，有两个重复的1，在这里选这两个1的效果是一样的就可以剪枝，所以对于重复的数我们只选择一次，这个通过先对数组排序再进行判断后一个和前面的相等就可以跳过即可.<br>我们还要标记一下使用过得元素防止重复使用</li></ol><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;res;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cur, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; used)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur.size() == nums.size())&#123;</span><br><span class="line">            res.push_back(cur);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; used[i - <span class="number">1</span>] == <span class="number">0</span>)&#123;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(used[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                used[i] = <span class="number">1</span>;</span><br><span class="line">                cur.push_back(nums[i]);</span><br><span class="line">                dfs(cur, nums, used);</span><br><span class="line">                cur.pop_back();</span><br><span class="line">                used[i] = <span class="number">0</span>;</span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; permuteUnique(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; used(n);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;cur;</span><br><span class="line">        dfs(cur, nums, used);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="DFS" scheme="https://sunxin18.github.io/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>二叉树专题</title>
    <link href="https://sunxin18.github.io/2020/07/29/binary-tree/"/>
    <id>https://sunxin18.github.io/2020/07/29/binary-tree/</id>
    <published>2020-07-29T12:43:30.000Z</published>
    <updated>2020-10-28T08:26:31.076Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ol start="236"><li>二叉树的最近公共祖先</li></ol><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TreeNode* ans;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">bool</span> lson = dfs(root-&gt;left, p, q);</span><br><span class="line">        <span class="keyword">bool</span> rson = dfs(root-&gt;right, p, q);</span><br><span class="line">        <span class="keyword">if</span> ((lson &amp;&amp; rson) || ((root-&gt;val == p-&gt;val || root-&gt;val == q-&gt;val) &amp;&amp; (lson || rson))) &#123;</span><br><span class="line">            ans = root;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> lson || rson || (root-&gt;val == p-&gt;val || root-&gt;val == q-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        dfs(root, p, q);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><ol start="114"><li>二叉树展开为链表</li></ol><ul><li>将左子树插入到右子树的地方</li><li>将原来的右子树接到左子树的最右边节点</li><li>考虑新的右子树的根节点，一直重复上边的过程，直到新的右子树为 null<br><strong>记得吧左子树置空</strong></li></ul><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        TreeNode* pre=root;</span><br><span class="line">        <span class="keyword">while</span>(root!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            pre=root-&gt;left;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;left!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(pre-&gt;right!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                pre=pre-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            pre-&gt;right=root-&gt;right;</span><br><span class="line">            root-&gt;right=root-&gt;left;</span><br><span class="line">            root-&gt;left=<span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        root=root-&gt;right;</span><br><span class="line">      &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><ol start="501"><li>二叉搜索树中的众数<br>第一种方法就是遍历一遍吧每个数出现的次数记录一下，然后换到vector来排序一下</li></ol><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">searchBST</span><span class="params">(TreeNode* cur, <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&amp; <span class="built_in">map</span>)</span> </span>&#123; <span class="comment">// 前序遍历</span></span><br><span class="line">    <span class="keyword">if</span> (cur == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">map</span>[cur-&gt;val]++; <span class="comment">// 统计元素频率</span></span><br><span class="line">    searchBST(cur-&gt;left, <span class="built_in">map</span>);</span><br><span class="line">    searchBST(cur-&gt;right, <span class="built_in">map</span>);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="keyword">static</span> <span class="title">cmp</span> <span class="params">(<span class="keyword">const</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&amp; a, <span class="keyword">const</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.second &gt; b.second;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findMode(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> result;</span><br><span class="line">        searchBST(root, <span class="built_in">map</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; vec(<span class="built_in">map</span>.begin(), <span class="built_in">map</span>.end());</span><br><span class="line">        sort(vec.begin(), vec.end(), cmp); <span class="comment">// 给频率排个序</span></span><br><span class="line">        result.push_back(vec[<span class="number">0</span>].first);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; vec.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (vec[i].second == vec[<span class="number">0</span>].second) result.push_back(vec[i].first);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><p>上面的代码可以优化，省掉闯创建vec和对vec排序的过程（上面这个主要是为了展示怎么对pair写排序），就是存储map的时候，同时记录最大值max，然后遍历map找到所有value为max的key就好了</p><p>再进一步优化空间就是采用递归充分利用二叉搜索树的性质，</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;res;</span><br><span class="line">    <span class="keyword">int</span> imax = <span class="number">0</span>,count = <span class="number">0</span>;</span><br><span class="line">    TreeNode* pre;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* cur)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="literal">NULL</span>)<span class="keyword">return</span>;</span><br><span class="line">        dfs(cur-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(pre == <span class="literal">NULL</span>)&#123; </span><br><span class="line">            count = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pre-&gt;val == cur-&gt;val)&#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            count = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(count == imax)</span><br><span class="line">                res.push_back(cur-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>(count &gt; imax)&#123;</span><br><span class="line">            res.clear();</span><br><span class="line">            res.push_back(cur-&gt;val);</span><br><span class="line">            imax = count;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = cur;</span><br><span class="line">        dfs(cur-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findMode(TreeNode* root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)<span class="keyword">return</span> res;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="二叉树" scheme="https://sunxin18.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
</feed>
